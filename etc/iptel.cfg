#
# $Id$
#
# iptel.org real world configuration
#

# ----------- global configuration parameters ------------------------

debug=3          # debug level (cmd line: -dddddddddd)
fork=yes
#fork=no
log_stderror=no	# (cmd line: -E)
#log_stderror=yes	# (cmd line: -E)
check_via=yes     # (cmd. line: -v)
dns=on           # (cmd. line: -r)
rev_dns=yes      # (cmd. line: -R)
port=5060
#port=8060
children=16

# advertise IP address in Via (as opposed to advertising DNS name
# which is annoying for downstream servers and some phones can
# not handle DNS at all)
listen=195.37.77.101

# ------------------ module loading ----------------------------------

loadmodule "../sip_router/modules/sl/sl.so"
loadmodule "../sip_router/modules/print/print.so"
#loadmodule "../sip_router/modules/tm/tm.so"
loadmodule "../sip_router/modules/acc/acc.so"
loadmodule "../sip_router/modules/rr/rr.so"
loadmodule "../sip_router/modules/maxfwd/maxfwd.so"
loadmodule "../sip_router/modules/mysql/mysql.so"
loadmodule "../sip_router/modules/usrloc/usrloc.so"
loadmodule "../sip_router/modules/auth/auth.so"
loadmodule "../sip_router/modules/cpl/cpl.so"

# ----------------- setting module-specific parameters ---------------

# -- usrloc params --

modparam("usrloc", "use_database",   1)
modparam("usrloc", "table",          "location")
modparam("usrloc", "user_column",    "user")
modparam("usrloc", "contact_column", "contact")
modparam("usrloc", "expires_column", "expires")
modparam("usrloc", "q_column",       "q")
modparam("usrloc", "callid_column",  "callid")
modparam("usrloc", "cseq_column",    "cseq")
modparam("usrloc", "flush_interval", 10)
modparam("usrloc", "db_url",         "sql://csps:47csps11@dbhost/csps107")

# -- auth params --

modparam("auth", "db_url",        "sql://csps:47csps11@dbhost/csps107")
modparam("auth", "user_column",   "user_id")
# nonce generation secret; particularly useful if multiple servers
# in a proxy farm are configured to authenticate
modparam("auth", "secret",        "439tg8h349g8hq349t9384hg")
# calculate_ha1=false means password column includes ha1 strings;
# if it was false, plain-text passwords would be assumed

# the database credentials in hashed form
modparam("auth", "calculate_ha1", false)
modparam("auth", "password_column", "ha1")
# password_column, realm_column, group_table, group_user_column,
#   group_group_column are set to their default values
# password_column_2 allows to deal with clients who put domain name
#   in authentication credentials when calculate_ha1=false (if true,
#   it works); if set to a value and USER_DOMAIN_HACK was enabled
#   in defs.h, authentication will still work
modparam("auth", "password_column_2", "ha1b")

# the database in plain-text alternative:
#modparam("auth", "calculate_ha1", true )
#modparam("auth", "password_column", "password")

modparam("auth", "nonce_expire",  300)
modparam("auth", "retry_count",   3)

# -- acc params --
# report ACKs too for sake of completeness -- as we account PSTN
# destinations which are RR, ACKs should show up
modparam("acc", "report_ack", 1)
# don't bother me with early media reports (I don't like 183 
# too much anyway...ever thought of timer C hitting after
# listening to music-on-hold for five minutes?)
modparam("acc", "early_media", 0)
modparam("acc", "log_level", 1)
# that is the flag for which we will account -- don't forget to
# set the same one :-)
modparam("acc", "acc_flag", 1 )
# we are interested only in succesful transactions
modparam("acc", "failed_transactions", 0 )

# -- tm params --
modparam("tm", "fr_timer", 30 )
modparam("tm", "fr_inv_timer", 60 )

# -------------------------  request routing logic -------------------

# main routing logic

route{

	# filter local stateless ACK generated by authentication of mf replies
	sl_filter_ACK();

	# filter too old messages
	log("LOG: Checking maxfwd\n");
	if (!mf_process_maxfwd_header("10")) {
		log("LOG: Too many hops\n");
		sl_send_reply("483","Too Many Hops");
		break;
	};

	# len_gt *after* max_fwd, otherwise an "INVITE sip:sos@0.0.0.0"
	# will cause "message too big" for a short message

	if (len_gt( max_len )) {
		sl_send_reply("513", "Riesengross -- Message too large");
		break;
	};


	/* IM gateways */
	if (uri=~"sip:.*@icq\.iptel\.org") {
		forward( 195.37.77.100, 5080 );
		break;
	};
	if (uri=~"sip:.*@msn\.iptel\.org") {
		forward( 195.37.77.100, 5080 );
		break;
	};

	# -------------------- testing accounts ----------------
#XX
	if (uri=~"sip:333.*@iptel\.org") {
		forward( 195.113.147.6, 5060 );
		break;
	} ;

	if (uri=~"sip:everloop@iptel\.org") {
		t_relay();
		break;
	}	;

	if (uri=~"sip:looptester@iptel\.org") {
		seturi("sip:lt0@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt0@iptel\.org") {
		seturi("sip:lt1@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt1@iptel\.org") {
		seturi("sip:lt2@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt2@iptel\.org") {
		seturi("sip:lt3@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt3@iptel\.org") {
		seturi("sip:lt4@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt4@iptel\.org") {
		seturi("sip:lt5@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt5@iptel\.org") {
		seturi("sip:lt6@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt6@iptel\.org") {
		seturi("sip:lt7@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt7@iptel\.org") {
		seturi("sip:lt8@iptel.org");
		t_relay();
		break;
	} ; if (uri=~"sip:lt8@iptel\.org") {
#	}   else if (uri=~"sip:lt8@iptel\.org") {
		seturi("sip:lt9@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt9@iptel\.org") {
		seturi("sip:lt0@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lt0@iptel\.org") {
		seturi("sip:lta@iptel.org");
		t_relay();
		break;
	} else if (uri=~"sip:lta@iptel\.org") {
		seturi("sip:ltb@iptel.org");
		t_relay();
		break;
	};
	# -------------------- Eo testing account ----------------

	# Do strict routing if route headers present
	rewriteFromRoute();

	# divert voicemail requests
    if (uri=~"mail\.iptel\.org" | uri=~":5066"| uri=~":6060") {
		log("Request is for voicemail\n");
		sethost("iptel.org");
#		t_relay_to("fox.iptel.org", "5066");
		if ( !t_relay_to("fox.iptel.org", "6060")) {
			sl_reply_error();
		};
		break;
	};

	# look at whether we need record-routing; 
	# - we need it for calls  from gateways (otherwise, subsequent 
	#   requests from the other # party will attempt to contact gateway 
	#  	directly through blocked ports)
	# - we need it for Windows Messanger's IM sessions to cross
	#   firewalls -- we force all MESSAGEs to go via our server
	#   to avoid blocking port numbers (some firewalls can do
	#   standard SIP but are puzzled by Microsoft's proprietary
	#   messaging session model)
	# - some other places may decide to set the record-routing
	#   flag (2 chosen) too; particularly, INVITEs to our gw
	if ( (src_ip==195.37.77.110 & method=="INVITE") || method=="MESSAGE" || method=="INFO" )  {
		setflag(2);
	};


	# if this request is not for our domain, fall over to
	# outbound request processing; include gateway's address
	# in matching too -- we RR requests to it, so that
	# its address may show up in subsequent requests
	# after rewriteFromRoute

	# sign of our domain: there is @ (username), :
    # (nothing) or . (host) in front of our domain name	
#XX
#	if (!(uri=~"[@:\.]iptel\.org([;:].*)*" 
	if (!(uri=~"[@:]iptel\.org([;:].*)*" 
		| uri=~"[@:\.]195\.37\.77\.101([;:].*)*" |
		uri=~"@195\.37\.77\.110([;:].*)*" )) {
		route(2);
		# break from route (2) return -- stop then !
		break;
	};
	# here we continue with requests for our domain...

	# various aliases (might use a database in future)
#XX
#	lookup_contact("aliases");
	if (uri=~"sip:9040@") {
		seturi("sip:jirih@iptel.org");
	};
	if (uri=~"sip:9042@") {
		seturi("sip:sisalem@iptel.org");
	};
	if (uri=~"sip:17@") {
		seturi("sip:henry@siptest.wcom.com");
	};
	if (uri=~"sip:jirim@"  ) {
		seturi("sip:001795061546@iptel.org");
	};
	if ( uri=~"sip:info@" ) {
		seturi("sip:jiri@mail.iptel.org");
	};
	# check again, if it is still for our domain after aliases
#XX
#	if ( !(uri=~"[@:\.]iptel\.org([;:].*)*" | 
	if ( !(uri=~"[@:]iptel\.org([;:].*)*" | 
		uri=~"[@:\.]195\.37\.77\.101([;:].*)*" |
		uri=~"@195\.37\.77\.110([;:].*)*" )) {
		route(2);
		# break from route (2) return -- stop then !
		break;
	};
	log("LOG Request is for iptel.org\n");	

	# registers always MUST be authenticated to
	# avoid stealing incoming calls	
	if (method=="REGISTER") {
		log("LOG Request is REGISTER\n");
		# prohibit attempts to grab someone else's To address 
		# using  valid credentials; the only exception is the user
		# 'replciator' permitted to generate 3-rd party registrations

##XX allow REGISTERs without authentication from localhost

		if (! src_ip==195.37.77.101 ) {

		if (!www_authorize(	"iptel.org" /* realm */, 
			 				"subscriber" /* table name */ )) {
			log("LOG: REGISTER has no credentials, sending challenge\n");
 			www_challenge(	"iptel.org" /* realm */, 
							"0" /* no qop -- M$ can't deal with it */);
			break;
		};

		if (!is_user("replicator") & !check_to()) {
			log("LOG: To Cheating attempt\n");
			sl_send_reply("403", "That is ugly -- use To=id next time");
			break;
		};

#XX
		};
			

		# update Contact database
       	log("LOG: REGISTER is authorized, saving location\n");
		save_contact("location");
		break;
	};

	# now check if it's about PSTN destinations through our gateway;
	# note that 8.... is exempted for numerical destinations
	if (uri=~"sip:\+?[0-79][0-9]*@.*") {
		route(3);
		# break from route (3) return -- stop then !
		break;
	}; 

	# ---------- CPL demo - begin --------------
	/* added by Bogdan for cpl demo - Dorgham request*/
	if (uri=~"sip:test@.*")
	{
		if (method=="INVITE")
		{
			if (! t_newtran()) {
    			# retransmit whatever we have
    			t_retransmit_reply();
			} else {
    			# do what you want to do
				if ( cpl_run_script() ) {
                	if ( cpl_is_response_reject() ) {
                    	log("SER: reject");
                    	sl_send_reply("603","I am not available!");
                    	break;
                	}else if ( cpl_is_response_redirect() ) {
                    	log("SER : redirect\n");
                    	cpl_update_contact();
                    	sl_send_reply("302","Moved temporarily");
                    	break;
                	};
	    		} else {
        			if (!t_send_reply("500", "error :-(")) {
            			# if replying failed, retry statelessly
            			sl_reply_error();
        			};
    			};
    			# transaction concluded -- junk it now
    			t_release();
			};
			t_unref();
			break;
		};
		if (method=="MESSAGE")
		{
			seturi("sip:491713042053@iptel.org");
			t_relay_to("bat.iptel.org","5070");
			break;
		};
	};
	# -------------- CPL demo - end -------------
	# ---------- forking demo2 - begin --------------
	if (uri=~"sip:cebit@.*" & method=="INVITE") {
		# Cisco phone on Jiri's desktop; Caution: DHCP address,
		#  subject to change
		seturi("sip:cebit@195.37.78.242");
		# Jiri's desktop PC; Caution: DHCP address,
		#  subject to change
		# t_fork_to_uri("sip:cebit@195.37.78.126");
		# gateway address; Caution: is PSTN number changes, it must
		#   on the list of free destination bellow; otherwise the
		#   caller will be challenged!
		t_fork_to_uri("sip:001795061546@195.37.77.110");
		#t_fork_to_uri( "sip:0016097265544@195.37.77.110");


		t_fork_on_no_response("sip:cebit@mail.iptel.org");
	
		if (!t_relay()) {
			sl_reply_error();
		};
		break;
	};
	# ---------- forking demo2 - end  --------------

	# native SIP destinations are handled using our USRLOC DB
	if (!lookup_contact("location")) {
		if (method=="ACK") {
			log("Ooops -- an ACK made it here -- probably UAC screwed up to-tags\n");
			break;
		};
		log("LOG: Unable to lookup contact, sending 404\n");
		sl_send_reply("404", "Not Found");
		break;
	};
	# check whether some inventive user has uploaded  gateway 
	# contacts to UsrLoc to bypass our authorization logic
	if (uri=~"@195\.37\.77\.110([;:].*)*" ) {
		log("LOG: Weird! Gateway address in UsrLoc!\n");
		route(3);
		# break from route (3) return -- stop then !
		break;
	};

	# requests from gateway should be RR-ed too
	if (isflagset(2)) {
		addRecordRoute();
	};

	# we now know we may, we know where, let it go out now!
	if (!t_relay()) {
		sl_reply_error();
		break;
	};
}
#---------------------------------------------------------------------

# routing logic for outbound requests targeted out of our domain
# (beware, messages to our users can end up here too: for example,
#  an INVITE may be UsrLoc-ed, then the other party uses outbound
#  proxy with r-uri=the usr_loced addredd (typically IP))
route[2] {
		# outbound requests are allowed only for our users -- we don't
		# support relaying and don't like strangers bothering us
		# with resolving DNS
		log("LOG: that's a request to outside");
#XX (allow unauthenticated requests from localhost for testing)
		if (! src_ip==195.37.77.101 ) {
		if (!(src_ip==195.37.77.110) & 
			!(proxy_authorize(	"iptel.org" /* realm */,
							"subscriber" /* table name */ ))) {
			# see comments bellow on these ACK/CANCEL exceptions
			if (method=="ACK" ) {
				log("LOG: failed outbound authentication for ACK granted\n");
			} else if (method=="CANCEL") {
				log("LOG: failed outbound authentication for CANCEL granted\n");
			} else {
				proxy_challenge("iptel.org" /* realm */, "0" /* no-qop */);
				break;
			};
		};
		# to maintain credibility of our proxy, we check From in INVITEs to be
		# equal to credential id  so that user john.doe does not put bill.gates
		# in his From; we don't do that for other requests: within a dialogue,
		# subsequent transactions coming from the other side will have in From
		# To of the original transaction to match the dialog; it may be 
		# however different from user's default From and digest; example:
		# user_a sends INVITE to secretary; secretary is translated to user_b;
		# user_b accepts and later BYEs; to match the dialog, it puts
		# secretary in From and sends user_b's credentials -- check_from
		# would fail
		if (!src_ip==195.37.77.110 & method=="INVITE" & !check_from()) {
			log("LOG: From Cheating attempt\n");
			sl_send_reply("403", "That is ugly -- use From=id next time (OB)");
			break;
		};
#XX
		};

		# requests from gateway should be RR-ed too
		if (isflagset(2)) {
			addRecordRoute();
		};
		if (!t_relay()) {
			sl_reply_error();
			break;
		};
}

#---------------------------------------------------------------------

# logic for calls through our PSTN gateway
route[3] {
	# the international + prefix
	if (uri=~"sip:\+" ) {
		strip(1);
		prefix("000");
	};
	# free call destinations ... no authentication needed
	if (uri=~"sip:001795061546@.*" | uri=~"sip:0016097265544.*" 
		| uri=~"sip:[79][0-9][0-9][0-9]@.*" 
		| uri=~"sip:98[0-9][0-9][0-9][0-9]") {
		log("LOG: Free PSTN\n");
		# let's log free calls for now too ...
		setflag(1);
	} else {
		# all other PSTN destinations only for authenticated users
		# (Cisco GW, which has no digest support, is authenticated
		# by its IP address -- that's for sure not very strong;
		# wth confirmed that we filter packets coming from outside
		# and bearing SRC IP address of our network)
		# we are forgiving about ACK/CANCEL as digest provides no
		# real security for them
		log("LOG: PSTN\n");
		if (!(src_ip==195.37.77.110 | method==ACK | method=="CANCEL" )) {
			if (!proxy_authorize(	"iptel.org" /* realm */,
								"subscriber" /* table name */))  {
				proxy_challenge( "iptel.org" /* realm */, "0" /* no qop */ );
				break;
			# let's check from=id ... avoids accounting confusion
			} else if (method=="INVITE" & !check_from()) {
				log("LOG: From Cheating attempt\n");
				sl_send_reply("403", "That is ugly -- use From=id next time (gw)");
				break;
			};
		};

		# authorize only for INVITEs -- RR/Contact may result in weird
		# things showing up in d-uri that would break our logic; our
		# major concern is INVITE which causes PSTN costs anyway

		if (method=="INVITE") {

			# does the authenticated user have a permission for local
			# calls? (i.e., is he in the "local" group?)
			if (uri=~"sip:0[1-9][0-9]+@.*") {
				if (!is_in_group("local")) {
					sl_send_reply("403", "Local Toodle Noodle...");
					break;
				};
			# the same for long-distance
			} else if (uri=~"sip:00[1-9][0-9]+@.*") {
				if (uri=~"sip:001[089]" | uri=~"sip:00900.*" ) {
					sl_send_reply("403", "Added Value Destinations not permitted...");
					break;
				};
				if (!is_in_group("ld")) {
					sl_send_reply("403", "LD Toodle Noodle...");
					break;
				};
			# the same for international calls
			} else if (uri=~"sip:000[1-9][0-9]+@.*") {
				if (!is_in_group("int")) {
					sl_send_reply("403", "International Toodle Noodle...");
					break;
				};
			# everything else (e.g., interplanetary calls) is denied
			} else {
				sl_send_reply("403", "interplanetary Toodle Noodle...");
				break;
			};

		}; # INVITE to authorized PSTN

		# we passed all authorization checks for PSTN -- move on!
		# tag this transaction for accounting
		setflag(1);

	}; # authorized PSTN

	# requests to gateway must be record-route because the GW accepts
	# only reqeusts coming from our proxy
	if (isflagset(2) || method=="INVITE")
		addRecordRoute();

	# if you have passed through all the checks, let your call go to GW!

	# if it is a MESSAGE pass it over to our SMS gateway
	# (which unfortunately lives at a different host due to
	# lack of serial interfaces)
	if (method=="MESSAGE") {
		# note that we don't do any admission control yet:
		# anyone can SMS anywhere; 
		rewritehostport("195.37.77.100:5070");
	} else  {
		rewritehostport("195.37.77.110:5060");
	};


	if (!t_relay()) {
		sl_reply_error(); 
		break; 
	};
}

