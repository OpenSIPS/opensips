<!-- $Id$ -->
<!DOCTYPE Book PUBLIC "-//OASIS//DTD DocBook V4.2//EN">
<!-- DOCTYPE Book SYSTEM "/usr/share/sgml/docbook/dtd-4.2/docbook.dtd" -->

<book label="seruser" id="seruser" lang="EN">
<?dbhtml filename="index.html">
    <title>iptel.org SIP Express Router v0.8.8 -- User's Guide</title>
    <bookinfo>
	<authorgroup>
	    <author>
		<firstname>Jiri</firstname>
		<surname>Kuthan</surname>
		<email>jiri@iptel.org</email>
	    </author>
	    <author>
		<firstname>Jan</firstname>
		<surname>Janak</surname>
		<email>J.Janak@sh.cvut.cz</email>
	    </author>
	    <author>
		<firstname>Yacine</firstname>
		<surname>Rebahi</surname>
		<email>rebahi@fokus.fhg.de</email>
	    </author>

	</authorgroup>

	<copyright>
	    <year>2001</year>
	    <year>2002</year>
	    <holder>FhG Fokus</holder>
	</copyright>
	<legalnotice>
	    <para>
		This documentation is free software; you can redistribute
		it and/or modify it under the terms of the GNU General Public
 		License as published by the Free Software Foundation; either
		version 2 of the License, or (at your option) any later
		version.
	    </para>
	    
	    <para>
		This program is distributed in the hope that it will be
		useful, but WITHOUT ANY WARRANTY; without even the implied
		warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
		See the GNU General Public License for more details.
	    </para>
	    
	    <para>
		You should have received a copy of the GNU General Public
		License along with this program; if not, write to the Free
		Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
		MA 02111-1307 USA
	    </para>
	    
	    <para>
		For more details see the file COPYING in the source
		distribution of <acronym>SER</acronym>.
	    </para>	    
	</legalnotice>

	<abstract>
	    <para>
		The document describes the <acronym>SIP</acronym> Express Router and its use in
		<acronym>SIP</acronym> networks. It is intended as an aid to server 
		administrators. 
	    </para>
	</abstract>
	<releaseinfo>
	    This is a pre-release documentation of the SER SIP Server.
	    For the latest and most complete documentation, visit our
	    site at <ulink url="http://www.iptel.org/ser/">http://www.iptel.org/ser</ulink>
	</releaseinfo>
    </bookinfo>
    
    <toc></toc>
    
    <chapter id="general">
	<title>General Information</title>
	<section id="aboutser">
	    <title>About <acronym>SIP</acronym> Express Router (<acronym>SER</acronym>)</title>
	    <para>
		SIP Express Router (<acronym>SER</acronym>) is an industrial-strength, free VoIP 
		server based on the session initiation protocol (<acronym>SIP</acronym> RFC3261). 
		It is engineered to power <acronym>IP</acronym> telephony infrastructures up to large 
		scale. The server keeps track of users, sets up VoIP sessions, 
		relays instant messages and creates space for new plug-in applications. 
		Its proven interoperability guarantees seamless integration with 
		components from other vendors, eliminating the risk of a single-vendor 
		trap. It has successfully participated in various interoperability 
		tests in which it worked with the products of other leading <acronym>SIP</acronym> vendors.
	    </para>
	    <para>
		The <acronym>SIP</acronym> Express Router enables a flexible plug-in model for new 
		applications: Third parties can easily link their plug-ins with 
		the server code and provide thereby advanced and customized services. 
		In this way, plug-ins such as <acronym>SNMP</acronym> support, RADIUS accounting,
		or SMS gateway have already been developed and are provided as 
		advanced features. Other modules are underway: Presence server,
		firewall control, and more.
	    </para>
	    <para>
		Its performance and robustness allows it to serve millions of users 
		and accommodate needs of very large operators. With a $3000 dual-CPU, the 
		<acronym>SIP</acronym> Express Router is able to power <acronym>IP</acronym> telephony services in an area 
		as large as the Bay Area during peak hours. Even on an IPAQ <acronym>PDA</acronym>, the server 
		withstands 150 calls per second (<acronym>CPS</acronym>)! The server has been powering our 
		iptel.org free <acronym>SIP</acronym> site withstanding heavy daily load that is further 
		increasing with the popularity of Microsoft's Messenger.  
	    </para>
	    <para>
		The <acronym>SIP</acronym> Express Router is extremely configurable to allow the creation of 
		various routing and admission policies as well as setting up new and 
		customized services. Its configurability allows it to serve many roles: 
		network security barrier, application server, or <acronym>PSTN</acronym> gateway guard for 
		example.
	    </para>
	    <para>
		<application moreinfo="none">ser</application> can be also
		used with contributed applications. Currently, 
		<application moreinfo="none">sereb</application>, a
		<application moreinfo="none">ser</application> web interface
		and <application moreinfo="none">SIPSak</application>
		diagnostic tools are available. Visit our site, 
		http://www.iptel.org/, for more information on
		contributed packages.
	    </para>
	</section> 

	<section id="aboutiptel">
	    <title>About iptel.org</title>
	    <para>
		iptel.org is a know-how company spun off from Germany's national 
		research company FhG Fokus. One of the first <acronym>SIP</acronym> implementations ever, 
		low-QoS enhancements, interoperability tests and VoIP-capable firewall 
		control concepts are examples of well-known FhG's work.
	    </para>
	    <para>
		iptel.org continues to keep this know-how leadership in <acronym>SIP</acronym>. 
		The access rate of the company's site, a well-known source of 
		technological information, is a best proof of interest. Thousands 
		of hits come every day from the whole Internet.
	    </para>
	    
	</section> <!-- iptel -->
	<section id="serfeatures">
	    <title>Feature List</title>
	    <para>
		Based on the latest standards, the <acronym>SIP</acronym> Express Router (<acronym>SER</acronym>) includes 
		support for registrar, proxy and redirect mode. Further it acts as 
		an application server with support for <acronym>CPL</acronym>, instant messaging and 
		presence including a <acronym>2G/SMS</acronym> gateway, a call control policy 
		language, call number translation, private dial plans and accounting, 
		authorization and authentication (<acronym>AAA</acronym>) services. <acronym>SER</acronym> runs on Sun/Solaris, 
		PC/Linux, IPAQ/Linux platforms and supports  both <acronym>IPv4</acronym> and <acronym>IPv6</acronym>. 
		Hosting multiple domains and database redundancy is supported.
	    </para>
	    <para>
		Other extensions are underway: presence server, firewall control and more.
	    </para>
	    <para>
		ser has been carefuly engineered with the following design objectives in mind:
		<itemizedlist>
		    <listitem>
			<para>
			    <emphasis>Speed</emphasis> - With SER, thousands of calls per seconds are achievable 
			    even on low-cost platforms. This competitive capacity allows 
			    setting up networks which are inexpensive and easy to manage 
			    due to low number of devices required. The speed has been 
			    achieved by extensive code optimization, usage of customized code, 
			    <acronym>ANSI C</acronym> combined with assembly instructions and leveraging latest 
			    <acronym>SIP</acronym> improvements. When powered by a dual-CPU Linux PC, <application>ser</application> is able
to serve call signaling Bay Area population.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>Flexibility</emphasis> - <acronym>SER</acronym> allows its users to define its behavior. 
			    Administrators may write textual scripts which determine <acronym>SIP</acronym> routing 
			    decisions, the main job of a proxy server. They may use the script to 
			    configure numerous parameters and introduce additional logic. For example, 
			    the scripts can determine for which destinations record routing should be 
			    performed, who will be authenticated, which transactions should be processed 
			    statefuly, which requests will be proxied or redirected, etc.
			</para>

		    </listitem>
		    <listitem>
			<para>
			    <acronym>Extensibility</acronym> - <acronym>SER</acronym>'s extensibility allows linking of 
			    new C code to ser to 
			    redefine or extend its logic. The new code can be developed independently 
			    on <acronym>SER</acronym> core and linked to it in run-time. The concept is similar to 
			    the module concept known for example in Apache Web server. Even such essential parts such 
			    as transaction management have been developed as modules to keep the <acronym>SER</acronym> core 
			    compact and fast.
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Portability. Ser has been written in ANSI C. It has been extensively tested on PC/Linux and 
			    Sun/Solaris. 
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Interoperability. Ser is based on open SIP standard. It has undergone extensive testing with 
			    products of other vendors. It powers the public iptel.org site 24 hours a day, 356 days a year 
			    serving numerous SIP implementations using this site.
			</para>
		    </listitem>
		</itemizedlist>
	    </para>
	</section> <!-- serfeatures -->

	<section id="usecases">
	    <title>Use Cases</title>
	    <para>
		This section illustrates the most frequent uses of SIP. In all these scenarios, 
		the SIP Express Router (SER) can be easily deployed as the glue connecting all 
		SIP components together, be it softphones, hardphones, PSTN gateways or any other 
		SIP-compliant devices.
	    </para>
	    <section>
		<title>Added-Value ISP Services</title>
		<para>
		    To attract customers, ISPs frequently offer applications bundled with IP access. 
		    With SIP, the providers can conveniently offer a variety of services running on top 
		    of a single infrastructure. Particularly, deploying VoIP and instant messaging and 
		    presence services is as easy as setting up a SIP server and guiding customers to use 
		    Windows Messenger. Additionally, the ISPs may offer advanced services such as PSTN 
		    termination, user-driven call handling or unified messaging all using the same infrastructure.
		</para>
		<para>
		    SIP Express Router has been engineered to power large scale networks: its capacity can deal 
		    with large number of customers under high load caused by modern applications. Premium 
		    performance allows deploying a low number of boxes while keeping investments and operational 
		    expenses extremely low. ISPs can start by providing instant messaging services on this 
		    standardized platform. This can be combined with the SIP-to-SMS gateway service also supported 
		    by SER. In a second step VoIP services can be added in addition to voicemail services and  UMS.
		</para>
	    </section> <!-- Added-value ISP -->
	    <section>
		<title>PC2Phone</title>
		<para>
		    Internet Telephony Service Providers (ITSPs) offer the service of interconnecting 
		    Internet telephony users using PC softphone or appliances to PSTN. Particularly with 
		    long-distance and international calls, substantial savings can be achieved by 
		    routing the calls over the Internet.
		</para>
		<para>
		    SIP Express Router can be easily configured to serve pc2phone users, distribute
		    calls to geographically appropriate PSTN gateway, act as a security barrier and keep track of charging. 
		</para>
	    </section>
	    <section>
		<title>PBX Replacement</title>
		<para>
		    Replacing a traditional PBX in an enterprise can achieve reasonable 
		    savings. Enterprises can deploy a single infrastructure for both voice 
		    and data and bridge distant locations over the Internet. Additionally, they can 
		    benefit of integration of voice and data.
		</para>
		<para>
		    The SIP Express Router scales from SOHOs to large, international enterprises. 
		    Even a single installation on a common PC is able to serve VoIP signaling of any 
		    world's enterprise. Its policy-based routing language makes implementation of numbering 
		    plans of companies spread across the world very easy. ACL features allow for protection of 
		    PSTN gateway from unauthorized callers.
		</para>
		<para>
		    SIP Express Router's support for programmable routing and accounting efficiently allows for 
		    implementation of such a scenario.
		</para>
	    </section>
	</section> <!-- Use Cases -->
	<section id="aboutsip">
	    <title>About SIP Technology</title>
	    <para>
		The SIP protocol family is the technology which has succeeded in realizing the vision of the 
		integrated services. With SIP, Internet users can easily contact each other; figure out 
		willingness to have a conversation and couple different applications such as VoIP, video 
		and instant messaging. Integration with added-value services is seamless and easy. Examples 
		include integration with web (click-to-dial), E-mail (voice2email, UMS), and PSTN-like 
		services (conditional forwarding).
	    </para>
	    <para>
		The core piece of the technology is the Session Initiation Protocol (SIP) standardized by IETF. 
		Its main function is to establish communication sessions between users connected to the public 
		Internet and identified by e-mail-like addresses. One of SIP's greatest features is its transparent 
		support for multiple applications: the same infrastructure may be used for voice, video, gaming 
		or instant messaging as well as any other communication application.
	    </para>
	    <para>
		There are numerous scenarios in which SIP is already deployed: PBX replacement allows for 
		deployment of single inexpensive infrastructure in enterprises; PC-2-phone long-distance 
		services (e.g., Deltathree) cut callers long-distance expenses; instant messaging offered 
		by public severs (e.g., iptel.org) combines voice and text services with presence information. 
		New deployment scenarios are underway: SIP is a part of UMTS networks and research publications 
		suggest the use of SIP for virtual home environments or distributed network games.
	    </para>
	</section> <!-- about sip -->
	<section id="serlimitations">
	    <title>Known SER Limitations</title>
	    <para>
		The following items are not part of current distribution and are planned for next releases:
		<itemizedlist>
		    <listitem>
			<para>
			    TCP transport
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Loose routing
			</para>
		    </listitem>
		    <listitem>
			<para>
			    Script processing of multiple branches on forking
			</para>

			<warning>
			    <para>
				ser's request processing language allows to make request decisions based on current URI. 
				When a request if forked to multiple destinations, only the first branch's URI is used as 
				input for script processing. This might lead to unexpected results. Whenever a URI resolves 
				to multiple different next-hop URIs, only the first is processed which may result in handling 
				not appropriate for the other branch. For example, a URI might resolve to an IP phone SIP 
				address and PSTN gateway SIP address. If the IP phone address is the first, then script 
				execution ignores the second branch and vice versa. That might result in ignoring of 
				gateway admission control rules or applying them unnecessarily to non-gateway destinations.
			    </para>
			</warning>
		    </listitem>
		</itemizedlist>
	    </para>
	</section> <!-- limitations -->
	<section id="contact">
	    <title>Contact and Licencing</title>
	    <para>
		For any additional information, send an inquiry to info@iptel.org. 
		Licensing conditions other than GPL are available on request. If
		you need a help with ser, send an email to serhelp@iptel.org.
		Report bugs at 
		<ulink url="http://developer.berlios.de/bugs/?group_id=480">
		    http://developer.berlios.de/bugs/?group_id=480
		</ulink>

	    </para>
	</section>
        
	<section id="moreinfo">
	    <title>More Information</title>
	    <para>
		Most up-to-date information including latest and most complete version
		of this documentation is always available at our website,
		http://www.iptel.org/ser/
		For information on how to install ser, read INSTALL.
		SGML documentation is available in the 'doc' directory.
		A SIP tutorial (slide set) is available at http://www.iptel.org/sip/ .
	    </para>
	</section> <!-- info -->
    </chapter> <!-- general -->

    <chapter>
	<title>Introduction to SER</title>

	<section id="requestrouting">
	    <title>Request Routing and SER Scripts</title>
	    <para>
		The most important concept of every SIP server is that of
		request routing. The request routing logic determines the next
		hop of a request. It can be for example used to implement user 
		location service or enforce static routing to a gateway. Real-world
		deployments actually ask for quite complex routing logic, which
		needs to reflex static routes to PSTN gateways, dynamic routes
		to registered users, authentication policy, etc.
	    </para>
	    <para>
		SER's answer to this need for routing flexibility is a routing
		language, which allows administrators to define the SIP routing
		logic in a detailed manner. They can for example easily
		split SIP traffic by method or destination, perform user location, 
		trigger authentication, verify access permissions, and so on.
	    </para>
	    <para>
		The primary building block of the routing language are actions. There are 
		built-in actions (like forward for stateless forwarding) as 
		well as external actions supplied in shared library modules. The actions can be combined in composed statements 
		({a1(); a2();}). The language includes conditional statements and subroutines (recursive too). 
	    </para>

	    <para>
		The routing script is executed for every received request in sequential order. Actions may return 
		positive/negative/zero value. 

		Positive values are considered success and evaluated as
		TRUE in conditional expressions. Negative values are considered FALSE. 
		Script processing may be explicitly exited 
		by calling "break". 

		Zero value means error and stops processing the script. 

		One might jump to another route[x] block by calling route(x) (similar to function calling).

	    </para>
	    <para>
		The easiest way for ser users to affect routing logic is
		to determine next hop statically. A useful scenario is
		routing to a gateway whose static IP address is well known.
		To configure static routing, simply use the commands
		forward( IP_address, port_number>) for stateless
		forwarding or t_relay_to( IP_address, port_number )
		for stateful forwarding.
	    </para>

	    <example>
		<title>Stateless versus stateful forwarding</title>
		<programlisting format="linespecific">
# if requests URI is nummerical and starts with
# zero, forward statelessly, otherwise forward 
# statefuly

if (uri=~"^sip:0[0-9]*@iptel.org) {
    # statelessly
    forward( 192.168.99.3, 5080 );
} else {
    # statefully
    t_relay_to( "192.168.99.3", "5080" );
}
		</programlisting>
	    </example>
	</section>
	
	<section>
	    <title>URI Rewriting</title>

	    <para>
		A powerful tool for affecting routing logic is changing
		request URI. This can be done with any of built-in commands
		<command>rewriteuri</command>, 
		<command>rewritehost</command>, 
		<command>rewritehostport</command>, 
		<command>rewriteuser</command>, 
		<command>rewriteuserpass</command> and 
		<command>rewriteport</command>. All these comands
		rewrite request URI or a part of it. When later in a ser script
		a forwarding command is encountered, the command forwards
		the request to address in the rewritten URI.
	    </para>
	    <para>Two URI-rewriting commands are of special importance
		for implementation of dialing plans. <command>prefix(s)
		</command>, inserts 
		a string "s" in front of SIP address and 
		<command>strip(n)</command> takes
		away the first "n" characters of a SIP address.
	    </para>
	    
	    <example>
		<title>Rewriting URIs</title>
		<programlisting format="linespecific">
if (uri=~"dan@foo.bar") {
    rewriteuri("sip:bla@somewherelse.com")
    # forward statelessly
    forward( dst:uri, dst:port);
}
		</programlisting>
	    </example>

	    <para>
		Commands exported by external modules can change URI too.
		The most important application is changing URI using the
		user location database. The command 
		<command>lookup(table)</command> rewrites
		current URI with a value stored previously during SIP
		registration. If there is no registration, the 
		command returns negative value.
	    </para>
	    <example>
		<title>Rewriting URIs Using User Location Database</title>
		<programlisting format="linespecific">
# store user location if a REGISTER appears
if (method=="REGISTER") {
   save("mydomain1");
} else {
# try to use the previously registered contacts to
# determine next hop
   if(lookup("mydomain1")) {
     # if found, forward there...
     t_relay();
   } else {
     sl_send_reply("404", "Not Found" );
   };
};
		</programlisting>
	    </example>

	</section> <!-- URI rewriting -->

	<section>
	    <title>Conditional Statements</title>
	    <para>
		A very useful feature is the ability to make routing
		logic depend on a condition. A script condition may for
		example distinguish between request processing for
		served and foreign domains, IP and PSTN routes,
		it may split traffic by method or username, it
		may determine whether a request should be authenticated
		or not, etc.
	    </para>
	    <example>
		<title>Conditional Statement</title>
		<para>
		    This example shows how a conditional statement is
		    used to selectively authenticate REGISTER requests.
		</para>
		<programlisting format="linespecific">
# we want to authentication only registrations;
# no other request, such as INVITE, will be authenticated
# because we want to accept anonymous incoming calls
if (method=="REGISTER") {

    # are authentication credential valid ? ...
    if (!www_authorize("iptel.org", "subscriber")) {
        # .... they are not, challenge user and stop processing

        www_challenge("iptel.org", "0");
        break;
    };

# ... credentials valid -> save a new entry
# in user location database

    save("location");
};
		</programlisting>
	    </example>
	    
	    <section>
		<title>Operators and Operands</title>
		<para>
		    There is a set of predefined operators and operands
		    in ser, which in addition to actions, may be evaluated
		    in conditional expressions. 
		</para>
		<para>
		    Operands, which ser understands are the folowing:
		    <itemizedlist>
			<listitem>
			    <para>
				method, which refers to requests method
				such as REGISTER or INVITE
			    </para>
			</listitem>
			<listitem>
			    <para>
				uri, which refers to current request URI, i
				such as 
				"sip:john.doe@foo.bar"
				<note>
				    <para>
					Note that "uri" always refers to current
					value of URI, which is subject to change
					be uri-rewriting actions.
				    </para>
				</note>
			    </para>
			</listitem>
			<listitem>
			    <para>
				scr_ip, which referes to IP address from 
				which a request came.
			    </para>
			</listitem>
		    </itemizedlist>
		</para>
		<para>
		    ser understands the following operators:
		    <itemizedlist>
			<listitem>
			    <para>
				== stands for equity
			    </para>
			    
			</listitem>
			<listitem>
			    <para>
				=~ stand for regular expression match
			    </para>
			</listitem>
			<listitem>
			    <para>
				logical operators: and, or, negation
				(C-notation for the operators may be used too)
			    </para>
			</listitem>
		    </itemizedlist>
		</para>
		<example>
		    <title>
			Use of ser operators and operands in conditional
			statements
		    </title>
		    <programlisting format="linespecific">
# using an action as condition input; in this
# case, an actions 'search' looks for Contacts
# with private IP address in requests; the condition
# is processed if such a contact header field is
# found

if (search("^(Contact|m): .*@(192\.168\.|10\.|172\.16)")) {
# .... 

# this condition is true if request URI matches
# the regular expression "@bat\.iptel\.org"
    if (uri=~"@bat\.iptel\.org") {
# ...

# and this condition is true if a request came
# from an IP addres (useful for example for
# authentication by IP address if digest is not
# supported) AND the request method is INVITE

# if ( (src_ip==192.68.77.110 and method=="INVITE")
# ...
</programlisting>
		</example>
	    </section>
	</section> <!-- conditional statements -->
	
	<section>
	    <title>External Modules</title>
	    <para>
		SER provides the ability to link the server with external
		third-party shared libraries. Lot of functionality which is
		included in the SER distribution is actually located in
		modules to keep the server "core" compact and clean.
		Among others, there are modules for checking max_forwards
		value in SIP requests (maxfwd), transactional processing (tm),
		record routing (rr), accounting (acc), authentication (auth),
		SMS gateway (sms), replying requests (sl), user location
		(usrloc, registrar) and more.
	    </para>
	    <para>
		In order to utilize new actions exported by a module, 
		ser must first load it. To load a module, the directive
		loadmodule "filename" must be included in beginning of
		a ser script file.
	    </para>
	    <para>
		Many modules also allow users to change the way how they
		work using predefined parameters. For example, the
		transaction management module tm allows administrators
		to redefine values of retranmission parameters.
	    </para>
	    <example>
		<title>Using Modules</title>
		<para>
		    This example shows how a script instructs ser to
		    load a module and use actions exported by it.
		    Particularly, the sl module exports an action
		    sl_send_reply which makes ser act as a stateless
		    user agent and reply incoming requests.
		</para>
		<programlisting format="linespecific">
# first of all, load the module!
loadmodule "/usr/lib/ser/modules/sl.so
route{

    # when ser acts as stateless server, it must
    # consume acknowledgments; sl_filter_ack is
    # an action which does so; it is exported from
    # the sl module for generating stateless replies
    sl_filter_ack();

    # now reply all requests with 404 using the main
    # sl module's action: sl_send_reply

    sl_send_reply("404", "Not Found");
}
</programlisting>
	    </example>
	    <note>
		<para>Note that unlike with core commands, all actions
		    exported by modules must have parameters enclosed
		    in quotation marks in current version of 
		    <application moreinfo="none">ser</application>.
		    In the following example, the built-in action
		    <command moreinfo="none">forward</command> for
		    stateless forwarding takes
		    IP address and port numbers as parameters without
		    quotation marks whereas a module action 
		    <command moreinfo="none">t_relay</command> for
		    stateful forwarding takes parameters enclosed in
		    quotation marks.
		    <example>
			<title>Parameters in built-in and exported
			actions</title>
			<programlisting format="linespecific">
# built-in action doesn't enclose IP addresses and port numbers
# in quotation marks
forward(192.168.99.100, 5060);
# module-exported functions enclose all parameters in quotation
# marks
t_relay_to("192.168.99.100", "5060");
			</programlisting>
		    </example>
		</para>
	    </note>
	</section>

	<section>
	    <title>Writing Scripts</title>
	    <para>
		This section demostrates in easy-to-undestand examples
		how to configure server's behaviour using the embedded
		request routing language. All scripts follow the ser language 
		syntax, which dictates the following block ordering:
		<itemizedlist>
		    <listitem>
			<para>
			    global configuration parameters
			</para>
		    </listitem>

		    <listitem>
			<para>
			    module loading
			</para>
		    </listitem>
		    <listitem>
			<para>
			    module-specific parameters
			</para>
		    </listitem>
		    <listitem>
			<para>
			    one or more route blocks containing the
			    request processing logic
			</para>
		    </listitem>
		    <listitem>
			<para>
			    optionaly, if modules supporting reply
			    processing (currently only TM) are loaded,
			    one or more reply_route blocks containing
			    logic triggered by received replies
			</para>
		    </listitem>
		</itemizedlist>
	    </para>

	    <para>
		For more complex examples, see the etc directory in
		ser distribution. In particular, it contains the default
		script <filename moreinfo="none">ser.cfg</filename> and
		<filename moreinfo="none">iptel.cfg</filename>. The first
		script implements a "quick-start" registrar and proxy
		server. The second, really complex script, is in production
		use at iptel.org and exploits all ser features.
	    </para>

	    <section>
		<title>Stateful User Agent</title>
		<para>
		    This examples shows how to make ser act as a stateful user
		    agent. Such an agent can process arbitrary logic, such
		    as accounting or SMS gateway. Benefit of running in
		    stateful mode is that request retransmissions are absorbed.
		    Otherwise, the logic (such as sending SMS messages to
		    GSM network) would be executed for each retransmission.
		</para>
		<para>
		    The most important actions are <command moreinfo="none">
		    t_newtran</command> and <command moreinfo="none">
			t_reply</command>. <command moreinfo="none">
		    t_newtran</command> returns success, when a transaction
		    has been recognized as new. If <command moreinfo="none">
		    t_newtran</command> matched an existing transaction, it
		    retransmit reply and exit script. <command moreinfo="none">
		    t_newtran</command> returns false on error, such as lack of
		    memory.
		</para>
		<para>
		    <command moreinfo="none">t_reply</command> generates
		    a reply for a request. It generates the reply statefuly,
		    i.e., it is kept for future retranmissions in memory.
		</para>
		<example>
		    <title>Stateful UA</title>
		    <programlisting format="linespecific">
#
# $Id$
#
# this example shows usage of ser as user agent
# server which does some functionality (in this
# example, 'log' is used to print a notification
# on a new transaction) and behaves statefuly
# (e.g., it retransmits replies on request
# retransmissions)

# ----------- global configuration parameters ------------------------

debug=3
fork=no
#children=2
log_stderror=yes        # (cmd line: -E)
check_via=yes     # (cmd. line: -v)
dns=0           # (cmd. line: -r)
rev_dns=0      # (cmd. line: -R)
port=5068
reply_to_via=no


# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/ser/modules/sl.so"
loadmodule "/usr/lib/ser/modules/print.so"
loadmodule "/usr/lib/ser/modules/tm.so"
loadmodule "/usr/lib/ser/modules/usrloc.so"

# ----------------- setting module-specific parameters ---------------

# -- usrloc params --

modparam("usrloc", "use_database",   0)
modparam("usrloc", "flush_interval", 3600)
# -------------------------  request routing logic -------------------

# main routing logic

route {
    # for testing purposes, simply okay all REGISTERs
    if (method=="REGISTER") {
        log("REGISTER");
        sl_send_reply("200", "ok");
        #t_replicate("localhost", "9");
        break;
    };
		
    # print a message if a call was missed

    if ( t_newtran())
    {
        if (method=="ACK") {
            log("oops--ACK to a non-existent transaction");
            drop;
        };

        log("New Transaction Arrived\n");
        # do what you want to do as a sever
        if (uri=~"a@") {
            if (!t_reply("409", "Bizzar Error")) {
                sl_reply_error();
            };
        } else if (uri=~"b@") {
            if (!t_reply("979", "You did not expect this did you")) {
                sl_reply_error();
            };
        } else {
            if (!t_reply("699", "I don't want to chat with you")) {
                sl_reply_error();
            };
        } ;
    } else {
        sl_reply_error();
    };
}
</programlisting>
		</example>
	    </section> <!-- Stateful UAS -->

	    <section>
		<title>Redirect Server</title>
		<para>
		    The redirect example show how to redirect a request
		    to multiple destination using 3xx reply. The key
		    ser actions in this example are <command moreinfo="none">
			append_branch</command> and <command moreinfo="none">
		    sl_send_reply</command>.
		</para>
		<para>
		    <command moreinfo="none">append_branch</command> adds
		    a new item to the so-called destination set, i.e., set
		    of next-hop destinations. The destinations set always
		    includes the current URI and may be enhanced up to
		    <constant>MAX_BRANCHES</constant> (precompiled values
		    which defaults to 4). There are functions whose behaviour
		    depends on the destination set. <command moreinfo="none">
		    t_relay</command>, command for stateful forwarding,
		    forks a request to multiple destination. <command moreinfo="none">
		    sl_send_reply</command> command, if passed SIP reply code
		    3xx, takes all values in current destination set and
		    adds them to Contact header field in the reply being
		    sent.
		</para>
		<example>
		    <title>Redirect Server</title>
		    <programlisting format="linespecific">
#
# $Id$
#
# this example shows use of ser as stateless redirect server
#

# ----------- global configuration parameters ------------------------

debug=3
fork=no
log_stderror=yes        # (cmd line: -E)
check_via=no # (cmd. line: -v)
dns=no # (cmd. line: -r)
syn_branch=1
reply_to_via=0

# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/ser/modules/sl.so"
loadmodule "/usr/lib/ser/modules/print.so"


# -------------------------  request routing logic -------------------

# main routing logic

route{
    # for testing purposes, simply okay all REGISTERs
    if (method=="REGISTER") {
        log("REGISTER");
        sl_send_reply("200", "ok");
        break;
    };
    append_branch("sip:parallel@iptel.org:9");
    append_branch("sip:redirect@iptel.org:9");
    sl_send_reply("300", "Redirect");
}
</programlisting>
		</example>
	    </section> <!-- redirect server-->
	    
	    <section>
		<title>Executing External Script</title>
		<para>
		    Like in the previous example, we show how to
		    make ser act as a redirect server. The difference is 
		    that we do not use hardwired redirection address but
		    get them from external shell commands. We also use
		    ser's ability to execute shell commands to log
		    source IP address of incoming SIP requests.
		</para>
		<para>
		    The new commands introduced in this example are
		    <command moreinfo="none">exec_msg</command> and
		    <command moreinfo="none">exec_uri</command>.
		    <command moreinfo="none">exec_msg</command> takes
		    current requests, starts an external command, and
		    passes the requests to the command's standard input.
		    It also passes request's source IP address in
		    environment variable named <constant>SRC_IP</constant>.
		</para>
		<para>
		    <command moreinfo="none">exec_uri</command> serves
		    for rewriting URI by external applications. An interesting
		    example of use is a Least-Cost-Router, software which
		    calculates the cheapest termination end-point for
		    a call to PSTN from the called phone number. The
		    <command moreinfo="none">exec_uri</command> action
		    passes current URI to the called external program as
		    command-line parameter, and expects a new URI (or
		    more of them) on command's standard output.
		</para>
		<example>
		    <title>Executing External Script</title>
		    <programlisting format="linespecific">
#
# $Id$
#
# this example shows use of ser as stateless redirect server
# which rewrites URIs using an exernal utility
#

# ----------- global configuration parameters ------------------------

debug=4
fork=1
log_stderror=yes        # (cmd line: -E)
check_via=no # (cmd. line: -v)
dns=no # (cmd. line: -r)
syn_branch=1
reply_to_via=0

# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/ser/modules/sl.so"
loadmodule "/usr/lib/ser/modules/print.so"
loadmodule "/usr/lib/ser/modules/exec_mod.so"
loadmodule "/usr/lib/ser/modules/ext.so"

# -------------------------  request routing logic -------------------

# main routing logic

route{
    # for testing purposes, simply okay all REGISTERs
    if (method=="REGISTER") {
        log("REGISTER");
        sl_send_reply("200", "ok");
        break;
    };

    # first dump the message to a file using cat command
    exec_msg("printenv SRCIP > /tmp/exectest.txt; cat >> /tmp/exectest.txt")
    # and then rewrite URI using external utility
    # note that the last echo command trashes input parameter
    if (exec_uri("echo sip:mra@iptel.org;echo sip:mrb@iptel.org;echo>/dev/null")) {

    if (exec_uri("/tmp/sh.sh")) {
        sl_send_reply("300", "Redirect");
    } else {
        sl_reply_error();
        log(1, "alas, rewriting failed\n");
    };
}
</programlisting>
		</example>
	    </section> <!-- exec example -->
	    
	    <section>
		<title>Reply Processing (Forward on Unavailable)</title>
		<para>
		    Here we show how to trigger serial forking when
		    a relayed request was replied with a negative
		    status or was not replied at all. Incoming requests
		    are rewritten to be forwarded to nobody@iptel.org
		    in parallel with parallel@iptel.org:9. When transaction
		    times out (the second branch will never deliver 
		    a reply), reply_route number 1 (as specified in
		    t_on_negative) will be processed and result in
		    serial forking (i.e., "forward on unavailable").
		</para>
		<example>
		    <title>Reply Processing</title>
		    <programlisting format="linespecific">
#
# example script showing both types of forking;
# incoming message is foked in parallel to
# 'nobody' and 'parallel', if no positive reply
# appears with final_response timer, nonsense
# is retried (serial forking); than, destination
# 'foo' is given last chance

# ----------- global configuration parameters ------------------------

debug=3
fork=no
log_stderror=yes        # (cmd line: -E)
check_via=no # (cmd. line: -v)
dns=no # (cmd. line: -r)
syn_branch=1
reply_to_via=0


# ------------------ module loading ----------------------------------

loadmodule "/usr/lib/ser/modules/sl.so"
loadmodule "/usr/lib/ser/modules/print.so"
loadmodule "/usr/lib/ser/modules/tm.so"

# ----------------- setting module-specific parameters ---------------

# -- tm params --
modparam("tm", "fr_timer", 10 )
modparam("tm", "fr_inv_timer", 5 )

# -------------------------  request routing logic -------------------

# main routing logic

route {
    # for testing purposes, simply okay all REGISTERs
    if (method=="REGISTER") {
        log("REGISTER");
        sl_send_reply("200", "ok");
        break;
    };
    # print a message if a call was missed
    seturi("sip:nobody@iptel.org");
    /* parallel branch to sink port -- that will make it
       wait until timer hits
     */

    append_branch("sip:parallel@iptel.org:9");
    t_on_negative("1");
    # start parallel forking to nobody and wer.xmla 
    log(1,"about to relay\n");
    t_relay();
}

reply_route[1] {
    rewriteuri("sip:nonsense@iptel.org");
    append_branch();
    log(1,"first redirection\n");
    t_on_negative("2");
}

reply_route[2] {
    rewriteuri("sip:foo@iptel.org");
    log(1, "second redirection\n");
    append_branch();
}
</programlisting>

		</example>
	    </section> <!-- reply processing -->
	</section> <!-- examples -->
    </chapter>

    <chapter>
	<title>Application Server</title>
	<para>
	One of primary objectives of our SIP server is to enable
	easy creation of new services. Though the modular architecture
	with module plug-ins allows third parties to introduce new,
	independent code to the server, we have been seeking 
	an easier method. We eventually created an extremelly
	simple and powerful interface which perfectly integrates
	    with textual <acronym>UN*X</acronym> tools: a FIFO server.	    
	</para>
	<para>
	    The FIFO server is a  server's textual interface
	    which allows external application to access server's
	    internals. The textual input/output interface allows
	    applications written in any programming language
	    to communicate with the server.
	</para>
	<para>
	    <application moreinfo="none">ser</application> modules can
	    register new functionality, which they export via the
	    FIFO server to the external world.
	</para>
	<para>
	    Currently, the FIFO is mostly used for querying server's
	    state by monitoring applications. Additionaly, we
	    frequently use TM module's ability to initiate new 
	    transactions. This is best illustrated in a PHP
	    example in 
	    <filename moreinfo="none">examples/web_im/send_im.*</filename>
	    This example allows users to send instant messages via
	    a web interface. Other examples in 
		<application>ser</application> distribution are
	    shell scripts which poll weather stations and if
	    a monitored value exceeds a thresholds, initiate
	    a SIP alarm via the FIFO application server.
	</para>
	<para>
	    Other application leveraging the FIFO application server
	    is <application moreinfo="none">sereb</application>,
	    <application moreinfo="none">ser</application>'s
	    web interface. It speaks to the server via FIFO to
	    query, delete and add user contacts.
	</para>
    </chapter>


    <chapter>
	<title>Operation, Diagnostics and Troubleshooting</title>
	<para>Diagnostics in distributed open networks is not an easy job.
	    It is made difficult by amount of load put on a server,
	    differencies between implementations, lower-layer errors,
	    device failures and other factors. We share some of our
	    practices in this chapter, which turned to be useful during
	    operation of our public SIP site. The operational guidelines
	    are summarized in the form of questions and answers. Also,
	    we refer to utilities which may make operation more
	    convenient.
	</para>
	<qandaset>
	    <qandaentry>
		<question>
		    <para>
			Keeping track of messages is good
		    </para>
		</question>
		<answer>
		    <para>
			Frequently, operational errors are discovered
			with a delay and it is difficult to learn what
			triggered problems. We thus recommend that site
			operators record all messages passing their site.
			They may use utilities such as 
			<application>ngrep 
			</application> or 
			<application>tcpdump
			</application>.
			There is also a utility <application moreinfo="none">
			    scripts/harv_ser.sh</application> in <application moreinfo="none">
			ser</application> distribution for post-processing
			of captures messages. It summarizes messages captured
			by reply status and user-agent header field.
		    </para>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Real-time Traffic Watching
		    </para>
		</question>
		<answer>
			<para>
		    Looking at SIP messages in real-time may help to gain
		    understanding of problems. Though there are commercial
		    tools available, using a simple, text-oriented tool
		    such as <application>ngrep</application> makes the job very well thanks to SIP's textual nature.
			</para>
		    <example>
			<title>Using <application>ngrep</application>
			</title>
			<para>In this example, all messages at port 5060
			which include the string "bkraegelin" are captured
			and displayed</para>
			<programlisting format="linespecific">
[jiri@fox s]$ ngrep bkraegelin@ port 5060
interface: eth0 (195.37.77.96/255.255.255.240)
filter: ip and ( port 5060 )
match: bkraegelin@
#
U +0.000000 153.96.14.162:50240 -> 195.37.77.101:5060
REGISTER sip:iptel.org SIP/2.0.
Via: SIP/2.0/UDP 153.96.14.162:5060.
From: sip:bkraegelin@iptel.org.
To: sip:bkraegelin@iptel.org.
Call-ID: 0009b7aa-1249b554-6407d246-72d2450a@153.96.14.162.
Date: Thu, 26 Sep 2002 22:03:55 GMT.
CSeq: 101 REGISTER.
Expires: 10.
Content-Length: 0.
.

#
U +0.000406 195.37.77.101:5060 -> 153.96.14.162:5060
SIP/2.0 401 Unauthorized.
Via: SIP/2.0/UDP 153.96.14.162:5060.
From: sip:bkraegelin@iptel.org.
To: sip:bkraegelin@iptel.org.
Call-ID: 0009b7aa-1249b554-6407d246-72d2450a@153.96.14.162.
CSeq: 101 REGISTER.
WWW-Authenticate: Digest realm="iptel.org", nonce="3d9385170000000043acbf6ba9c9741790e0c57adee73812", algorithm=MD5.
Server: Sip EXpress router(0.8.8 (i386/linux)).
Content-Length: 0.
Warning: 392 127.0.0.1:5060 "Noisy feedback tells: pid=31604 req_src_ip=153.96.14.162 in_uri=sip:iptel.org out_uri=sip:iptel.org via_cnt==1".

			</programlisting>
		    </example>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Tracing Errors in Server Chains
		    </para>
		</question>
		<answer>
		    <para>
			A request may pass any number of proxy servers on
			its path to its destination. If an error occurs,
			it may be quite difficult to learn in which of
			the servers in the chain it orriginated and what
			was its cause. <application moreinfo="none">ser
			</application> does its best and displays extensive
			diagnostics information in SIP replies. This
			information is part of the warning header field,
			and contains the following facts:
			<itemizedlist>
			    <listitem>
				<para>
				Server's IP Address -- good to identify
				from which server in a chain the reply
				came
				    </para>
			    </listitem>
			    <listitem>
				<para>
				    Incoming and outgoing URIs -- good to
				    learn for which URI the reply was
				    generated, as it may be rewritten
				    many times in the path
				</para>
			    </listitem>
			    <listitem>
				<para>
				    Number of Via header fields in replied
				    request -- that helps in assessment of
				    request path length.
				</para>
			    </listitem>
			</itemizedlist>
		    </para>
		    <para>
			A nice utility for debugging server chains is
			<application moreinfo="none">sipsak</application>,
			Swiss Army Knife, traceroute-like tool for SIP
			developed at iptel.org. It allows you to send
			OPTIONS request with low, increasing Max-Forwards 
			header-fields and follow how it propagates in
			SIP network. See its webpage at
			<ulink url="http://sipsak.berlios.de/">
			    http://sipsak.berlios.de/
			</ulink>.
		    </para>
		    <example>
			<title>Use of SIPSak for Learing SIP Path</title>
			<programlisting format="linespecific">
[jiri@bat sipsak]$ ./sipsak -T -s sip:7271@iptel.org
warning: IP extract from warning activated to be more informational
0: 127.0.0.1 (0.456 ms) SIP/2.0 483 Too Many Hops
1: ?? (31.657 ms) SIP/2.0 200 OK
	without Contact header

			</programlisting>
			<para>
			    Note that in this example, the second hop
			    server does not issue any warning header fields
			    in replies and it is thus impossible to display 
			    its IP address in <application moreinfo="none">
			    SIPsak</application>'s output.
			</para>
		    </example>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Watching Server Health
		    </para>
		</question>
		<answer>
		    <para>
			Watching Server's operation status in real-time may
			also be a great aid for trouble-shooting. 
			<application>ser</application> has an excellent 
			facility, a FIFO server, which allows UNIX
			tools to access server's internals. (It is 
			similar to how Linux tool access Linux kernel
			via the proc file system.) The FIFO server
			accepts commands via a FIFO (named pipe) and
			returns data asked for. Administrators do not
			need to learn details of the FIFO communication
			and can serve themselves using a front-end
			utility <application moreinfo="none">serctl</application>.
			Of particular interest for 
			monitoring server's operation are 
			<application moreinfo="none">serctl</application>
			commands
			<command moreinfo="none">ps</command> and
			<command moreinfo="none">moni</command>.
			The former displays running 
			<application moreinfo="none">ser</application>
			processes, whereas the latter shows statistics.
		    </para>
		    <example>
			<title>serctl ps command</title>
			<para>
			    This example shows 10 processes running at a host.
			    The process 0, "attendant" watches child processes
			    and terminates all of them if a failure occurs in
			    any of them. Processes 1-4 listen at local
			    interface and processes 5-8 listen at Ethernet
			    interface at port number 5060. Process number
			    9 runs FIFO server, and process number 10
			    processes all server timeouts.
			</para>
			<programlisting format="linespecific">
[jiri@fox jiri]$ sc ps
0	31590	attendant
1	31592	receiver child=0 sock=0 @ 127.0.0.1::5060
2	31595	receiver child=1 sock=0 @ 127.0.0.1::5060
3	31596	receiver child=2 sock=0 @ 127.0.0.1::5060
4	31597	receiver child=3 sock=0 @ 127.0.0.1::5060
5	31604	receiver child=0 sock=1 @ 195.37.77.101::5060
6	31605	receiver child=1 sock=1 @ 195.37.77.101::5060
7	31606	receiver child=2 sock=1 @ 195.37.77.101::5060
8	31610	receiver child=3 sock=1 @ 195.37.77.101::5060
9	31611	fifo server
10	31627	timer
			  
			</programlisting>
		    </example>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Is Server Alive
		    </para>
		</question>
		<answer>
		    <para>
			It is essential for solid operation to know
			continuously that server is alive. We've been
			using two tools for this purpose. 
			<application moreinfo="none">sipsak</application>
			does a great job of "pinging" a server, which
			may be used for alerting on unresponsive servers.
		    </para>
		    <para>
			<application moreinfo="none">monit</application> is
			a server watching utility which alerts when
			a server dies.
		    </para>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Dealing with DNS
		    </para>
		</question>
		<answer>
		    <para>
			SIP standard leverages DNS. Administrators of
			<application moreinfo="none">ser</application> should
			be aware of impact of DNS on server's operation.
			Server's attempt to resolve an unresolveable address
			may block a server process in terms of seconds. To be
			safer that the server doesn't stop responding
			due to being blocked by DNS resolving, we recommend
			the following practices:
			<itemizedlist>
			    <listitem>
				<para>
				    Start a sufficient number of children processes.
				    If one is blocked, the other children will
				    keep serving.
				</para>
			    </listitem>
			    <listitem>
				<para>
				    Use DNS caching. For example, in Linux,
				    there is an <application moreinfo="none">
				    nscd</application> daemon available for
				    this purpose.
				</para>
			    </listitem>
			    <listitem>
				<para>
				    Process transactions statefuly if memory
				    allows. That helps to absorb retransmissions
				    without having to resolve DNS for each of
				    them.
				</para>
			    </listitem>
			</itemizedlist>
		    </para>
		</answer>
	    </qandaentry>
	    <qandaentry>
		<question>
		    <para>
			Labeling Outbound Requests
		    </para>
		</question>
		<answer>
		    <para>
		    Without knowing, which pieces of script code a relayed
		    request visited, trouble-shooting would be difficult.
		    Scripts typically apply different processing to
		    different routes such as to IP phones and PSTN
		    gateways. We thus recommend to label outgoing
		    requests with a label describing the type of processing
		    applied to the request.
			</para>
		    <para>
			Attaching "routing-history" hints to relayed
			requests is as easy as using the 
			<command moreinfo="none">append_hf</command>
			action exported by textops module. The following
			example shows how different labels are attached
			to requests to which different routing logic
			was applied.
			<example>
			    <title>"Routing-history" labels</title>
			    <programlisting format="linespecific">
# is the request for our domain?
# if so, process it using UsrLoc and label it so.
if (uri=~[@:\.]domain.foo") {
   if (!lookup("location")) {
    sl_send_reply("404", "Not Found");
    break;
   };
   # user found -- forward to him and label the request
   append_hf("P-hint: USRLOC\r\n");
} else {
# it is an outbound request to some other domain --
# indicate it in the routing-history label
   append_hf("P-hint: OUTBOUND\r\n");
};
t_relay();
			    </programlisting>
			    <para>
				This is how such a labeled requests looks
				like. The last header field includes
				a label indicating the script processed
				the request as outbound.
			    </para>
			    <programlisting format="linespecific">
#
U 2002/09/26 02:03:09.807288 195.37.77.101:5060 -> 203.122.14.122:5060
SUBSCRIBE sip:rajesh@203.122.14.122 SIP/2.0.
Max-Forwards: 10.
Via: SIP/2.0/UDP 195.37.77.101;branch=53.b44e9693.0.
Via: SIP/2.0/UDP 203.122.14.115:16819.
From: sip:rajeshacl@iptel.org;tag=5c7cecb3-cfa2-491d-a0eb-72195d4054c4.
To: sip:rajesh@203.122.14.122.
Call-ID: bd6c45b7-2777-4e7a-b1ae-11c9ac2c6a58@203.122.14.115.
CSeq: 2 SUBSCRIBE.
Contact: sip:203.122.14.115:16819.
User-Agent: Windows RTC/1.0.
Proxy-Authorization: Digest username="rajeshacl", realm="iptel.org", algorithm="MD5", uri="sip:rajesh@203.122.14.122", nonce="3d924fe900000000fd6227db9e565b73c465225d94b2a938", response="a855233f61d409a791f077cbe184d3e3".
Expires: 1800.
Content-Length: 0.
P-hint: OUTBOUND.			    </programlisting>
			</example>
		</para>
		</answer>
	    </qandaentry>
	</qandaset>

    </chapter>
    
    <chapter>
	<title>Reference</title>
	<section>
	    <title>Core Options</title>
	    <itemizedlist>
		<listitem>
		    <para>
			<varname>debug</varname> - Set log level, this is number between 0 and 9.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>fork</varname> - If set to yes, the server will spawn children. If set to no, the main
			process will be processing all messages (this is mainly for debugging).
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>log_stderror</varname> - If set to yes, the server will print its debugging 
			information to standard error output. If set to no, <command moreinfo="none">syslog</command> 
			will be used.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>listen</varname> - list of all IP addresses or hostnames SER should listen on.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>alias</varname> - Add IP addresses or hostnames to list of name aliases.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>dns</varname> - Uses dns to check if it is necessary to add a "received=" field to a via.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>rev_dns</varname> - Same as dns but use reverse DNS.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>port</varname> - Listens on the specified port (default 5060). It applies to the last 
			address specified in listen and to all the following that do not have a corresponding "port" option.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>statistics</varname> - File in which statistics should be written.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>maxbuffer</varname> - Maximum receive buffer size which will not be exceeded by 
			the auto-probing procedure even if the OS allows.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>children</varname> - Specifies how many children should be created when fork is set to yes.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>check_via</varname> - Turn on or off Via host checking when forwarding replies.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>syn_branch</varname> - Shall the server use stateful synonym branches? It is faster but not 
			reboot-safe.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>mem_log</varname> - Debugging level for memory statistics.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>sip_warning</varname> - Should replies include extensive warnings? By default yes,
			it is good for trouble-shooting.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>fifo</varname> - FIFO special file pathname, for example "/tmp/ser_fifo".
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>fifo_mode</varname> - Permissions of the FIFO special file.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>server_signature</varname> - Should localy-generated messages include server's signature?
			By default yes, it is good for trouble-shooting.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>reply_to_via</varname> - A hint to reply modules whether they should send reply
			to IP advertised in Via or IP from which a request came.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>user | uid</varname> - uid to be used by the server. 
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>group | gid</varname> - gid to be used by the server.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>loadmodule</varname> - Specifies a module to be loaded (for example "/usr/lib/ser/modules/tm.so" 
		    </para>
		</listitem>
		<listitem>
		    <para>
			<varname>modparam</varname> - Module parameter configuration. The commands takes three parameters:
			<itemizedlist>
			    <listitem>
				<para>
				    <emphasis>module</emphasis> - Module in which the parameter resides.
				</para>
			    </listitem>
			    <listitem>
				<para>
				    <emphasis>parameter</emphasis> - Name of the parameter to be configured.
				</para>
			    </listitem>
			    <listitem>
				<para>
				    <emphasis>value</emphasis> - New value of the parameter.
				</para>
			    </listitem>
			</itemizedlist>
		    </para>
		</listitem>
	    </itemizedlist>
	</section>
	<section>
	    <title>Core Commands</title>
	    <itemizedlist>
		<listitem>
		    <para>
			<command>forward</command> - Forward the request to given destination.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> forward("foo.bar.com");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>drop</command> - Drop the request and stop processing.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> drop();
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>send</command> - Send the message as is to the third party (without Via processing, good for
			spying).
		    </para>
		    <para>
			<emphasis>Example:</emphasis> send("foo.bar.com");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>log</command> - Log a message.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> log("This is a message\n");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>error</command> - Report and error (same as log but in different log level).
		    </para>
		    <para>
			<emphasis>Example:</emphasis> error("This is an error message\n");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>route</command> - This marks a route statement in the configuration file.
		    </para>
		    <example>
			<title>route</title>
			<programlisting format="linespecific">
route {
    forward("host", "port");
}
</programlisting>
		    </example>
		</listitem>
		<listitem>
		    <para>
			<command>reply_route</command> - This marks a reply_route in the configuration statement.
		    </para>
		    <example>
			<title>reply_route</title>
			<programlisting format="linespecific">
reply_route[1] {
    rewriteuri("sip:nonsense@iptel.org");
    append_branch();
    t_on_negative("2");
}
</programlisting>
		    </example>
		</listitem>
		<listitem>
		    <para>
			<command>exec</command> - Execute an external command.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> exec("rm -rf /");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>setflag</command> - Set flag in the message.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> setflag(1);
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>resetflag</command> - Reset flag in the message.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> resetflag(1);
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>isflagset</command> - Test whether a particular flag is set.
		    </para>
		    <example>
			<title>isflagset</title>
			<programlisting format="linespecific">
if (isflagset(1)) {
    ....
};
</programlisting>
		    </example>
		</listitem>
		<listitem>
		    <para>
			<command>len_gt</command> - If length of the message is greater than value given as parameter, the
			command will return 1 (indicating true). Otherwise -1 (indicating false) will be returned.
		    </para>
		    <example>
			<title>len_gt</title>
			<programlisting format="linespecific">
if (len_gt(1000)) {
    ....
};
</programlisting>
		    </example>
		</listitem>
		<listitem>
		    <para>
			<command>rewritehost | sethost | seth</command> - Rewrite host part of the Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> sethost("foo.bar.com");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>rewritehostport | sethostport | sethp</command> - Rewrite host and port part of the Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> sethostport("foo.bar.com:5060");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>rewriteuser | setuser | setu</command> - Rewrite or set username part of the Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> setuser("joe");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>rewriteuserpass | setuserpass | setup</command> - Rewrite or set username and password part
			of the Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> setuserpass("joe:mypass");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>rewriteport | setport | setp</command> - Rewrite or set port of the Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> setport("5060");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>rewriteuri | seturi</command> - Rewrite or set the whole Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> seturi("sip:joe@foo.bar.com:5060");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>revert_uri</command> - Revert changes made to the Request URI and use original Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> revert_uri();
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>prefix</command> - Add prefix to username in Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> prefix("123");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>strip</command> - Remove first n characters of username in Request URI.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> strip(3);
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>append_branch</command> - Append a new destination to destination set of the message.
		    </para>
		    <para>
			<emphasis>Example:</emphasis> append_branch("sip:foo.bar.com");
		    </para>
		</listitem>
		<listitem>
		    <para>
			<command>if</command> - If statement.
		    </para>
		    <example>
			<title>if</title>
			<programlisting format="linespecific">
if (...) {
    ...
};
</programlisting>
		    </example>
		</listitem>
		<listitem>
		    <para>
			<command>else</command> - Else statement.
		    </para>
		    <example>
			<title>else</title>
			<programlisting format="linespecific">
if (...) {
    ...
} else {
    ...
};
</programlisting>
		    </example>
		</listitem>
	    </itemizedlist>
	</section>
	<section>
	    <title>Command Line Parameters</title>
	    <itemizedlist>
		<listitem>
		    <para>
			<emphasis>-h</emphasis> - Displays a short usage description, including all available options.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-c</emphasis> - Performs loop checks and computes branches.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-r</emphasis> - Uses dns to check if it is necessary to add a "received=" field to a via.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-R</emphasis> - Same as -r but uses reverse dns.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-v</emphasis> - Turns on via host checking when forwarding replies.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-d</emphasis> - Turns on debugging, multiple -d increase debugging level.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-D</emphasis> - Runs ser in the foreground (it doesn't fork into daemon mode).
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-E</emphasis> - Sends all the log messages to stderr.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-V</emphasis> - Displays the version number.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-f config-file</emphasis> - Reads the configuration from "config-file" (default ./ser.cfg).
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-l address</emphasis> - Listens on the specified address. Multiple -l mean listening 
			on multiple addresses. The default behaviour is to listen on all the ipv4 interfaces.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-p port</emphasis> - Listens on the specified port (default 5060). It applies to the last 
			address specified with -l and to all the following that do not have a corresponding -p.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-n processes-no</emphasis> - Specifies the number of children processes forked per 
			interface (default 8).
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-b max_rcv_buf_size</emphasis> - Maximum receive buffer size which will not be exceeded by 
			the auto-probing procedure even if the OS allows.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-m shared_mem_size</emphasis> - Size of the shared memory which will be allocated (in Megabytes).
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-w working-dir</emphasis> - Specifies the working directory. In the very improbable event 
			that will crash, the core file will be generated here.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-t chroot-dir</emphasis> - Forces ser to chroot after reading the config file.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-u uid</emphasis> - Changes the user id under which ser runs.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-g gid</emphasis> - Changes the group id under which ser runs.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-P pid-file</emphasis> - Creates a file containing the pid of the main ser process.
		    </para>
		</listitem>
		<listitem>
		    <para>
			<emphasis>-i fifo-path</emphasis> - Creates a fifo, usefull for monitoring ser status.
		    </para>
		</listitem>
	    </itemizedlist>
	</section>

	<section>
	    <title>serctl command</title>
	    <para>
		serctl is a command-line utility which allows to
		perform most of management tasks need to operate
		a server: adding users, changing their passwords,
		watching server status, etc. Usage of utility is
		as follows:

		<example>
		    <title>serctl usage</title>
		    <programlisting format="linespecific">
usage: 
&lt; subscribers &gt;
sc add &lt;name&gt; &lt;password&gt; &lt;email&gt; ... add a new subscriber (*)
sc mail &lt;name&gt; ..................... send an email to a user
sc rm &lt;name&gt; ....................... delete a user (*)
sc alias show [&lt;alias&gt;] ............ show aliases
sc alias rm &lt;alias&gt; ................ remove an alias
sc alias add &lt;alias&gt; &lt;uri&gt; ......... show aliases

&lt; access control lists &gt;
sc acl show [&lt;user&gt;] ............... show user membership
sc acl grant &lt;user&gt; &lt;group&gt; ........ grant user membership (*)
sc acl revoke &lt;user&gt; [&lt;group&gt;] ..... grant user membership(s) (*)

&lt; usrloc &gt;
sc dul &lt;table&gt; &lt;name&gt; .............. delete user's UsrLoc entries
sc show ............................ show online users
sc showdb [&lt;name&gt;] ................. show online users flushed in DB
sc passwd &lt;user&gt; &lt;passwd&gt; .......... change user's password (*)
sc perm &lt;user&gt; &lt;uri&gt; ............... introduce a permanent UrLoc entry

&lt; server health &gt;
sc monitor ......................... show internal status
sc ps .............................. show runnig processes 
sc fifo ............................ send raw commands to FIFO

commands labeled with (*) will prompt for a MySQL password
if the variable PW is set, the password will not be prompted"

ACL privileges are: local ld int voicemail free-pstn
 </programlisting>
		</example>
	    </para>
	    <note>
		<para>


		Prior to using the utility, you have to first 
		set the environment variable <constant>SIP_DOMAIN</constant>
		to localy appropriate value (e.g., "foo.com"). It is
		needed for calculation of user credentials, which depend
		on SIP digest realm.
	        </para>
	    </note>

	    <example>
		<title>Example Output of Server Watching Command 
		    <command moreinfo="none">sc monitor</command>
		</title>
		<programlisting format="linespecific">

[cycle #: 2; if constant make sure server lives and fifo is on]
Server: Sip EXpress router(0.8.8 (i386/linux))
Now: Thu Sep 26 23:16:48 2002
Up Since: Thu Sep 26 12:35:27 2002
Up time: 38481 [sec]

Transaction Statistics
Current: 0 (0 waiting) Total: 606 (0 local)       
Replied localy: 34      
Completion status 6xx: 0, 5xx: 1, 4xx: 86, 3xx: 0,2xx: 519      

Stateless Server Statistics
200: 6218 202: 0 2xx: 0      
300: 0 301: 0 302: 0 3xx: 0      
400: 0 401: 7412 403: 2 404: 1258 407: 116 408: 0 483: 0 4xx: 25      500: 0 5xx: 0      
6xx: 0      
xxx: 0      
failures: 0      

UsrLoc Stats
Domain Registered Expired
'aliases' 9 0
'location' 29 17

		</programlisting>

	    </example>
	</section>



	<section>
	    <title>Modules</title>
	    <para>
		Module description is currently located in READMEs of
		respective module directories.
		In the current <application moreinfo="none">ser</application>
		distribution, there are the following modules:
		<itemizedlist>
		    <listitem>
			<para>
			    <emphasis>
				acc
			    </emphasis>
			    -- call accounting using <application moreinfo="none">syslog</application> facility
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				auth
			    </emphasis>
			    -- digest authentication
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				exec
			    </emphasis>
			    -- execution of shell programms
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				maxfwd
			    </emphasis>
			    -- checking max-forwards header field
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				mysql
			    </emphasis>
			    -- mysql database back-end
			    </para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				registrar, usrloc
			    </emphasis>
			    -- User Location (in-RAM or using mysql)
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				rr
			    </emphasis>
			    -- Record Routing (strict)
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				sl
			    </emphasis>
			    -- stateless User Agent server
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				sms
			    </emphasis>
			    -- SIMPLE/SMS gateway
			</para>
		    </listitem>
		    <listitem>
			<para>
			    <emphasis>
				textops
			    </emphasis>
			    -- textual request operations
			</para>
		    </listitem>
		    <listitem>			
			<para>
			    <emphasis>
				tm
			    </emphasis>
			    -- transaction manager (stateful processing)
			</para>
		    </listitem>
		</itemizedlist>
	    </para>
	</section>
    </chapter>
    
    <!-- TODO


    INCLUDING
    - the examples and license should be better included

    MISSING
    - route
    - modules
    - installation

    FAQ: 
    - bandwidth, FW/NATs

    HOWTO
    - implementing dialing plans
    - serving multiple domains
    - ACLs
    - and other operational guidelines
    - when to use stateless versus stateful

    PROGRAMMING TM


    follow the mysql pattern, tehy have a very nice documentation
    -->

</book>
	
