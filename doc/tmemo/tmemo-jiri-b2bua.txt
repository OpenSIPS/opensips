$Id$

Draft Design Options for Building Prepaid Scenarios Using SIP/SER
==================================================================

Jiri Kuthan, iptel.org, January 2003

Abstract
--------
Prepaid scenarios for making calls to PSTN gateways require the 
ability to terminate an exising call when user's credit is 
exhausted. Though it seems appropriate to implement such 
a feature in the device providing the service (i.e., in the gateway),
we are currently not aware of such gateways. We thus first
recommend a session-timer based approach which possibly works,
and requires limited support in end-devices (session-timer)
and proxy servers (session-timer and call length determination).
We then discuss another alternative, based on a B2BUA middlebox,
which works even with the dumbest PSTN gateways but puts
a considerable workload on SIP server.

TOC
---
Section 1 explains design alternatives which can be made when
designed a "forced" call termination (FCT). The design alternatives
are FCT support in end-devices (nice, but not doable with current 
gateways), FCT support using session-timer (nice, hopefuly doable, 
requires session-timer support) and FCT using a B2BUA (ugly
and costly, but best backwards-compatible).

Section 2 details known drawbacks of the B2BUA technology.

Preliminary hints how to implement the B2BUA using ser,
which has no B2BUA support, are detailed in section 3.

1. How To Terminate a Call When No Money Is Left
--------------------------------------------------

In general, there are many ways to implement a service operator
driven call cut-off. We argue, that architecturally best acceptable
place for this functionality is in the terminating PSTN end-device.
The device already keeps session state, it knows too when things
go wrong on the PSTN site, it is able to detect caller's media
inactivity -- it is simply full in control of the call. Thus it
seems an ideal place for implementing a call termination functionality.
No other element in the network knows all the things the end-device 
knows. 

The missing piece is then the ability to determine maximum call
duration. A consequent application of the approach of placing the
logic in end-device would make the gateway query some database.
(It is of limited use to include this information directly in
in gateway, as multiple devices may want to share this piece of
information.) However support of such a "query-credit" protocol
does not exist in PSTN gateways. Other solutions are thus sought.

One way to make the gateway aware of the maximum call duration is
to determine it in a proxy server (which typically has programming
capabilities that allow doing so) and propagating it to gateways 
using SIP session timer. 
  http://www.iptel.org/ietf/callsignalling/#draft-ietf-sip-session-timer
This solution is scalable in that the element determining the maximum
call length is a proxy server, which is at most transactionally
stateful. No call state needs is maintained except in the
end-devices. 

The behaviour of the session-timer-based construct is as follows:
a caller intiates a call through a proxy server. The proxy server
determines maximum acceptable call length and inidiacates it using
the session timer mechanisms. The timer is then propagated to
the end-device using SIP. If it actually hits, the terminating 
gateway will try to revitalize the session using a re-INVITE. 
The proxy server then can recalculate available credit, and if too 
low, deny the re-invitation. The end-device is then supposed 
to terminate the call using a BYE.

  Note: a similar technique can be used to keep firewall
  pinholes alive.

We have never experimented with the session-timer-based solution.
We do not know if some session timer negotiation troubles can
occur. We do not know how widely support of session timer is
deployed in gateways. We do not know whether the standardization
effort for session-timer will result in some changes and when
it will complete. Nevertheless, we think it is worth trying.
Its appeal is it leaves call-termination, a call-stateful
feature, down in the end-devices and does not pose too big
burden on server developers and especially operators. The
scenario is mentioned in [ccframework], section 7.2.12.

WE THUS ENCOURAGE VOLUNTEERS TO EXPERIMENT WITH THIS OPTION.
TAKE THE GATEWAY YOU HAVE, LOOK AT IT IF IT SUPPORTS ST,
ADD ST TO SER PROXY AND CHECK IF THINGS WORK.

If end-devices do not make the job of call cut-off well, someone
else, a third-party, will have to. That is where B2BUA comes
in. It is a singaling entity that terminates signaling dialog
with both call parties and keeps dialog state during the whole
conversation time. Acting as a UA allows it to generate SIP
messages on its own (as opposed to just realying someone 
else's messages, as proxy do). Because it appears as a simple
UA to each party in the call, it works with any phone without
need for support for any extensions. Problems with use of
B2BUA are described in the next section.

One could perhaps make the cut-off component easier to
implement than a whole B2BUA. Well, as long as the implementation
is expected to be 100% conform, there is no way around it.
The BYE initiator needs to be aware of current dialog state,
it will not be able to do its job otherwise. Obvisouly,
it needs to remember initial constant information such as
call-id. However, it needs to keep information that changes
too. Particularly, it must know current CSeq -- Cseq gets
updated with in-dialog transactions and failure to send
a proper CSeq would result in denied BYE. An implementer
wishing to make his life easier and avoid the B2BUA
machinery could feel tempted just to "spoof" dialog state
in a proxy, (i.e., not to translate one into another one) and
if it decides to cut-off, send a BYE using the current
status. That introduced race conditions, however, as
another transaction may show up in middle of the cut-off
process, increase remote party's CSeq and disqualify the
delayed cut-off BYE.

So design choices are either B2BUA, or a "dialog spoofer"
with a risk of race conditions.

2. What Are B2BUA limitations?
------------------------------
B2BUA features all drawbacks of a centralized solution. Whereas
B2BUAs are applicable in the prepaid scenarios one should not
forget the price.

a) it is a single point of failure. When in the middle of
   a conversation additional sigaling occurs and the B2BUA
   is down, signaling will fail. (Doesn't happen if signaling
   runs only between end-points.) Call persistency must be
   implemented, signaling will otherwise fail on server
   reboot.
b) scalability issues: a B2BUA needs to keep state for two
   calls for the whole duration of a conversation. That might
   be an issue with too heavy traffic. Transaction state
   takes 3k per transaction and lasts seconds. Call state
   consumes at least twice so much and lasts minutes.
c) e2e security does not work -- implementations willing to
   achieve high security will want to encrypt and sign
   SIP message bodies. B2BUA breaks the e2e security if
   it needs to change the body.
d) economical aspects: it is simply yet another piece of
   non-trivial software you need to purchase or develop and
   operate. that's maybe the strongest argument: it is
   expensive.

Lot of this conversation has taken place on IETF SIP
and SIPPING mailing lists. Few messages from these
discussions are referred from  
   http://www.iptel.org/info/trends/#b2bua

3. How to Implement a B2BUA Using ser
-------------------------------------

One of the design decisions is whether to make B2BUA work
as a module or an external application bound to ser via some
of its interfaces. 

You will have to keep dialog table keyed by callid and tags,
update it on INVITE complition, remove on BYE, updated on
e.g. INFO changing dialog state.

The cut-off timer needs to be started too.

Also note, that these scenarios are based only on signaling -- there
are no PSTN-prepaid-style anouncement "you can call 5 minutes"
and "your call will be cut off in 20 seconds". It is doable too,
but it is probably more meaningful to start with the signaling.
See [tmemo_media] for more on that.

Appendix: References
--------------------
[ccframework] http://www.iptel.org/ietf/callprocessing/#draft-ietf-sipping-cc-framework


