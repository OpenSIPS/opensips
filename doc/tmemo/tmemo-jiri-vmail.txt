$Id$


Draft Voicemail Architecture
============================

Jiri Kuthan, iptel.org, January 2003

Abstract
--------

We describe design decision made when building media 
support to iptel.org's SIP server suite. We discuss
how to introduce a voicemail component most effectively,
i.e., without voicemail programmer's too big involvement
in SER. We also mention some design choices which
can be in general made to couple external applications
with SER.

TOC
---

We first discuss interfacing methods used between SIP
server/stack and applications in section 1, interfacing.
We explain why we chose FIFO for the purpose.

Section 2, IPC, gives details on use of FIFO, call flows
examples and use of FIFO is detailed in Section 3.

Possible extensions of the FIFO interface are mentioned
in section 4.

We show how the IPC/FIFO mechanisms compare to CGI-BIN
which is architecturaly close in Section 5.

1) Interfacing
--------------

A primary design objective is to hide SIP/SER internals from
application builders. The SER code is not easy: it includes
lot of shmem access along with its synchronizations, quite
dynamic memory use and management. Data structures are rich
and dynamic. That makes life of an application programmer
quite difficult and is likely to result in higher bug rate. 
Thus, it is desirable to decouple application from the stack.

We have considered two approaches: API-based and FIFO-based.
API-based approach takes a clean encapsulation of parser,
memory management and other frequently used code in a library.
The library should take away as much details as possible from
application developer.

While librarization of SER is a very desirable objective,
it is a time-expensive task and we do not want it to become
a road-block for application creation. That's the primary
argument why we are going FIFO now. 

There were technical arguments related to FIFO use in this
context too. Some (myself) were arguing that FIFO provides 
the cleanest separation of applications from ser. It is 
language-independent, allowing use of effective scripting  
languages and whatever an app programmer is familiar with. 
It is no way tied to ser's architecture and the burden of 
its parallel processing, synchronization, data structures 
and memory management.

Counter-arguments (by almost anyone else) against FIFO included
concerns that SER will become too bloated by exporting too
much of its functionality through FIFO. It is certainly 
true that a technology may become a victim of its own
success if it grows too big. SIP itself is unfortunately 
becoming an example of such technology. 

A demarcation line we agreed to draw was dialog maintenance,
which shall stay away from SER whereas transaction-related
stuff will stay in SER.


2) IPC
------

1) voicemail server will not be cranked via fork/exec
   as it is too expensive. Instead, it will be multi-
   threaded and await INVITE's via its FIFO server.
   SER will then dump incoming INVITE requests to
   voicemail's FIFO server. (non-blocking) A drawback 
   is that the FIFO server will not be able to inherit 
   pre-parsed header fields in environment variables.

2) subsequent requests, such as BYE, will take the
   same FIFO path

3) the external application will communicate with SER
   using FIFO. For the purpose of replying original
   INVITEs, there will be a t_fifo_reply command.
   The command will identify a transaction to be 
   replied using the pair hash:label. It will be further 
   parametrized by first reply line, optional header fields and 
   optional body. (The pair hash:label will have to be
   communicated via the method described in 1.)

4) to-tags will be generated in the external app.
   That's a change from previous suggestions. It's
   a consequence of moving process/thread control
   from SER to the app. In general, to-tags identify
   a call and thereby the process/thread associated with
   it. So the generation of to-tags should be owned by
   the piece responsible for spawning new processes/threads
   -- this is the place which will have to dispatch
   subsequent requests to previously spawned processes.

5) BYE's from voicemail (on timeout) will be done using
   fifo t_uac. fifo t_uac will have to be changed to
   allow parametrization of call-id/cseq. (it is ephemeral
   only now). Call-IDs and Cseq known from previous
   requests will be passed to SER via FIFO as t_uac
   parameters.

6) As for CANCEL: the voicemail app doesn't care of it.
   It is automated and responds immediately, CANCEL is thus
   not relevant. It is responsibility of the transaction 
   machine to take care of CANCELs. If they come when the 
   transaction is still alive, the CANCEL will not affect 
   the call state, it will be replied with 481 otherwise. 
   See section 9.2 of RFC 3261 for details.

3) Call Flows and FIFO Use
---------------------------

a) call setup

---> ... SIP
===> ... FIFO

UAC               SER            VM
         INVITE
         ----->
         100                          ; 100 generated automatically
         <---                         ; by t_fifo
                     t_fifo(INVITE)   ; if request acceptable, VM
                     =========>       ; stores dialog state indexed by
                                      ; newly created, unique to-tag and replies
                     t_reply(200)
                     <========
                     200 ok           ; (FIFO/200 means tranaction found and
                     ========>        ; reply accepted for delivery
         200
         <---

b) voicemail terminates call on timer

UAC              SER             VM
                     t_uac(BYE)      ; VM generates BYE using dialog context
                     <=========      ; created and stored on receipt of INVITE
                                     ; (see session 8 in rfc3261, particularly
                                     ; dealing with RR is tricky)
        BYE
        <---
        200           200
        ---->        ==========>     ; uac completed -- FIFO returns
                     

c) caller terminates

UAC              SER              VM

      BYE            t_fifo(BYE)
     ------>         ==========>     ; VM attempts to look-up the call; on look-up 
                                     ; failure or if CSeq low, it initiates t_reply 
                     t_reply(200)    ; with a negative code; otherwise, it completes
                     <==========     ; recording and confirms the BYE with a 200

--
use of FIFO:

  t_fifo is a tm action -- it creates a new transaction (t_newtran),
  sends a provisional 100 back (interaction with media component may
  take long) and dumps request to a file (presumably media server's
  FIFO):
     t_fifo("/tmp/media_fifo", "some parameters");
  The following items are dumped:
  - t_fifo (media component may receive other requests)
  - parameters
  - to_tag (optimization for a quick dialog look-up)
  - transaction identification: hash and label (used to refer
    to transaction when replying)
  - received requests
  Eventually, t_fifo sets a timer (otherwise, the application could fail
  to reply and transaction would be never released).

  t_reply is a FIFO command, which is part of tm too -- it allows external 
  apps to reply a pending transaction. It is parametrized as follows:
  - to_tag (to be used if there is no tag in original request; important
            for looking up dialog for future requests)
  - transaction identifier: hash, table
  - code
  - phrase
  - optional header fields and body
  
4) Possible Extensions of the FIFO interface
---------------------------------------------

All these extensions are thought to help coupling of external
applications with ser.

A reasonable alternative for some other applications would be to 
use exec instead of FIFO for the SER->APP path. That would
have the benefit of getting header fields conveniently 
parsed in env vars in the same way like exec module does
it (since release 0.8.11). Application would then not have to parse 
header fields.  That however makes only sense if the executed apps are 
small -- forking is expensive and all is much worse if the started 
application is big and starts slowly. 

Some other applications may wish to have other triggering
points than just request receipt. For example, they may wish
to be triggered on transaction completion (e.g., some
accounting applications) or receipt of a reply
(with the possibility to initiate  serial forking,
for example). That is implementable: transaction completion
exec can be implemented in a similar way like exec
module runs and bound to transaction machine via
a TM callback.  Care needs to be paid to the case
of exec on reply receipt -- it is called from a callback 
installed within reply processing mutex, which poses
some implementation caveats: it has performance
implications and deadlock potentials. In particular,
an exec-ed app bound to reply processing could result
in deadlock if it called FIFO/t_reply.  Also at least
an evnironment variable describing reply status would
have to be added, so that the script sees more than
the original request.

5) SIP CGI-BIN (RFC3050) comparison
-----------------------------------
SIP-CGI BIN is a nice mechanism for coupling external applications
with SIP servers. It is textual, language-independent, separated
from server processes. From this perspective, it is similar
to SER's app-coupling mechanisms, which include execution of external 
applications as in exec module potentialy integrated in TM's transaction 
management. The reason why SER is somewhat different is of historical 
nature: we have been trying to address mainstream scenarios with
compact solutions. They developed in course of time to bigger beasts 
comparable to SIP CGI-BIN today, but still different. We now try to
explain how SER/FIFO/exec compares to SIP CGI-BIN. 

   Note that there are some applications, in which ser's FIFO server
   can be used whereas CGI-BIN is not applicable. Particular, the
   FIFO server can be used if an application wants to initiate
   transactions or dialogs. CGI-BIN is only evoked when server
   (through receipt of a messages) want to run applications.

Also, knowledge of the gaps may be used to implement CGI-BIN for
SER, if ever wanted.

Similarities:
- both CGI and t_exec (as suggested in #4) can start external apps
  on request receipt; retransmissions and other transaction burden
  is handled by the server
- both CGI apps and t_exec apps can steer proxy server's 
  transaction logic; CGI apps do so by returning instructions 
  on stdout, t_exec apps can do so through FIFO server

SER Defficiencies:
- enabling applications to remove header fields (CGI permits that)
  through FIFO currently not possible -- there is no such a FIFO
  command; should not be difficult to implement
- request forwarding neither, for the same reason -- no such a FIFO
  command; easy to change, though
- the application can be re-execed on receipt of a reply from
  a reply_route like in CGI BIN; however, there are no meaningful
  FIFO actions that can be used; use of FIFO/t_reply can result
  in a deadlock as reply_route is called from within a reply_lock,
  which is initiated by t_reply called from FIFO server too
