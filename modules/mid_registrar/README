mid_registrar Module

Liviu Chircu

   OpenSIPS Solutions
   <liviu@opensips.org>

Edited by

Liviu Chircu

   Copyright © 2016 www.opensips-solutions.com
     __________________________________________________________

   Table of Contents

   1. Admin Guide

        1.1. Overview
        1.2. Working modes

              1.2.1. Mirror (default, mode = 0)
              1.2.2. Device throttling (mode = 1)
              1.2.3. User throttling (mode = 2)

        1.3. Contact routing modes

              1.3.1. Route by Contact (default,
                      contact_routing_mode = 0)

              1.3.2. Route by Path (contact_routing_mode = 1)

        1.4. Dependencies

              1.4.1. OpenSIPS Modules
              1.4.2. External Libraries or Applications

        1.5. Exported Parameters

              1.5.1. mode (integer)
              1.5.2. contact_routing_mode (integer)
              1.5.3. outgoing_expires (integer)
              1.5.4. contact_match_param (string)

        1.6. Exported Functions

              1.6.1. mid_registrar_save(domain[, [flags][, [aor][,
                      [outgoing_expires]]]])

              1.6.2. mid_registrar_lookup(domain[, [flags][,
                      [aor]]])

   List of Examples

   1.1. Setting the mode module parameter
   1.2. Setting the contact_routing_mode module parameter
   1.3. Setting the outgoing_expires module parameter
   1.4. Setting the contact_match_param module parameter
   1.5. mid_registrar_save usage
   1.6. mid_registrar_lookup usage

Chapter 1. Admin Guide

1.1. Overview

   The mid_registrar component of a VoIP platform is a
   registration front-end, an in-between SIP registrar. It opens
   up new possibilities for leveraging existing infrastructure in
   order to support larger user bases / heavier traffic loads
   while minimizing the need to add additional hardware. This is
   possible through the optimized SIP user location implementation
   of OpenSIPS, capable of handling high subscriber numbers and
   large amounts of registration traffic.

   The main motivation behind the mid-registrar concept stems from
   the fact that SIP User Agents have been (and still are!)
   continually shifting towards mobile devices. These UAs are
   known to have unstable network presence, hence they have short
   built-in registration times, imposed by their manufacturers
   (usually 60 seconds). This, in effect, causes them to put more
   and more registration traffic overhead on existing platforms.

   Acting as an intermediary registration front-end between users
   and main SIP registrar, the mid-registrar is able to:
     * convert incoming high-rate registration traffic into a
       low-rate variant, towards the main registrar layer. With
       proper configuration, it can absorb over 90% of existing
       registration traffic while preserving the back-end's user
       location state, effectively reducing resource usage at the
       respective layer.
     * stay in perfect sync with the registration back-end (from a
       SIP perspective), by properly adhering to the contact
       states and expiration times imposed by the main registrar

1.2. Working modes

   Depending on the value of the mode module parameter, the
   mid_registrar can function in one of the following ways:

1.2.1. Mirror (default, mode = 0)

   This basic usage of the module highlights its capability to
   properly handle expiry times imposed by the main registrar
   layer. In other words, any contact-related operation will only
   be performed on a 200 OK reply.

   In "mirror mode", the mid-registrar will not alter any Contact
   or Expires header, nor append additional ones. It will not
   modify a REGISTER request at all.

   A possible usage of this mode, for example, would be to cache
   registrations in order to offload the main registrar from
   processing a subset of all types of incoming SIP requests.

1.2.2. Device throttling (mode = 1)

   This working mode employs a SIP contact-oriented approach
   (hence "device"), in which subsequent registration traffic is
   throttled (i.e. absorbed / immediately replied to / not
   forwarded to the main registrar) for each unique SIP "Contact"
   header field that manages to successfully register.

   Device throttling is the first level of registration traffic
   optimization. This is possible through the use of the
   outgoing_expires module parameter or the corresponding
   parameter to mid_registrar_save(), which allow the script
   writer to prolong the life of the registrations on the way to
   the main registrar.

   Once a prolonged registration is completed, subsequent
   registrations for the same SIP Contact header field value will
   be continuously absorbed by the mid-registrar until,
   eventually, the lifetime of the remote registration will have
   decreased enough that a refresh (i.e. simply forwarding the
   next REGISTER request) is mandatory.

   A common occurence is for some SIP User Agents to lose their
   network connection (especially when dealing with mobile
   devices), hence not de-registering themselves from the
   mid-registrar. In this case, in order to avoid zombie
   registrations on the main registrar (which contains SIP
   contacts with greatly extended lifetimes!), the mid-registrar
   will appropriately generate De-REGISTER requests and remove
   these contacts from the main registrar's location service as
   soon as it considers them to have expired.

   In "device throttling mode", depending on the
   "outgoing_expires" value, the mid-registrar may alter Contact
   header field values found in the initial request, including
   their ";expires" parameters, as needed. If an "Expires" header
   field is present, its value may also be altered. Finally, the
   module may also insert a "Path" header if the
   countact_routing_mode module parameter indicates this.

   Practical usages for this mode include the above "registration
   caching" concept, along with "traffic conversion". The latter
   does nothing more than to save resources on the back-end layer,
   allowing it to dedicate more processing power to critical areas
   of the platform, such as advanced SIP calling features and/or
   media handling.

1.2.3. User throttling (mode = 2)

   This working mode employs a SIP Address-of-record-oriented
   approach (hence "user"), in which subsequent registration
   traffic is throttled (i.e. absorbed / immediately replied to /
   not forwarded to the main registrar) for each unique SIP "To"
   header field username part that manages to successfully
   register.

   User-level throttling is the second level of registration
   traffic optimization, effectively building upon the previous
   "device throttling" mode. This is also possible through the use
   of the outgoing_expires module parameter or the corresponding
   parameter to mid_registrar_save(), which allow the script
   writer to prolong the life of the registrations on the way to
   the main registrar.

   Once a prolonged registration is completed, subsequent
   registrations to the same Address-of-record (the username of
   the "To" header field URI of a REGISTER request) will be
   continuously absorbed by the mid-registrar until, eventually,
   the lifetime of the remote registration will have decreased
   enough that a refresh (i.e. simply forwarding the next REGISTER
   request) is mandatory.

   A common occurence is for some SIP User Agents to lose their
   network connection (especially when dealing with mobile
   devices), hence not de-registering themselves from the
   mid-registrar. In this case, in order to avoid zombie
   registrations on the main registrar (which contains SIP
   contacts with greatly extended lifetimes!), the mid-registrar
   will appropriately generate De-REGISTER requests and remove
   these contacts from the main registrar's location service as
   soon as it considers them to have expired.

   Of all three modes, "user throttling" potentially offers the
   best reduction in traffic on the way to the main registrar. By
   aggregating contacts, it also has the added benefit of reducing
   the number of contacts that the main registrar must handle.

   Regarding SIP request mangling in this mode, the module will
   always replace all Contact header fields with a single Contact
   header field, for registration requests headed over to the main
   registrar, indicating that the AoR is local to the front-end,
   along with all of its contacts.

   Practical usages for this mode include the "registration
   caching" concept, along with "traffic conversion". The latter
   does nothing more than to save resources on the back-end layer,
   allowing it to dedicate even more processing power to critical
   areas of the platform, such as advanced SIP calling features
   and/or media handling.

1.3. Contact routing modes

   A defining feature of the module is that it must be easy to
   integrate, ideally a "plug-and-play" SIP component, without
   imposing any additional "outbound-proxy" configurations on any
   of the platform's layers.

   With the above in mind, the script writer can choose between
   two out-of-the-box contact routing mechanisms: either by having
   the module modify Contact headers when forwarding
   registrations, or instruct it to make use of a Path header (RFC
   3327).

1.3.1. Route by Contact (default, contact_routing_mode = 0)

   In this routing mode, the module will mangle the Contact header
   field values of all forwarded registration requests, by
   replacing any original IP and port of a Contact URI with those
   of one of the mid-registrar's listening interfaces.

   The module will also append a parameter to each Contact URI
   ("rinstance" by default, can be changed through the
   contact_match_param module parameter) This URI parameter allows
   reply contacts to be matched with the ones from the request.
   This same parameter will also be used when routing calls to the
   users. In this case, it will be taken from the INVITE's
   Request-URI.

1.3.2. Route by Path (contact_routing_mode = 1)

   Instructs the module to append a "Path" header field to each
   forwarded registration request. By recording itself between
   each user and the main registrar, the mid-registrar allows
   subsequent calls to be properly routed to the called party.

1.4. Dependencies

1.4.1. OpenSIPS Modules

   The following modules must be loaded before this module:
     * usrloc
     * signaling
     * tm

1.4.2. External Libraries or Applications

   The following libraries or applications must be installed
   before running OpenSIPS with this module loaded:
     * None

1.5. Exported Parameters

1.5.1. mode (integer)

   Working mode of the module. Refer to Section 1.2, “Working
   modes” for more details. Possible values are:
     * 0 (mirror mode)
     * 1 (device throttling mode)
     * 2 (user throttling mode)

   Default value is 0 (mirror mode)

   Example 1.1. Setting the mode module parameter
modparam("mid_registrar", "mode", 2)

1.5.2. contact_routing_mode (integer)

   Contact routing mode of the module. Only relevant in "device
   throttling" mode. Refer to Section 1.3, “Contact routing modes”
   for more details. Possible values are:
     * 0 (route by Contact)
     * 1 (route by Path)

   Default value is 0 (route by Contact)

   Example 1.2. Setting the contact_routing_mode module parameter
modparam("mid_registrar", "contact_routing_mode", 1)

1.5.3. outgoing_expires (integer)

   Only relevant in device/user throttling modes. Sets the default
   value for the expiration intervals of outgoing contacts. Values
   for this parameter which are shorter than the expiration
   intervals of some contacts present in a REGISTER request being
   processed will lead to the outgoing expiration intervals of
   these contacts remaining unchanged.

   Default value is 600 (seconds)

   Example 1.3. Setting the outgoing_expires module parameter
modparam("mid_registrar", "outgoing_expires", 3600)

1.5.4. contact_match_param (string)

   Only relevant in device throttling mode. Specifies the name of
   the Contact URI parameter which is used by the module in order
   to match contacts and route calls.

   Default value is “rinstance”

   Example 1.4. Setting the contact_match_param module parameter
modparam("mid_registrar", "contact_match_param", "mid-reg-id")

1.6. Exported Functions

1.6.1.  mid_registrar_save(domain[, [flags][, [aor][,
[outgoing_expires]]]])

   Sets up the internally required hooks in order for the user
   location update (i.e. any contact additions/updates/deletions)
   to be transparently performed once a 200 OK reply is received.

   In device/user throttling modes (more info about working modes
   in Section 1.2, “Working modes”), the return value of this
   function indicates whether the script writer must forward the
   REGISTER request to the main registrar, or just wrap up any
   left-over processing and exit script execution, as the current
   REGISTER request has been answered with 200 OK (absorbed at
   mid-registrar level).

   In the above-mentioned working modes, the mid_registrar_save()
   function may additionally perform the following series of
   transformations when relaying REGISTER requests:

     * in "device throttling" mode
          + change the value of the Expires header field to the
            value of outgoing_expires, if given, otherwise the
            value given by the outgoing_expires module parameter.
            The same applies to any ";expires" Contact URI
            parameter.
          + replace the "host:port" part of all Contact URIs of
            the incoming REGISTER request with an OpenSIPS
            listening interface
          + append a parameter to each Contact URI, which will
            allow the module to match the reply contacts and also
            route calls. The name of this URI parameter is
            configurable via contact_match_param
     * in "user throttling" mode
          + change the value of the Expires header field to the
            value of outgoing_expires, if given, otherwise the
            value given by the outgoing_expires module parameter.
          + replace all Contact header fields of the request with
            a single Contact header field, which will contain the
            following SIP URI:
            "sip:address-of-record@proxy_ip:proxy_port"

   Meaning of the parameters is as follows:
     * domain - logical domain within the registrar. If a database
       is used, then this must be name of the usrloc table which
       stores the contacts
     * flags (optional) - TODO - not fully implemented
     * aor (optional) - variable holding a custom
       Address-of-Record. If not given, the AoR will be taken from
       the To header URI
     * outgoing_expires (optional, only relevant in device/user
       throttling modes) - custom value for the contact expiration
       interval of the outgoing REGISTER request, which overrides
       the default outgoing_expires module parameter.

   Return value
     * 1 (success) - current REGISTER request must be dispatched
       by the script writer over to the main registrar
     * 2 (success) - current REGISTER request has been absorbed by
       the mid-registrar; a 200 OK reply has been sent upstream
     * -1 (error) - generic error code; the logs should provide
       more help

   This function can only be used from the request route.

   Example 1.5. mid_registrar_save usage
...
if (is_method("REGISTER")) {
        mid_registrar_save("location");
        switch ($retcode) {
        case 1:
                xlog("L_INFO", "forwarding REGISTER to main registrar...
\n");
                $ru = "sip:10.0.0.3:5070";
                if (!t_relay()) {
                        send_reply("500", "Server Internal Error 1");
                }

                break;
        case 2:
                xlog("L_INFO", "REGISTER has been absorbed!\n");
                break;
        default:
                xlog("L_ERR", "mid-registrar error!\n");
                send_reply("500", "Server Internal Error 2");
        }

        exit;
}
...

1.6.2.  mid_registrar_lookup(domain[, [flags][, [aor]]])

   Performs the necessary processing in order to build the proper
   branch set for the currently requested Address-of-record.
   Depending on the current working mode, the function will behave
   as follows:

     * in "mirror" mode
          + extract the username (Address-of-Record) from the
            Request-URI and look up all of its contact bindings
            stored in the user location. The Request-URI ($ru
            variable) will be overwritten with the highest q-value
            contact, with additional branches for each contact
            being optionally created. (depending on the flags
            parameter)
     * in "device throttling" mode
          + extract the contact_match_param from the Request-URI,
            derive the actual SIP URI of the destination from it
            and set it as the new Request-URI of the INVITE ($ru
            variable).
     * in "user throttling" mode
          + extract the username (Address-of-Record) from the
            Request-URI and look up all of its contact bindings
            stored in the user location. The Request-URI ($ru
            variable) will be overwritten with the highest q-value
            contact, with additional branches for each contact
            being optionally created. (depending on the flags
            parameter)

   Meaning of the parameters is as follows:
     * domain - logical domain within the registrar. If a database
       is used, then this must be name of the usrloc table which
       stores the contacts
     * flags (optional) - TODO - not fully implemented
     * aor (optional) - variable holding a custom
       Address-of-Record. If not given, the AoR will be taken from
       the Request-URI

   Return value
     * 1 (success) - branch set successfully built
     * -1 (error) - generic error code; the logs should provide
       more help

   This function can only be used from the request route.

   Example 1.6. mid_registrar_lookup usage
...
        # initial invites from the main registrar - need to look them up
!
        if (is_method("INVITE") and $si == "10.0.0.3" and $sp == 5070) {
                if (!mid_registrar_lookup("location")) {
                        t_reply("404", "Not Found");
                        exit;
                }

                if (!t_relay())
                        send_reply("500", "Server Internal Error 3");

            exit;
        }
...
