#
# $Id$
#
# simple quick-start config script
#

# ----------- global configuration parameters ------------------------

debug=3          # debug level (cmd line: -dddddddddd)
fork=no
log_stderror=yes

check_via=no	# (cmd. line: -v)
dns=no           # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
port=5060
children=0
fifo="/tmp/ser_fifo"


# ------------------ module loading ----------------------------------


loadmodule "/home/gva/sip_router/modules/sl/sl.so"
loadmodule "/home/gva/sip_router/modules/tm/tm.so"
loadmodule "/home/gva/sip_router/modules/rr/rr.so"
loadmodule "/home/gva/sip_router/modules/maxfwd/maxfwd.so"
loadmodule "/home/gva/sip_router/modules/usrloc/usrloc.so"
loadmodule "/home/gva/sip_router/modules/registrar/registrar.so"
/* for the search()  export */
loadmodule "/home/gva/sip_router/modules/textops/textops.so"
loadmodule "/home/gva/sip_router/modules/mangler/mangler.so"


# Uncomment this if you want digest authentication
# mysql.so must be loaded !
#loadmodule "/usr/lib/ser/modules/auth.so"

# ----------------- setting module-specific parameters ---------------
# seting separator for encoded contact
modparam("mangler","contact_flds_separator","*")


# -- usrloc params --
modparam("usrloc", "db_mode",   0)


# -------------------------  request routing logic -------------------

# main routing logic

route{

	# initial sanity checks -- messages with
	# max_forwards==0, or excessively long requests
	if (!mf_process_maxfwd_header("10")) {
		sl_send_reply("483","Too Many Hops");
		break;
	};
	if (len_gt( max_len )) {
		sl_send_reply("513", "Message too big");
		break;
	};

	record_route();	
	# if the request is for other domain use UsrLoc
	# (in case, it does not work, use the following command
	# with proper names and addresses in it)
	if (uri==myself) {

		if (method=="REGISTER") {
			save("location");
			break;
		};

		# native SIP destinations are handled using our USRLOC DB
		if (!lookup("location")) {
			sl_send_reply("404", "Not Found");
			break;
		};
	};


        /* REPLACE PUBLIC WITH PUBLIC ADDRESS OF NAT BOX */

        /* outgoing connection */
        if (src_ip == 10.0.0.0/8)
        {
        /* we mangle the contact address and ports in SDP
        part of the message
         */
         if (method == "INVITE")
                {
                    sdp_mangle_ip("10.0.0.0/8","PUBLIC");
                    /* diferent mangling based on what phone we use */
                    if (src_ip==10.0.0.1) sdp_mangle_port("+1000");
                    if (src_ip==10.0.0.2) sdp_mangle_port("-1000");
                    
                };
            

         if (search("Contact: .*@10\.")) /* an adress like 10. */
            {
            /* we seem to have a private address on a Contact 
            which is not valid */
             encode_contact("enc_prefix","PUBLIC");
            };
        /*
            #if ser is behind a NAT and NAT box has port forwarding
            #on port 5060 set to our ser private address ...
            record_route(PUBLIC);
        */
        } else /* incoming connection */
        {
            ;/* we should only mangle replies */
        };
        
        /* we received something for a local phone */
        if (uri=~"enc_prefix*")
            {
            decode_contact();
            forward(uri:host,uri:port);
            break;
            };

        
	# forward to current uri now; use stateful forwarding; that
	# works reliably even if we forward from TCP to UDP
	if (!t_relay()) {
		sl_reply_error();
	};

}

