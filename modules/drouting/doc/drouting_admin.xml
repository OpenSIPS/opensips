<!-- Drouting Module User's Guide -->

<chapter>
	<title>&adminguide;</title>

	<section id="overview" xreflabel="Overview">
	<title>Overview</title>
	<section>
	<title>Introduction</title>

	<para>Dynamic Routing is a module for selecting (based on multiple
	criteria) the best gateway/destination to be used for delivering a
	certain call. Least Cost Routing (LCR) is a special case of dynamic
	routing - when the rules are ordered based on costs. Dynamic Routing
	comes with many features regarding routing rule selection:
	</para>
	<itemizedlist>
		<listitem><para>prefix based</para></listitem>
		<listitem><para>caller/group based</para></listitem>
		<listitem><para>time based</para></listitem>
		<listitem><para>priority based</para></listitem>
	</itemizedlist>
	<para>
	, processing :
	</para>
	<itemizedlist>
		<listitem><para>stripping and prefixing</para></listitem>
		<listitem><para>default rules</para></listitem>
		<listitem><para>inbound and outbound processing</para></listitem>
		<listitem><para>script route triggering</para></listitem>
	</itemizedlist>
	<para>
	and failure handling:
	<itemizedlist>
		<listitem><para>serial forking</para></listitem>
		<listitem><para>weight based GW selection</para></listitem>
		<listitem><para>random GW selection</para></listitem>
		<listitem><para>GW probing for crashes</para></listitem>

	</itemizedlist>
	</para>
</section>

<section>
	<title>Features</title>
	<para>
	The dynamic routing implementation for &osips; is designed with the
	following properties:
	</para>
	<itemizedlist>
	<listitem>
	<para>
	The routing info (destinations, carriers, rules, groups) is stored in a
	database and loaded into memory at start up time; reload at runtime via
	a Management Interface command.
	</para>
	</listitem>

	<listitem>
	<para>
	weight-based or random selection of the destinations (from a rule or
	 from a carrier), failure detection of gateways (with switching to next
	 available gateway).
	</para>
	</listitem>

	<listitem>
	<para>
	able to handle large volume of routing info (10M of rules) with minimal
	speed/time and memory consumption penalties
	</para>
	</listitem>

	<listitem>
	<para>
	script integration - Pseudo-variable support in functions; scripting
	route triggering when rules are matched
	</para>
	</listitem>

	<listitem>
	<para>
	bidirectional behavior - inbound and outbound processing (strip and
	prefixing when sending and receiving from a destination/GW)
	</para>
	</listitem>

	<listitem>
	<para>
	blacklisting - the module allows definition of blacklists based on the
	destination IPs. This blacklists are to be used to prevent malicious
	forwarding to GWs (based on DNS lookups) when the script logic does
	none-GE forwarding (like foreign domains).
	</para>
	</listitem>

	<listitem>
	<para>
	loading routing information from multiple databases - the gateways, rules, groups and
	carriers can be grouped by partitions, and each partition may be loaded
	from different databases/tables. This makes the routing process partition
	based. In order to be able to use a table from a partition, its name must
	be found in the "version" table belonging to the database defined in the
	partition's db_url.
	</para>
	</listitem>

	</itemizedlist>
</section>


<section>
	<title>Performance</title>
	<para>
	There were several tests performed regarding the performance of the module
	when dealing with a large number of routing rules.
	</para>
	<para>
	The tests were performed with a set of 383000 rules and measured:
	</para>
	<itemizedlist>
	<listitem><para>time to load from DB</para></listitem>
	<listitem><para>used shared memory</para></listitem>
	</itemizedlist>
	<para>
	The time to load was varying between 4 seconds and 8 seconds, depending of
	the caching of the DB client - the first load was the slowest (as the DB
	query hits the disk drive); the following are faster as data is already
	cached in the DB client. So technically speaking, the time to load (without
	the time to query which is DB type dependent) is ~4 seconds
	</para>
	<para>
	After loading the data into shared memory ~ 96M of memory were used
	exclusively for the DR data.
	</para>
</section>


<section>
	<title>Dynamic Routing Concepts</title>
	<para>
	DR engine uses several concepts in order to define how the routing
	should be done (describing all the dependencies between destinations
	and routing rules).
	</para>

	<section>
	<title>Destination/Gateways</title>
	<para>
	These are the end SIP entities where actually the traffic needs to be sent
	after routing. They are stored in a table called <quote>dr_gateways</quote>.
	Gateway addresses are stored in a separate table because of the need to access them
	independent of Dynamic Routing processing (e.g., adding/ removing gateway PRI
	prefix before/after performing other operation -- receiving/relaying to gateway).
	</para>
	<para>
	In DR, a gateway is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>SIP address (SIP URI)</para></listitem>
	<listitem><para>type (integer which allows GWs to be grouped by purpose,
	e.g. inbound, outbound, etc.)</para></listitem>
	<listitem>strip value (number of digits) from dialled
	number<para></para></listitem>
	<listitem><para>prefix (string) to be added to dialled
	number</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this GW)</para></listitem>
	<listitem><para>probing mode (how the GW should be probed at SIP level
	- see the probing chapter)</para></listitem>
	</itemizedlist>
	<para>
	The Gateways are to be used from the routing rule or from the carrier
	definition. They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Carriers</title>
	<para>
	The carrier concept is used if you need to group gateways in order to
	have a better control on how the GWs will be used by DR rules; like
	in what order the GWs will be used.
	</para>
	<para>
	Basically, a carrier is a set of gateways which have its own sorting
	algorithm and its own attribute string. They are by default defined
	in the <quote>dr_carriers</quote> table.
	</para>
	<para>
	In DR, a carrier is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>list of gateways with/without weights (string)
	(Ex:<quote>gw1=10,gw4=10</quote> or <quote>gw1,gw2</quote>
	</para></listitem>
	<listitem><para>flags : 0x1 - use only the first gateway from the carrier
	(depending on the sorting); 0x2 - disable the usage of this
	carrier</para></listitem>
	<listitem><para>sort algorithm : how the list of the gateways should be
	sorted before being used, NULL - use the DB given order, W - do weight
	based re-ordering, Q - do quality based sorting (requires the qrouting 
	module)</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this carrier)</para></listitem>
	</itemizedlist>
	<para>
	The Carriers are to be used only from the routing rule definition.
	They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Routing Rules</title>
	<para>
	These are the actual rules which control the routing. Using
	different criterias (prefix, time, priority, etc), they will decide
	to which gateways the call will be sent.
	</para>
	<para>
	Default name for the table storing rule definitions is
	<quote>dr_rules</quote>.
	</para>
	<para>
	In DR, a routing rule is defined by:
	</para>
	<itemizedlist>
	<listitem><para>group (list of numbers) - rules can be grouped (a rule may
	belong to multiple groups in the same time ) and you can
	use only a certain group at a point; like having a <quote>premium</quote> or
	<quote>standard</quote> or <quote>interstate</quote> or
	<quote>intrastate</quote> groups of rules to be used in different
	cases</para></listitem>
	<listitem><para>prefix (string with digits only) - prefix to be used for
	matching this rule (longest prefix matching)</para></listitem>
	<listitem><para>time validity (time recurrence string) - when this rule is
	valid from time point of view (see RFC 2445)</para></listitem>
	<listitem><para>priority (number) - priority of the rule - higher value,
	higher priority (see rule section alg)</para></listitem>
	<listitem><para>script route ID (string) - if defined, then execute the
	route with the specified ID when this rule is matched. That's it, a route
	which can be used to perform custom operations on message. NOTE that no
	modification is performed at signaling level and you must NOT do
	any signaling operations in that script route</para></listitem>
	<listitem><para>list of GWs/carriers (string) - a comma separated list
	of gateways or carriers (defined by IDs) to be used for this rule; the
	carrier IDs are prefixed with <quote>#</quote> sign. For each ID (GW or
	carrier) you may specify a weight. For how this list will be interpreted
	(as order) see the rule selection section. Example of list:
	<quote>gw1,gw4,#cr3</quote> or <quote>gw1=10,gw4=10,#cr3=80</quote>
	</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when this rule matched and been used)</para></listitem>
	</itemizedlist>

	<para>
	More on time recurrence:
	</para>
	<itemizedlist>
	<listitem><para>
	A date-time expression that defines the time recurrence to be matched for
	current rule. Time recurrences are based closely on the recurring time
	intervals from the Internet Calendaring and Scheduling Core Object
	Specification (calendar COS), RFC 2445. The set of attributes used in
	a routing rule specification is a subset of time recurrence attributes.
	</para></listitem>
	<listitem><para>
	The value stored in database has the basic format of:
	<![CDATA[
	<timezone>|<dtstart>|<dtend>|<duration>|<freq>|<until>|<interval>|<byday>|<bymonthday>|<byyearday>|<byweekno>|<bymonth>
	]]>
	, identical to the input of the <ulink url='cfgutils#func_check_time_rec'>check_time_rec()</ulink>
	function of the <emphasis>cfgutils</emphasis> module, including the optional
	use of logical operators linking multiple such strings into a larger expression.
	</para></listitem>
	<listitem><para>
	When an attribute is not specified, the corresponding place must be left
	empty, whenever another attribute that follows in the list has to be
	specified.
	</para></listitem>
	</itemizedlist>
	</section>
</section>


<section>
	<title>Routing Rule Processing</title>
	<para>
	The module can be used to find out which is the best gateway to use for new
	calls terminated to PSTN. The algorithm to select the rule is as follows:
	<itemizedlist mark='bullet'>
	<listitem>
	<para>
	the module discovers the routing group of the originating user. This
	step is skipped if a routing group is passed from the script as parameter.
	</para>
	</listitem>
	<listitem>
	<para>
	once the group is known, in the subset of the rules for this group the
	module looks for the one that matches the destination based on "prefix"
	column. The set of rules with the longest prefix is chosen. If no digit
	from the prefix matches, the default rules are used (rules with no prefix)
	</para>
	</listitem>
	<listitem>
	<para>
	within the set of rules is applied the time criteria, and the rule which
	has the highest priority and matches the time criteria is selected to drive
	the routing.
	</para>
	</listitem>
	<listitem>
	<para>
	Once found the rule, it may contain a route ID to execute. If a certain
	flag is set, then the processing is stopped after executing the route
	block.
	</para>
	</listitem>
	<listitem>
	<para>
	The rule must contain a chain of gateways and carriers. The module will
	execute serial forking for each address in the chain (ordering is either done
	by simply using the definition order or it may weight-based - weight selection must be
	enabled). The next address in chain is used only if the previously has failed.
	</para>
	</listitem>
	<listitem>
	<para>
	With the right gateway address found, the prefix (PRI) of the gateway is
	added to the request URI and then the request is forwarded.
	</para>
	</listitem>
	</itemizedlist>
	</para>
	<para>
	If no rule is found to match the selection criteria an default action must
	be taken (e.g., error response sent back). If the gateway in the chain has
	no prefix the request is forwarded without adding any prefix to the request
	URI.
	</para>
</section>


<section>
	<title>Probing and Disabling destinations</title>
	<para>
	The module has the capability to monitor the status of the destinations by
	doing SIP probing (sending SIP requests like OPTIONS).
	</para>
	<para>
	For each destination, you can configure what kind of probing should be
	done (probe_mode column):
	</para>
	<itemizedlist>
	<listitem>
		<para><emphasis>(0)</emphasis> - no probing at all;</para>
	</listitem>
	<listitem>
		<para><emphasis>(1)</emphasis> - probing only when the destination is
		in disabled mode (disabling via MI command will completely stop the
		probing also). The destination will be automatically re-enabled
		when the probing will succeed next time;</para>
	</listitem>
	<listitem>
		<para><emphasis>(2)</emphasis> - probing all the time. If disabled,
		the destination will be automatically re-enabled when the probing
		will succeed next time;
		</para>
	</listitem>
	</itemizedlist>
	<para>
	A destination can become disabled in two ways:
	<itemizedlist>
	<listitem>
		<emphasis>script detection</emphasis> - by calling from script the
		dr_disable() function after trying the destination. In this case, if
		probing mode for the destination is (1) or (2), the destination will
		be automatically re-enabled when the probing will succeed.
	</listitem>
	<listitem>
		<emphasis>MI command</emphasis> - by calling the dr_gw_status MI
		command for disabling (on demand) the destination. If so, the probing
		and re-enabling of this destination will be completly disabled until
		you re-enable it again via MI command - this is designed to allow
		controlled and complete disabling of some destination during
		maintenance.
	</listitem>
	</itemizedlist>
	</para>
</section>

</section>


	<section id="dependencies" xreflabel="Dependencies">
	<title>Dependencies</title>
	<section>
		<title>&osips; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>

			<listitem>
			<para>
				<emphasis>a database module</emphasis>.
			</para>
			</listitem>
			</itemizedlist>

			<itemizedlist>
			<listitem>
			<para>
				<emphasis>tm module</emphasis>.
			</para>
			</listitem>

			<listitem>
			<para>
				<emphasis>clusterer</emphasis> - only if "cluster_id"
				option is enabled.
			</para>
			</listitem>

			</itemizedlist>
		</para>
	</section>

	<section>
		<title>External Libraries or Applications</title>
		<itemizedlist>
			<listitem>
			<para>
				<emphasis>none</emphasis>.
			</para>
			</listitem>
		</itemizedlist>

		</section>
	</section>

	<section id="exported_parameters" xreflabel="Exported Parameters">
	<title>Exported Parameters</title>
	<section id="param_db_url" xreflabel="db_url">
		<title><varname>db_url</varname>(str)</title>
		<para>
		The database url.
		</para>
		<para>
		<emphasis>	Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")
...
</programlisting>
		</example>
	</section>
	<section id="param_drd_table" xreflabel="drd_table">
		<title><varname>drd_table</varname>(str)</title>
		<para>
		The name of the db table storing gateway addresses.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_gateways</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drd_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drd_table", "dr_gateways")
...
</programlisting>
		</example>
	</section>
	<section id="param_drr_table" xreflabel="drr_table">
		<title><varname>drr_table</varname>(str)</title>
		<para>
		The name of the db table storing routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_rules</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drr_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drr_table", "rules")
...
</programlisting>
		</example>
	</section>

	<section id="param_drg_table" xreflabel="drg_table">
		<title><varname>drg_table</varname>(str)</title>
		<para>
		The name of the db table storing groups.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_groups</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_table", "groups")
...
</programlisting>
		</example>
	</section>

	<section id="param_drc_table" xreflabel="drc_table">
		<title><varname>drc_table</varname>(str)</title>
		<para>
		The name of the db table storing definitions of the carriers that will
		be used directly by the routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_carriers</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drc_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drc_table", "my_dr_carriers")
...
</programlisting>
		</example>
	</section>

	<section id="param_ruri_avp" xreflabel="ruri_avp">
		<title><varname>ruri_avp</varname> (str)</title>
		<para>
		The name of the avp for storing Request URIs to be later used
		(alternative destiantions for the current one).
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_ruri__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_ruri__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>ruri_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "ruri_avp", '$avp(33)')
...
	</programlisting>
		</example>
	</section>


	<section id="param_gw_id_avp" xreflabel="gw_id_avp">
		<title><varname>gw_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current selected
		gateway/destination - once a new destination is selected (via the
		use_next_gw() function), the AVP will be updated with the ID of the
		new selected gateway/destination.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_gw_id__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_gw_id__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_id_avp", '$avp(gw_id)')
modparam("drouting", "gw_id_avp", '$avp(334)')
...
	</programlisting>
		</example>
	</section>

	<section id="param_gw_priprefix_avp" xreflabel="gw_priprefix_avp">
		<title><varname>gw_priprefix_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the PRI prefix of the current selected
		destination/gateway - once a new destination is selected (via the
		use_next_gw() function), the AVP will be updated with the PRI prefix of the
		new used destination.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_priprefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_priprefix_avp", '$avp(gw_priprefix)')
...
	</programlisting>
		</example>
	</section>


	<section id="param_rule_id_avp" xreflabel="rule_id_avp">
		<title><varname>rule_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current matched
		routing rule (see dr_rules table).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_id_avp", '$avp(rule_id)')
modparam("drouting", "rule_id_avp", '$avp(335)')
...
	</programlisting>
		</example>
	</section>

	<section id="param_rule_prefix_avp" xreflabel="rule_prefix_avp">
		<title><varname>rule_prefix_avp</varname> (str)</title>
		<para>
		The actual prefix that matched the routing rule (the part from RURI
		username that matched the routing rule).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_prefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_prefix_avp", '$avp(dr_prefix)')
...
	</programlisting>
		</example>
	</section>


	<section id="param_carrier_id_avp" xreflabel="carrier_id_avp">
		<title><varname>carrier_id_avp</varname> (str)</title>
		<para>
		AVP to be populate with the ID string for the carrier the
		current GW belongs to.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>carrier_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "carrier_id_avp", '$avp(carrier_id)')
...
	</programlisting>
		</example>
	</section>


	<section id="param_gw_sock_avp" xreflabel="gw_sock_avp">
		<title><varname>gw_sock_avp</varname> (str)</title>
		<para>
		The name of the avp for storing sockets for alternative destinations
		defined by ruri_avp.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_sock__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_sock__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_sock_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_sock_avp", '$avp(dr_sock)')
modparam("drouting", "gw_sock_avp", '$avp(77)')
...
	</programlisting>
		</example>
	</section>

	<section id="param_define_blacklist" xreflabel="define_blacklist">
		<title><varname>define_blacklist</varname> (str)</title>
		<para>
		Defines a blacklist based on a list of GW types - the blacklist will 
		be populated with the IPs (no port, all protocols) of the GWs having 
		the specified types.
		</para>
		<para>
		If partitions are used, prefix the blacklist definition string with 
		the name of the partition followed by ":" separator.
		</para>
		<para>
		Multiple instances of this param are allowed.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>define_blacklist</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "define_blacklist", 'bl_name= 3,5,25,23')
modparam("drouting", "define_blacklist", 'list= 4,2')
modparam("drouting", "define_blacklist", 'pstn:list2 = 5,6')
modparam("drouting", "define_blacklist", 'pstn:list3 = 7,8')
...
	</programlisting>
		</example>
	</section>

	<section id="param_default_group" xreflabel="default_group">
		<title><varname>default_group</varname> (int)</title>
		<para>
		Group to be used if the caller (FROM user) is not found in the GROUP
		table.
		</para>
		<para>
		<emphasis>Default value is <quote>NONE</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>default_group</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "default_group", 4)
...
</programlisting>
		</example>
	</section>

	<section id="param_force_dns" xreflabel="force_dns">
		<title><varname>force_dns</varname> (int)</title>
		<para>
		Force DNS resolving of GW/destination names (if not IPs) during
		startup. If not enabled, the GW name will be blindly used during
		routing.
		</para>
		<para>
		<emphasis>Default value is <quote>1 (enabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>force_dns</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "force_dns", 0)
...
	</programlisting>
		</example>
	</section>

	<section id="param_persistent_state" xreflabel="persistent_state">
		<title><varname>persistent_state</varname> (int)</title>
		<para>
		Specifies whether the <emphasis>state</emphasis> column
		should be loaded at startup and flushed during runtime or not.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote> (enabled).
		</emphasis>
		</para>
		<example>
		<title>Set the <varname>persistent_state</varname> parameter</title>
		<programlisting format="linespecific">
...
# disable all DB operations with the state of a gateway
modparam("drouting", "persistent_state", 0)
...
</programlisting>
		</example>
	</section>

	<section id="param_no_concurrent_reload" xreflabel="no_concurrent_reload">
		<title><varname>no_concurrent_reload</varname> (int)</title>
		<para>
			If enabled, the module will not allow do run multiple dr_reload
			MI commands in parallel (with overlapping)  Any new reload will
			be rejected (and discarded) while an existing reload is in
			progress.
			</para>
			<para>
			If you have a large routing set (millions of rules/prefixes), you
			should consider disabling concurrent reload as they will exhaust
			the shared memory (by reloading into memory, in the same time,
			multiple instances of routing data).
			</para>
		<para>
		<emphasis>Default value is <quote>0 (disabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>no_concurrent_reload</varname> parameter</title>
		<programlisting format="linespecific">
...
# do not allow parallel reload operations
modparam("drouting", "no_concurrent_reload", 1)
...
</programlisting>
		</example>
	</section>

	<section id="param_probing_interval" xreflabel="probing_interval">
		<title><varname>probing_interval</varname> (integer)</title>
		<para>
		How often (in seconds) the probing of a destination should be done. If
		set to 0, the probing will be disabled as functionality (for all
		destinations)
		</para>
		<para>
		<emphasis>
			Default value is <quote>30</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_interval</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_interval", 60)
...
</programlisting>
		</example>
	</section>

	<section id="param_probing_method" xreflabel="probing_method">
		<title><varname>probing_method</varname> (string)</title>
		<para>
		The SIP method to be used for the probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"OPTIONS"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_method</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_method", "INFO")
...
</programlisting>
		</example>
	</section>

	<section id="param_probing_from" xreflabel="probing_from">
		<title><varname>probing_from</varname> (string)</title>
		<para>
		The FROM SIP URI to be advertised in the SIP probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"sip:prober@localhost"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_from</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_from", "sip:pinger@192.168.2.10")
...
</programlisting>
		</example>
	</section>

	<section id="param_probing_reply_codes" xreflabel="probing_reply_codes">
		<title><varname>probing_reply_codes</varname> (string)</title>
		<para>
		A comma separted list of SIP reply codes. The codes defined here
		will be considered as valid reply codes for probing messages,
		apart for 200.
		</para>
		<para>
		<emphasis>
			Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_reply_codes</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_reply_codes", "501, 403")
...
</programlisting>
		</example>
	</section>

	<section id="param_probing_socket" xreflabel="probing_socket">
		<title><varname>probing_socket</varname> (string)</title>
		<para>
		A socket description [proto:]host[:port] of the local socket
		(which is used by OpenSIPS for SIP traffic) to be used
		(if multiple) for sending the probing messages from.
		</para>
		<para>
		For probing gateway the highest priority has socket from gateway
		configuration in dr_gateways table. Then socket from global
		<varname>probing_socket</varname> parameter and the lowest
		priority is default behaviour with auto selected socket wich
		OpenSIPS listens on.
		</para>
		<para>
		<emphasis>
			Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_socket</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_socket", "udp:192.168.1.100:5060")
...
</programlisting>
		</example>
	</section>

	<section id="param_gw_socket_filter_mode" xreflabel="gw_socket_filter_mode">
		<title><varname>gw_socket_filter_mode</varname> (string)</title>
		<para>
		This parameter controls the gateway filtering during DB loading, or which
		gateways are loaded or not into memory depending on the configured
		socket they have.
		</para>
		<para>
		The supported filtering modes are:
		</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis role='bold'>"all"</emphasis> - all the gateways
			defined in DB are loaded into memory, disregarding what socket
			value they have. NOTE: for the gw sockets not matching any OpenSIPS
			listeners/sockets, the GW will be loaded with NULL/no socket.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>"ignore"</emphasis> - all the gateways
			defined in DB are loaded into memory, but ignoring the socket
			value they have (the socket will be set to NULL/NONE with no 
			attempt to check it against the OpenSIPS listeners/sockets).
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>"matched-only"</emphasis> - in this mode
			the module will load from DB only the gateways that have a
			configured a socket matching any of the  the OpenSIPS
			listeners/sockets. If the gateways socket does not match, it will
			be discards, not loaded into memory at all.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		<emphasis>
			Default value is <quote>"all"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_socket_filter_mode</varname> parameter</title>
		<programlisting format="linespecific">
...
# multiple OpenSIPS instances sharing a DR setting, so each should
# load only the GWs they have sockets for.
modparam("drouting", "gw_socket_filter_mode", "matched-only")
...
# an OpenSIPs instance not doing routing, but needing to be
# aware of all the gws, so load them all ignoring the sockets
modparam("drouting", "gw_socket_filter_mode", "ignore")
...
</programlisting>
		</example>
	</section>


	<section id="param_cluster_id" xreflabel="cluster_id">
		<title><varname>cluster_id</varname> (integer)</title>
		<para>
		The ID of the cluster the module is part of. The clustering support is 
		used in drouting module for two purposes: for sharing the status of 
		the gateways/carriers and for controlling the pinging to gateways.
		</para>
		<para>
		If clustering enbled, the module will automatically share changes
		over the status of the gateways/destinations/carriers with the other 
		OpenSIPS instances that are part of a cluster. Whenever such a status 
		changes (following an MI command, a probing result, a script command),
		the module will replicate this status change to all the nodes in this 
		given cluster.
		</para>
		<para>
		The clustering with sharing tag support may be used to control which 
		node in the cluster will perform the pinging/probing to 
		gateways. See the
		<xref linkend="param_cluster_sharing_tag"/> option.
		</para>
		<para>
		For more info on how to define and populate a cluster (with OpenSIPS 
		nodes) see the "clusterer" module.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0 (none)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>cluster_id</varname> parameter</title>
		<programlisting format="linespecific">
...
# replicate gw/carrier status with all OpenSIPS in cluster ID 9
modparam("drouting", "cluster_id", 9)
...
</programlisting>
		</example>
	</section>

	<section id="param_cluster_sharing_tag" xreflabel="cluster_sharing_tag">
		<title><varname>cluster_sharing_tag</varname> (string)</title>
		<para>
		The name of the sharing tag (as defined per clusterer modules) to 
		control which node is responsible for perform the self-triggered
		actions in the module. Such actions may be the gateway probing (see
		also the <xref linkend="param_cluster_probing_mode"/> parameter)  or
		sharing the gateway/carrier status changes.
		If defined, only the node with active status of this tag will 
		perform the actions (pinging and sharing status).
		</para>
		<para>
		The <xref linkend="param_cluster_id"/> must be defined for this option
		to work.
		</para>
		<para>
		This is an optional parameter. If not set, all the nodes in the cluster
		will share the status changes.
		</para>
		<para>
		<emphasis>
			Default value is <quote>empty (none)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>cluster_sharing_tag</varname> parameter</title>
		<programlisting format="linespecific">
...
# only the node with the active "vip" sharing tag will perform pinging
# and broadcast the status changes
modparam("drouting", "cluster_id", 9)
modparam("drouting", "cluster_sharing_tag", "vip")
...
</programlisting>
		</example>
	</section>

	<section id="param_cluster_probing_mode" xreflabel="cluster_probing_mode">
		<title><varname>cluster_probing_mode</varname> (string)</title>
		<para>
		This paramter controls how the probing/pinging should be done when
		using the clustering support. It is about which node in the cluster
		pings which gateway/destination.
		</para>
		<para>
		The <xref linkend="param_cluster_id"/> must be defined for this option
		to work.
		</para>
		<para>
		The supported probing modes are:
		</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis role='bold'>"all"</emphasis> - all the nodes in the
			cluster will independetly ping all the defined gateways,
			an "all" pings "all" mode.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>"by-shtag"</emphasis> - all the gateways
			are pinged by only one node in the cluster, the node having the
			<xref linkend="param_cluster_sharing_tag"/> active. By 
			activating the sharing tag on a different node, the pinging
			duty will be transfered to another node in the cluster.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>"distributed"</emphasis> - the pinging
			effort is distributed across all the nodes in the cluster, so each
			node will ping a sub-set of the overall set of gateway. Still all
			the gateways will get pinged (and only once per pinging cycle).
			The re-partitioning of the pinging effort over the available nodes
			in the cluster is automatically done when new nodes are joining or
			nodes are dropping out. Still there is no guaratee on which node
			will be responsible for pinging which gateway.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		<emphasis>
			Default value is <quote>"all"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>cluster_probing_mode</varname> parameter</title>
		<programlisting format="linespecific">
...
# only the node with the active "vip" sharing tag will perform pinging
modparam("drouting", "cluster_id", 9)
modparam("drouting", "cluster_sharing_tag", "vip")
modparam("drouting", "cluster_probing_mode", "by-shtag")
...
# the pinging effort is distributed across all the nodes
modparam("drouting", "cluster_id", 9)
modparam("drouting", "cluster_probing_mode", "distributed")
...
</programlisting>
		</example>
	</section>


	<section id="param_use_domain" xreflabel="use_domain">
		<title><varname>use_domain</varname> (int)</title>
		<para>
			Flag to configure whether to use domain match when querying
			database for user's routing group.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>use_domain</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "use_domain", 0)
...
</programlisting>
		</example>
	</section>

	<section id="param_drg_user_col" xreflabel="drg_user_col">
		<title><varname>drg_user_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the username is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>username</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_user_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_user_col", "user")
...
</programlisting>
		</example>
	</section>

	<section id="param_drg_domain_col" xreflabel="drg_domain_col">
		<title><varname>drg_domain_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the domain is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>domain</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_domain_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_domain_col", "host")
...
</programlisting>
		</example>
	</section>

	<section id="param_drg_grpid_col" xreflabel="drg_grpid_col">
		<title><varname>drg_grpid_col</varname> (str)</title>
		<para>
			The name of the column in group db table where the
			group id is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>groupid</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_grpid_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_grpid_col", "grpid")
...
</programlisting>
		</example>
	</section>


	<section id="param_use_partitions" xreflabel="use_partitions">
		<title><varname>use_partitions</varname> (int)</title>
		<para>
		Flag to configure whether to use partitions for routing. If this
		flag is set then the <varname>db_partitions_url</varname> and
		<varname>db_partitions_table</varname>
		variables become mandatory.
		</para>
		<para>
		<emphasis>Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>use_partitions</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "use_partitions", 1)
...
</programlisting>
		</example>
	</section>

<section id="param_db_partitions_url" xreflabel="db_partitions_url">
		<title><varname>db_partitions_url</varname> (str)</title>
		<para>
		The url to the database containing partition-specific
		information. (partition-specific information includes
		partition name, url to the database where information about
		the partition is preserved, the names of the tables in which it
		is preserved and the AVPs that can be accessed using the .cfg
		script). The <varname>use_partitions</varname> parameter
	    must be set to 1.
		</para>
		<para>
		<emphasis>Default value is <quote>"NULL"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_partitions_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_partitions_url", "mysql://user:password@localhost/opensips_partitions")
...
</programlisting>
		</example>
	</section>

	<section id="param_db_partitions_table" xreflabel="db_partitions_table">
		<title><varname>db_partitions_table</varname> (str)</title>
		<para>
		The name of the table containing partition definitions. To be
		used with <varname>use_partitions</varname> and <varname>db_partitions_url</varname>.
		</para>
		<para>
		<emphasis>Default value is <quote>dr_partitions</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_partitions_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_partitions_table", "partition_defs")
...
</programlisting>
		</example>
	</section>

	<section id="param_partition_id_pvar" xreflabel="partition_id_pvar">
		<title><varname>partition_id_pvar</varname> (pvar)</title>
		<para>
			Variable which will store the name of the name partition when
			<emphasis>wildcard(*)</emphasis> operatior is used.
			<emphasis>Use_partitions</emphasis> must be set in order to
			use this parameter.
		</para>
		<para>
			NOTE: The variable must be WRITABLE!
		</para>
		<para>
		<emphasis>Default value is <quote>null(not used)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>partition_id_pvar</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "partition_id_pvar", "$var(matched_partition)")
...
</programlisting>
		</example>
	</section>

	<section id="param_enable_restart_persistency" xreflabel="enable_restart_persistency">
		<title><varname>enable_restart_persistency</varname> (int)</title>
		<para>
			Parameter set to enable restart persistency for the Dynamic Routing module.
			When this parameter is set, the drouting module no longer loads the data
			from the database after restart, but uses the persistent storage file, and loads
			data from it <quote>on demand</quote>, improving the startup performance.
		</para>
		<para>
			NOTE: If the restart persistent cache is not populated from a previous run,
			then the data will be loaded from database at startup!
		</para>
		<para>
			NOTE: A reload will update the cached data.
		</para>
		<para>
		<emphasis>Default value is <quote>0 (disabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>enable_restart_persistency</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "enable_restart_persistency", yes)
...
</programlisting>
		</example>
	</section>

	<section id="param_extra_prefix_chars" xreflabel="extra_prefix_chars">
		<title><varname>extra_prefix_chars</varname> (str)</title>
		<para>
			List of ASCII (0-127) characters to be additionally accepted in
			the prefixes. By default only '0' - '9' chars (digits) are
			accepted.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>extra_prefix_chars</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "extra_prefix_chars", "#-%")
...
</programlisting>
		</example>
	</section>

	<section id="param_extra_id_chars" xreflabel="extra_id_chars">
		<title><varname>extra_id_chars</varname> (str)</title>
		<para>
			A set of extra characters to be allowed in both Gateway and Carrier
			unique string identifiers, on top of alphanumeric characters.
		</para>
		<para>
		<emphasis>Default value is <quote>_-.</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>extra_id_chars</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "extra_id_chars", ":_-.")
...
</programlisting>
		</example>
	</section>

	<section id="param_rule_tables_query" xreflabel="rule_tables_query">
		<title><varname>rule_tables_query</varname> (str)</title>
		<para>
			This parameter offers a dynamic, SQL-based way of building a set of
			<emphasis>dr_rules</emphasis>-compatible table names, to be
			each loaded and then merged into a single "dr_rules" table,
			for any given partition.
		</para>
		<para>
			The syntax of the parameter is:
			"<emphasis role='bold'>token</emphasis> : <emphasis role='bold'>query</emphasis>",
			where <emphasis role='bold'>token</emphasis> is a special name
			given to a "dr_rules" table, so OpenSIPS can match it against
			the custom queries defined using this parameter.
		</para>
		<para>
			This parameter may be set multiple times (each definition creates
			a new mapping).
		</para>
		<example>
		<title>Set the <varname>rule_tables_query</varname> parameter</title>
		<programlisting format="linespecific">
...
# first, set the "dr_rules" table name to the name of your query
modparam("drouting", "drr_table", "MY_RULES_QUERY")

# next, instruct drouting to load both 'dr_rules_a' and 'dr_rules_b',
# then merge all of their rules
modparam("drouting", "rule_tables_query", "
	MY_RULES_QUERY:
		SELECT 'dr_rules_a' UNION SELECT 'dr_rules_b'")
...
</programlisting>
		</example>
	</section>

</section>

<section id="exported_functions" xreflabel="exported_functions">
	<title>Exported Functions</title>
	<section id="func_do_routing" xreflabel="do_routing()">
		<title>
		<function moreinfo="none">do_routing([groupID], [flags], [gw_whitelist], [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar], [partition])</function>
		</title>
		<para>
		Function to trigger routing of the message according to the
		rules in the database table and the configured parameters.
		</para>
		<para>
		This function can be used from all routes.
		</para>
		<para>
		If you set <varname>use_partitions</varname> to 1 the 
		<emphasis role='bold'>partition</emphasis> last parameter becomes 
		mandatory.
		</para>
		<para>
		All parameters are optional. Any of them may be ignored, provided
		the necessary separation marks "," are properly placed.
		</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis role='bold'>groupID</emphasis> (int, optional) - number to 
			specify the group of the caller for routing purposes.
			If none specified the function will automatically try to query
			the dr_group table to get this 
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>flags</emphasis> (string, optional) - a list
			of letter-like flags for controlling the routing behavior.
			Possible flags are:
			</para>
			<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>F</emphasis> - Enable rule fallback; 
				normally the engine is using a single rule for routing a call;
				by setting this flag, the engine will fallback and use
				rules with less priority or shorter prefix when all the
				destination from the current rules failed.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>L</emphasis> - Do strict length matching
				over the prefix - actually DR engine will do full number 
				matching and not prefix matching anymore.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>C</emphasis> - Only check if the dialed
				number matches any routing rule, without loading / applying any
				routing info (no GW is set, the RURI is not altered)
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>gw_whitelist</emphasis> (string, optional) - a
			comma separated white list of gateways. This will force routing over,
			at most, this list of carriers or gateways (in other words, 
			the whitelist will be intersected with the results of the search 
			through the rules).
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>rule_attrs_pvar</emphasis> (var, optional) - a
			writable variable which will be  populated with the attributes of the
			matched dynamic routing rule.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) - a
			writable variable which will be 
			populated with the attributes of the matched gateway.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>carrier_attrs_pvar </emphasis> (var, optional) - a
			a writable variable which will be
			populated with the attributes of the matched carrier.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>partition</emphasis> (string, optional) - the name
			of the DR partition to be used. This parameter is to be defined
			ONLY if the "use_partition" module parameter is turned on.
			Besides specifing the name of one partition, you can use the "*" 
			wildcard sign to force routing over all partitions.
			</para>
		</listitem>

		</itemizedlist>

		<example>
		<title><function>do_routing</function> usage</title>
		<programlisting format="linespecific">
...
# all groups, sort on order, <varname>use_partitions</varname> is 0
do_routing();
...
# all groups, sort on order, <varname>use_partitions</varname> is 1, route by partition named "part"
do_routing( , , , , , ,"part");
...
# group id 0, sort on order, <varname>use_partitions</varname> is 0
do_routing(0);
...
# group id 0, sort on order, <varname>use_partitions</varname> is 1, route by partition named "part"
do_routing(0, , , , , , "part");
...
# group id from $var(id), sort on order, <varname>use_partitions</varname> is 0
do_routing($var(id));
...
# all groups, sort on weights, <varname>use_partitions</varname> is 0
do_routing(, "W");
...
# <varname>use_partitions</varname> is 1, partition and group supplied by AVPs, do strict length matching
do_routing( $avp(grp),"L", , , , ,$avp(partition))
...
# group id 2, sort on order, fallback rule and also return the gateway attributes
do_routing(2, "F", , , $var(gw_attributes));
...
</programlisting>
		</example>
	</section>

	<section id="func_route_to_carrier" xreflabel="route_to_carrier()">
		<title>
		<function moreinfo="none">route_to_carrier( carriers, [gw_attrs_pvar], [carrier_attrs_pvar], [partition])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given set carriers (one 
		or more). So, the routing is not done prefix based, but carrier based 
		(call will be sent to the GWs of that carrier, based on carrier 
		policy).
		</para>
		<para>
		This function can be used from all routes.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter also (where the carrier are to be
		found).
		</para>
		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>carriers</emphasis> (string) - comma separated
					carrier IDs (names)
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) -
					an output writable variable which will be populated
					with the attributes of the currently matched gateway of 
					this carrier.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (var, 
					optional) - an output writable variable which will be populated 
					with the attributes of this carrier.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (string, optional) -
					the name of the DR partition to be used. This parameter is
					to be defined ONLY if the "use_partition" module parameter
					is turned on. Wildcard sign is not accepted by the 
					function.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_carrier</function> usage</title>
		<programlisting format="linespecific">
...
# use_partitions is not set
if ( route_to_carrier("my_top_carrier, def_carrier", , $var(carrier_att)) ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
# use_partitions is enabled
if ( route_to_carrier("my_top_carrier", , $var(carrier_att), "part") ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
# use_partitions is enabled
if ( route_to_carrier($var(carrierId), , , $var(my_partition)) ) {
	xlog("Routing to \"my_top_carrier\"\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section id="func_route_to_gw" xreflabel="route_to_gw()">
		<title>
		<function moreinfo="none">route_to_gw(gw_id, [gw_attrs_var], [carrier_attrs_var], [partition])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given gateway (or list of
		gateways). Attributes and per-gw processing will be available.
		</para>
		<para>
		This function can be used from all routes.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>gw_id </emphasis> (string) - comma
					separated list of gateway IDs to be used.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis>  (var, optional)
					- an output writable variable which will be populated
					with the attributes of the currently matched gateway.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (var, 
					optional) - an output writable variable which will be 
					populated with the attributes of this carrier. NOTE: the
					first carrier pointing to the GW(s) will be considered!
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (string, optional) -
					the name of the DR partition to be used. This parameter is
					to be defined ONLY if the "use_partition" module parameter
					is turned on. Wildcard sign is not accepted by the 
					function.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_gw</function> usage</title>
		<programlisting format="linespecific">
...
# use_partitions is not set
if ( route_to_gw("gw_europe") ) {
	t_relay();
	exit;
}
...
# use_partitions is not set
if ( route_to_gw("gw1,gw2,gw3", $var(gw_attrs)) ) {
	xlog("Relaying to first gateway from our list - $var(gw_attrs)\n");
	t_relay();
	exit;
}
...
# use_partitions is enabled
if ( route_to_gw("gw_europe", , , "my_partition") ) {
	t_relay();
	exit;
}
...
# use_partitions is enabled
if ( route_to_gw("gw1,gw2,gw3", $var(gw_attrs), , "my_partition") ) {
	xlog("Relaying to first gateway from our list - $var(gw_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section id="func_use_next_gw" xreflabel="use_next_gw()">
		<title>
		<function moreinfo="none">use_next_gw( [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar], [partition])</function>
		</title>
		<para>
		The function takes the next available destination (set by do_routing,
		as alternative destinations) and pushes it into the RURI. Note that the
		function just sets the RURI (nothing more).
		</para>
		<para>
		If a new RURI is set, the used destination is removed from the
		pending set of alternative destinations.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		The function returns true only if a new RURI was set. False
		is returned is no other alternative destinations are found or in case
		of an internal processing error. It may take the following optional 
		parameters:
		</para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>rule_attrs_pvar </emphasis> (var, optional)
					- an output writable variable which will be populated
					with the attributes of the matched dynamic routing rule.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) - an
					output writable variable which will be populated
					with the attributes of the matched gateway.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (var, optional) 
					- an output writable variable which will be populated
					with the attributes of the matched carrier.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (optinal, string) -
					the name of the DR partition to be used. This parameter is
					to be defined ONLY if the "use_partition" module parameter
					is turned on. Wildcard sign is not accepted by the 
					function.
					</para>
				</listitem>
		</itemizedlist>
		<example>
		<title><function>use_next_gw</function> usage</title>
		<programlisting format="linespecific">
...
# use_partitions is not set
if (use_next_gw()) {
	t_relay();
	exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw(, , $var(carrier_attrs))) {
	xlog("Carrier attributes of current gateway: $var(carrier_attrs)\n");
	t_relay();
	exit;
}
...
# use_partitions is enabled
if (use_next_gw( , , ,"my_partition")) {
	t_relay();
	exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw( , ,$var(carrier_attrs), "my_partition")) {
	xlog("Carrier attributes of current gateway: $var(carrier_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section id="func_goes_to_gw" xreflabel="goes_to_gw()">
		<title>
		<function moreinfo="none">goes_to_gw( [type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar], [partition])</function>
		</title>
		<para>
		Function returns true if the destination of the current request
		(destination URI or Request URI) points (as IP) to one of the gateways.
		There no DNS lookups done if the domain part of the URI is not an IP.
		</para>
		<para>
		This function does not change anything in the message.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE, ONREPLY_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		It may take the following optional parameters:
		</para>
		<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>type</emphasis> (int, optional) - number for
				the GW/destination type to be checked; when omitting this 
				parameter or specifying the special value <emphasis>-1</emphasis>, matching will 
				be done against all types. 
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>flags</emphasis> (string, optional) - 
				letter like flags for controlling what operations should be 
				performed when a GW matches:
				</para>
				<itemizedlist>
					<listitem>
						<para>
						<emphasis role='bold'>'s'</emphasis> (Strip) - apply
						to the username of RURI the strip defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'p'</emphasis> (Prefix) - apply
						to the username of RURI the prefix defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'i'</emphasis> (Gateway ID) - 
						return the gateway id into gw_id_avp AVP
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'n'</emphasis> (Ignore port) -
						ignores port number during matching
							</para>
						</listitem>
						<listitem>
						<para>
						<emphasis role='bold'>'c'</emphasis> (Carrier ID) - 
						return the carrier id into carrier_id_avp AVP
						</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) -
				an  output writable variable which will be populated with
				the attributes of the matched gateway.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>carrier_attrs_pvar</emphasis> (var, optional) - an 
				output writable variable which will be populated with
				the attributes of the matched carrier.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>partition</emphasis> (string, optional) - 
				the name of the DR partition to be used. This parameter is
				to be defined ONLY if the "use_partition" module parameter
				is turned on. Wildcard sign is accepted by this 
				function.
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>goes_to_gw</function> usage</title>
		<programlisting format="linespecific">
...
# use_partitions is not set
if (goes_to_gw( 1, , $var(gw_attrs))) {
	sl_send_reply(403,"Forbidden");
	exit;
}
...
# use_partitions is enabledt
if (goes_to_gw(1, , $var(gw_attrs), , "my_partition")) {
	sl_send_reply(403,"Forbidden");
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section id="func_is_from_gw" xreflabel="is_from_gw()">
		<title>
		<function moreinfo="none">is_from_gw([type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar],  [partition])</function>
		</title>
		<para>
		The function checks if the sender of the message (source IP + source
		port) is a gateway from a certain group.
		</para>
		<para>
		This function does not change anything in the message.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE and ONREPLY_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		It may take the following optional parameters:
		</para>
		<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>type</emphasis> (int, optional) - number for
				the GW/destination type to be checked; when omitting this 
				parameter or specifying the special value <emphasis>-1</emphasis>, matching will 
				be done against all types. 
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>flags</emphasis> (string, optional) - 
				letter like flags for controlling what operations should be 
				performed when a GW matches:
				</para>
				<itemizedlist>
					<listitem>
						<para>
						<emphasis role='bold'>'s'</emphasis> (Strip) - apply
						to the username of RURI the strip defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'p'</emphasis> (Prefix) - apply
						to the username of RURI the prefix defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'i'</emphasis> (Gateway ID) - 
						return the gateway id into gw_id_avp AVP
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'n'</emphasis> (Ignore port) -
						ignores port number during matching
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'r'</emphasis> (Check protocol) - check protocol
						</para>
					</listitem>
					<listitem>
					<para>
					<emphasis role='bold'>'c'</emphasis> (Carrier ID) - 
					return the carrier id into carrier_id_avp AVP
					</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) - an 
				output writable variable which will be populated with
				the attributes of the matched gateway.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>carrier_attrs_pvar</emphasis> (var, optional) - an 
				output writable variable which will be populated with
				the attributes of the matched carrier.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>partition</emphasis> (string, optional) - 
				the name of the DR partition to be used. This parameter is
				to be defined ONLY if the "use_partition" module parameter
				is turned on. Wildcard sign is accepted by this 
				function.
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>is_from_gw</function> usage</title>
		<programlisting format="linespecific">
# use_partitions is not set
# match the source IP (only) against all gateways
if (is_from_gw(-1, "n")) {
	...
}

# use_partitions is enabled
# match the source IP and port against all gateways from the "outbound"
# partition and return the matched gateway's carrier
if (is_from_gw(, "c", , , "outbound")) {
	...
}
</programlisting>
		</example>
	</section>

	<section id="func_dr_is_gw" xreflabel="dr_is_gw()">
		<title>
		<function moreinfo="none">dr_is_gw( sip_uri, [type], [flags], [gw_attrs_pvar], [carrier_attrs_pvar], [partition])</function>
		</title>
		<para>
		The function checks if the SIP URI hostname part stored inside the
		"src_pv" pseudo-variable is a gateway from a certain group.
		</para>
		<para>
		This function does not change anything in the message.
		</para>
		<para>
		This function can be used from all routes.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		It may take the following optional parameters:
		</para>
		<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>sip_uri</emphasis> (string) - SIP URI.
				If the URI hostname part is a FQDN,
				it will be resolved prior to matching.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>type</emphasis> (int, optional) - number for
				the GW/destination type to be checked; when omitting this 
				parameter or specifying the special value <emphasis>-1</emphasis>, matching will 
				be done against all types. 
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>flags</emphasis> (string, optional) - 
				letter like flags for controlling what operations should be 
				performed when a GW matches:
				</para>
				<itemizedlist>
					<listitem>
						<para>
						<emphasis role='bold'>'s'</emphasis> (Strip) - apply
						to the username of RURI the strip defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'p'</emphasis> (Prefix) - apply
						to the username of RURI the prefix defined by the GW
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'i'</emphasis> (Gateway ID) - 
						return the gateway id into gw_id_avp AVP
						</para>
					</listitem>
					<listitem>
						<para>
						<emphasis role='bold'>'n'</emphasis> (Ignore port) -
						ignores port number during matching
							</para>
						</listitem>
						<listitem>
						<para>
						<emphasis role='bold'>'c'</emphasis> (Carrier ID) - 
						return the carrier id into carrier_id_avp AVP
						</para>
					</listitem>
				</itemizedlist>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>gw_attrs_pvar</emphasis> (var, optional) - an  
				output writable variable which will be populated with
				the attributes of the matched gateway.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>carrier_attrs_pvar</emphasis> (var, optional) - an 
				output writable variable which will be populated with
				the attributes of the matched carrier.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>partition</emphasis> (string, optional) - 
				the name of the DR partition to be used. This parameter is
				to be defined ONLY if the "use_partition" module parameter
				is turned on. Wildcard sign is accepted by this 
				function.
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>dr_is_gw</function> usage</title>
		<programlisting format="linespecific">
# match the SIP URI host within $var(uac) against all gateways
if (dr_is_gw( $var(uac), , "n")) {
	...
}


# match the SIP URI host within $var(uac) against
# all gws in "outbound" partition
if (dr_is_gw( $avp(uac), , "n", , , "partition")) {
	...
}
</programlisting>
		</example>
	</section>

	<section id="func_dr_disable" xreflabel="dr_disable()">
		<title>
		<function moreinfo="none">dr_disable([partition])</function>
		</title>
		<para>
		Marks as disabled the last destination that was used for the current
		call. The disabling done via this function will prevent the
		destination to be used for usage from now on. The probing mechanism
		can re-enable this peer (see the probing section in the beginning)
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE, ONREPLY_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must 
		supply the "partition" parameter to instruct on the partition where the
		gateway has been defined.
		</para>
		<para>
		It may take the following parameters:
		</para>
		<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>partition</emphasis> (string, optional) - 
				the name of the DR partition to be used. This parameter is
				to be defined ONLY if the "use_partition" module parameter
				is turned on. Wildcard sign is accepted by this 
				function.
				</para>
			</listitem>
		</itemizedlist>

		<example>
		<title><function>dr_disable()</function> usage</title>
		<programlisting format="linespecific">
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
	dr_disable();

}
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
	dr_disable("my_partition");

}
...
</programlisting>
		</example>
	</section>


	<section id="func_dr_match" xreflabel="dr_match()">
		<title>
		<function moreinfo="none">dr_match(groupID, [flags], number, [rule_attrs_pvar], [partition])</function>
		</title>
		<para>
		The function tries to match/check the given number against the
		rules from the database.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE, ONREPLY_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> to 1 the 
		<emphasis role='bold'>partition</emphasis> last parameter becomes 
		mandatory.
		</para>
		<para>
		The parameters are:
		</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis role='bold'>groupID</emphasis> (int) - number to 
			specify the dr group (set of rules) to perform the check against 
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>flags</emphasis> (string, optional) - a list
			of letter-like flags for controlling the checking/matching behavior.
			Possible flags are:
			</para>
			<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>L</emphasis> - Do strict length matching
				over the prefix - actually DR engine will do full number 
				matching and not prefix matching anymore.
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>number</emphasis> (string) - the number to check
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>rule_attrs_pvar</emphasis> (var, optional) - a
			writable variable which will be  populated with the attributes of the
			matched dynamic routing rule.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>partition</emphasis> (string, optional) - the name
			of the DR partition to be used. This parameter is to be defined
			ONLY if the "use_partition" module parameter is turned on.
			</para>
		</listitem>

		</itemizedlist>

		<example>
		<title><function>dr_match</function> usage</title>
		<programlisting format="linespecific">
...
if ( dr_match( 1, "L" , $fU, ,"dids") )
	xlog("Full From Username $fU found in group 1 partition DIDS\n");
...
if ( dr_match( 1, , $var(did) ) )
	xlog("DID $var(did) matches rules in group 1\n");
...
</programlisting>
		</example>
	</section>


</section>


<section id="exported_mi_functions" xreflabel="Exported MI Functions">
	<title>Exported MI Functions</title>
	<section id="mi_dr_reload" xreflabel="dr_reload">
		<title>
		<function moreinfo="none">dr_reload</function>
		</title>
		<para>
		Command to reload routing rules from database.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 - all routing rules will be reloaded.

					<itemizedlist>
						<listitem><para>
							<emphasis>inherit_state</emphasis> (optional) : whether inherit old state of the gateway , default is y.
							<itemizedlist>
								<listitem><para> <quote>n</quote>: no inherit state </para></listitem>
								<listitem><para> <quote>y</quote>: inherit state </para></listitem>
							</itemizedlist>
						</para></listitem>
					</itemizedlist>
					
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1, the parameters are:
					<itemizedlist>
						<listitem><para>
							<emphasis>partition_name</emphasis> (optional) - if not provided
							all the partitions will be reloaded, otherwise just the partition given as parameter will be reloaded.
						</para></listitem>
					</itemizedlist>

					<listitem><para>
							<emphasis>inherit_state</emphasis> (optional) : whether inherit old state of the gateway , default is y.
							<itemizedlist>
								<listitem><para> <quote>n</quote>: no inherit state </para></listitem>
								<listitem><para> <quote>y</quote>: inherit state </para></listitem>
							</itemizedlist>
					</para></listitem>

				</para>
			</listitem>
		</itemizedlist>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		opensips-cli -x mi dr_reload part_1
		</programlisting>
	</section>

	<section>
		<title><varname>dr_gw_status</varname></title>
		<para>
		Gets the status (enabled or disabled) of one or multiple gateways. The function
		can also be used to set the status of a single gateway.
		<itemizedlist>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 0, the parameters are:
				<itemizedlist>
					<listitem><para><emphasis>gw_id</emphasis> (optional) - the id of
					a gateway. If provided, the function will return/set (depnding if the second
					parameter is given) the status of that gateway, otherwise it will list all
					gateways along with their statuses.
					</para></listitem>
					<listitem><para><emphasis>status</emphasis> (optional) - the new status
					to be forced for a GW (0 - disable, 1 - enable). Only makes sense if
					<emphasis>gw_id</emphasis> is provided.
					</para></listitem>
				</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 1, the parameters are:
				<itemizedlist>
					<listitem><para><emphasis>partition_name</emphasis>
					</para></listitem>
					<listitem><para><emphasis>gw_id</emphasis> (optional) - the id of
					a gateway. If provided, the function will return/set (depnding if the third
					parameter is given) the status of that gateway, otherwise it will list all
					gateways in the given partition along with their statuses.
					</para></listitem>
					<listitem><para><emphasis>status</emphasis> (optional) - the new status
					to be forced for a GW (0 - disable, 1 - enable). Only makes sense if
					<emphasis>gw_id</emphasis> is provided.
					</para></listitem>
				</itemizedlist>
				</para>
			</listitem>
		</itemizedlist>
		</para>
		<example>
		<title><function>dr_gw_status</function> usage when <varname>use_partitions</varname> is set to 0</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_gw_status gw_id=2
State:: Active
$ opensips-cli -x mi dr_gw_status gw_id=2 status=0
$ opensips-cli -x mi dr_gw_status gw_id=2
Enabled:: Disabled MI
$ opensips-cli -x mi dr_gw_status gw_id=3
Enabled:: Inactive
</programlisting>
		</example>

		<example>
		<title><function>dr_gw_status</function> usage when <varname>use_partitions</varname>is set to 1</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_gw_status partition_name=part_1 gw_id=my_gw
State:: Active
$ opensips-cli -x mi dr_gw_status partition_name=part_1 gw_id=my_gw status=0
$ opensips-cli -x mi dr_gw_status partition_name=part_1 gw_id=my_gw
enabled:: disabled mi
$ opensips-cli -x mi dr_gw_status partition_name=partition8 status=3
enabled:: inactive
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_carrier_status</varname></title>
		<para>
		Gets the status (enabled or disabled) of one or multiple carriers. The function
		can also be used to set the status of a single carrier.
		</para>
		<itemizedlist>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 0, the parameters are:
				<itemizedlist>
					<listitem><para><emphasis>carrier_id</emphasis> (optional) - the id of
					a carrier. If provided, the function will return/set (depnding if the second
					parameter is given) the status of that carrier, otherwise it will list all
					carriers along with their statuses.
					</para></listitem>
					<listitem><para><emphasis>status</emphasis> (optional) - the new status
					to be forced for a carrier (0 - disable, 1 - enable). Only makes sense if
					<emphasis>carrier_id</emphasis> is provided.
					</para></listitem>
				</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 1, the parameters are:
				<itemizedlist>
					<listitem><para><emphasis>partition_name</emphasis>
					</para></listitem>
					<listitem><para><emphasis>carrier_id</emphasis> (optional) - the id of
					a carrier. If provided, the function will return/set (depnding if the third
					parameter is given) the status of that carrier, otherwise it will list all
					carriers contained in the given partition along with their statuses.
					</para></listitem>
					<listitem><para><emphasis>status</emphasis> (optional) - the new status
					to be forced for a carrier (0 - disable, 1 - enable). Only makes sense if
					<emphasis>carrier_id</emphasis> is provided.
					</para></listitem>
				</itemizedlist>
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>dr_carrier_status</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_carrier_status carrier_id=CR1
Enabled:: no
$ opensips-cli -x mi dr_carrier_status carrier_id=CR1 status=1
$ opensips-cli -x mi dr_carrier_status carrier_id=CR1
Enabled:: yes
</programlisting>
		</example>
		<example>
		<title><function>dr_carrier_status</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_carrier_status partition_name=my_partition carrier_id=CR1
Enabled:: no
$ opensips-cli -x mi dr_carrier_status partition_name=partition_1 carrier_id=CR1 status=1
$ opensips-cli -x mi dr_carrier_status partition_name=partition_3 carrier_id=CR1
Enabled:: yes
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_reload_status</varname></title>
		<para>
			Gets the time of the last reload for any partition.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 - the function
					doesn't receive any parameter. It will list the date of the
					last reload for the default (and only) partition.
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1, the parameters are:
					<itemizedlist>
						<listitem><para>
							<emphasis>partition_name</emphasis> (optional) - if not provided
							the function will list the time of the last update for every
							partition. Otherwise, the function will list the time of the last
							reload for the given partition.
						</para></listitem>
					</itemizedlist>
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>dr_reload_status</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_reload_status
Date:: Tue Aug 12 12:26:00 2014
</programlisting>
		</example>
		<example>
		<title><function>dr_reload_status</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
$ opensips-cli -x mi dr_reload_status
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
Partition:: part_2 Date=Tue Aug 12 12:24:13 2014
$ opensips-cli -x mi dr_reload_status part_test
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_number_routing</varname></title>
		<para>
			Gets the matched prefix along with the list of the gateways / carriers to which a number
			would be routed when using the do_routing function.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1 the function
					will have 3 parameters:
					<itemizedlist>
						<listitem>
							<para><emphasis>partition_name</emphasis></para>
						</listitem>
						<listitem>
							<para><emphasis>group_id</emphasis> (optional) - the group id of the rules to
								check against </para>
						</listitem>
						<listitem>
							<para><emphasis>number</emphasis> - the number to test against</para>
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 the function will have 2 parameters:
					<itemizedlist>
						<listitem><para>
							<emphasis>group_id</emphasis> (optional) - the group id of the rules to check against
						</para></listitem>
						<listitem><para>
							<emphasis>number</emphasis> - the number to test against
						</para></listitem>
					</itemizedlist>
				</para>
			</listitem>
		</itemizedlist>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		opensips-cli -x mi dr_number_routing partition_name=part1 group_id=3 number=012340987
		</programlisting>
	</section>

	<section>
		<title>
		<function moreinfo="none">dr_enable_probing</function>
		</title>
		<para>
		Enables/disables gateway probing or returns the current gateway
		probing status.
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>
				<emphasis>status</emphasis> (optional) - 1 - enable,
				0 - disable gateway probing</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>dr_enable_probing</function> usage</title>
		<programlisting  format="linespecific">
$ opensips-cli -x mi dr_enable_probing
Status:: 1
$ opensips-cli -x mi dr_enable_probing 0
$ opensips-cli -x mi dr_enable_probing
Status:: 0
		</programlisting>
		</example>
	</section>

</section>

<section id="exported_events" xreflabel="Exported Events">
	<title>Exported Events</title>
	<section id="event_E_DROUTING_STATUS" xreflabel="E_DROUTING_STATUS">
		<title>
		<function moreinfo="none">E_DROUTING_STATUS</function>
		</title>
		<para>
			This event is raised when the module changes the state of a gateway,
			either through an MI command, probing or script function.
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>
				<emphasis>partition</emphasis> - the name of the partition.
			</para></listitem>
			<listitem><para>
				<emphasis>gwid</emphasis> - the gateway identifier.
			</para></listitem>
			<listitem><para>
				<emphasis>address</emphasis> - the address of the gateway.
			</para></listitem>
			<listitem><para>
				<emphasis>status</emphasis> - <emphasis>disabled MI</emphasis> if
				the gateway was disabled using MI commands,
				<emphasis>probing</emphasis> if the gateway is being pinged,
				<emphasis>inactive</emphasis> if it was disabled from the script or
				<emphasis>active</emphasis> if the gateway is enabled.
			</para></listitem>
		</itemizedlist>
	</section>
</section>


<section id="sr_identifiers" xreflabel="Status/Report Identifiers">
	<title>Exported Status/Report Identifiers</title>

	<para>
	The module provides the "drouting" Status/Report group, where each
	routing partition is defined as a separate SR identifier.
	</para>
	<section id="sr_id_partition_name" xreflabel="partition_name">
	<title><varname>[partition_name]</varname></title>
	<para>
	The status of these identifiers reflects the readiness/status of the 
	cached data (if available or not when being loaded from DB):
	</para>
	<itemizedlist>
		<listitem><para>
		<emphasis>-2</emphasis> - no data at all (initial status)
		</para></listitem>
		<listitem><para>
		<emphasis>-1</emphasis> - no data, initial loading in progress
		</para></listitem>
		<listitem><para>
		<emphasis>1</emphasis> - data loaded, partition ready
		</para></listitem>
		<listitem><para>
		<emphasis>2</emphasis> - data available, a reload in progress
		</para></listitem>
	</itemizedlist>

	<para>
	Reload reporting:
	</para>
	<para>
	In terms of data reloading, the following logs will be reported:
	</para>
	<itemizedlist>
		<listitem><para>
		starting DB data loading
		</para></listitem>
		<listitem><para>
		DB data loading failed, discarding
		</para></listitem>
		<listitem><para>
		DB data loading successfully completed
		</para></listitem>
		<listitem><para>
		N gateways loaded (N discarded), N carriers loaded (N discarded), N rules loaded (N discarded)
		</para></listitem>
	</itemizedlist>
	<programlisting  format="linespecific">
    {
        "Name": "Default",
        "Reports": [
            {
                "Timestamp": 1652353940,
                "Date": "Thu May 12 14:12:20 2022",
                "Log": "starting DB data loading"
            },
            {
                "Timestamp": 1652353940,
                "Date": "Thu May 12 14:12:20 2022",
                "Log": "DB data loading successfully completed"
            },
            {
                "Timestamp": 1652353940,
                "Date": "Thu May 12 14:12:20 2022",
                "Log": "2 gateways loaded (0 discarded), 2 carriers loaded (0 discarded), 1 rules loaded (0 discarded)"
            }
        ]
    }
	</programlisting>
	</section>

	<section id="sr_id_events" xreflabel="events">
	<title><varname>[partition_name];events</varname></title>
	<para>
	GW/Carrier switching reporting:
	</para>
	<para>
	For reporting events related to the state changes of the
	gateways and carriers, the module provides separate identifiers (still
	one per partition).
	Why separate ones? The reports on state changing may be verbose and there
	is the risk of loose/discard important reports on reloads due to the high
	number of logs on state changes;
	</para>
	<para>
	So, each partition will provide the identified "partition_name;events" for
	reporting state changes of gateways and carriers, along with the reason
	of the change. This identifiers have a 200 records history before 
	discarding the old ones.
	</para>
	<programlisting>
    {
        "Name": "Default;events",
        "Reports": [
            {
                "Timestamp": 1652353976,
                "Date": "Thu May 12 14:12:56 2022",
                "Log": "GW &lt;gw1_1&gt;/127.0.1.1 switched to [inactive] due probing reply\n"
            },
            {
                "Timestamp": 1652353976,
                "Date": "Thu May 12 14:12:56 2022",
                "Log": "GW &lt;gw2_1&gt;/127.0.1.2 switched to [inactive] due probing reply\n"
            }
        ]
    }
	</programlisting>
	</section>

	<para>
	For how to access and use the Status/Report information, please see
	<ulink url='>https://www.opensips.org/Documentation/Interface-StatusReport-3-3'>https://www.opensips.org/Documentation/Interface-StatusReport-3-3</ulink>.
	</para>

</section>




<section>
	<title>Installation</title>
	<para>
	The module requires 4 tables in the OpenSIPS database: dr_groups,
	dr_gateways, dr_carriers, dr_rules. The SQL syntax to create them can be
	found in the drouting-create.sql script, located in the database directories
	of the opensips/scripts folder. You can also find the complete
	database documentation on the project webpage, &osipsdbdocslink;.
	</para>
</section>

</chapter>
