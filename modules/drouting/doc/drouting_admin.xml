<!-- Drouting Module User's Guide -->

<chapter>
	<title>&adminguide;</title>
	
	<section>
	<title>Overview</title>
	<section>
	<title>Introduction</title>

	<para>Dynamic Routing is a module for selecting (based on multiple
	criteria) the best gateway/destination to be used for delivering a
	certain call. Least Cost Routing (LCR) is a special case of dynamic
	routing - when the rules are ordered based on costs. Dynamic Routing 
	comes with many features regarding routing rule selection:
	</para>
	<itemizedlist>
		<listitem><para>prefix based</para></listitem>
		<listitem><para>caller/group based</para></listitem>
		<listitem><para>time based</para></listitem>
		<listitem><para>priority based</para></listitem>
	</itemizedlist>
	<para>
	, processing :
	</para>
	<itemizedlist>
		<listitem><para>stripping and prefixing</para></listitem>
		<listitem><para>default rules</para></listitem>
		<listitem><para>inbound and outbound processing</para></listitem>
		<listitem><para>script route triggering</para></listitem>
	</itemizedlist>
	<para>
	and failure handling:
	<itemizedlist>
		<listitem><para>serial forking</para></listitem>
		<listitem><para>weight based GW selection</para></listitem>
		<listitem><para>random GW selection</para></listitem>
		<listitem><para>GW probing for crashes</para></listitem>

	</itemizedlist>
	</para>
</section>

<section>
	<title>Features</title>
	<para>
	The dynamic routing implementation for &osips; is designed with the
	following properties:
	</para>
	<itemizedlist>
	<listitem>
	<para>
	The routing info (destinations, carriers, rules, groups) is stored in a 
	database and loaded into memory at start up time; reload at runtime via
	a Management Interface command.
	</para>
	</listitem>

	<listitem>
	<para>
	weight-based or random selection of the destinations (from a rule or
	 from a carrier), failure detection of gateways (with switching to next
	 available gateway).
	</para>
	</listitem>

	<listitem>
	<para>
	able to handle large volume of routing info (10M of rules) with minimal
	speed/time and memory consumption penalties
	</para>
	</listitem>
	
	<listitem>
	<para>
	script integration - Pseudo-variable support in functions; scripting
	route triggering when rules are matched
	</para>
	</listitem>
	
	<listitem>
	<para>
	bidirectional behavior - inbound and outbound processing (strip and 
	prefixing when sending and receiving from a destination/GW)
	</para>
	</listitem>

	<listitem>
	<para>
	blacklisting - the module allows definition of backlists based on the
	destination IPs. This blacklists are to be used to prevent malicious 
	forwarding to GWs (based on DNS lookups) when the script logic does
	none-GE forwarding (like foreign domains).
	</para>
	</listitem>

	</itemizedlist>
</section>


<section>
	<title>Performance</title>
	<para>
	There were several tests performed regarding the performance of the module
	when dealing with a large number of routing rules.
	</para>
	<para>
	The tests were performed with a set of 383000 rules and measured:
	</para>
	<itemizedlist>
	<listitem><para>time to load from DB</para></listitem>
	<listitem><para>used shared memory</para></listitem>
	</itemizedlist>
	<para>
	The time to load was varying between 4 seconds and 8 seconds, depending of
	the caching of the DB client - the first load was the slowest (as the DB 
	query hits the disk drive); the following are faster as data is already 
	cached in the DB client. So technically speaking, the time to load (without
	the time to query which is DB type dependent) is ~4 seconds
	</para>
	<para>
	After loading the data into shared memory ~ 96M of memory were used 
	exclusively for the DR data.
	</para>
</section>


<section>
	<title>Dynamic Routing Concepts</title>
	<para>
	DR engine uses several concepts in order to define how the routing
	should be done (describing all the dependecies between destinations
	and routing rules).
	</para>

	<section>
	<title>Destination/Gateways</title>
	<para>
	These are the end SIP entities where actually the traffic needs to be sent
	after routing. They are stored in a table called <quote>dr_gateways</quote>.
	Gateway addresses are stored in a separate table because of the need to access them
	independent of Dynamic Routing processing (e.g., adding/ removing gateway PRI
	prefix before/after performing other operation -- receiving/relaying to gateway). 
	</para>
	<para>
	In DR, a gateway is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>SIP address (SIP URI)</para></listitem>
	<listitem><para>type (number to allow to group GW based on purpose,
	like inbound, outbound, etc)</para></listitem>
	<listitem>strip value (number of digits) from dialled
	number<para></para></listitem>
	<listitem><para>prefix (string) to be added to dialled
	number</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this GW)</para></listitem>
	<listitem><para>probing mode (how the GW should be probed at SIP level
	- see the probing chapter)</para></listitem>
	</itemizedlist>
	<para>
	The Gateways are to be used from the routing rule or from the carrier
	definition. They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Carriers</title>
	<para>
	The carrier concept is used if you need to group gateways in order to
	have a better control on how the GWs will be used by DR rules; like 
	in what order the GWs will be used.
	</para>
	<para>
	Basically, a carrier is a set of gateways which have its own sorting
	algorithm and its own attribute string. They are by default defined
	in the <quote>dr_carriers</quote> table.
	</para>
	<para>
	In DR, a carrier is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>list of gateways with/without weights (string)
	(Ex:<quote>gw1=10,gw4=10</quote> or <quote>gw1,gw2</quote>
	</para></listitem>
	<listitem><para>flags : 0x1 - use weight for sorting the list and
	not definition order; 0x2 - use only the first gateway from the carrier
	(depending on the sorting); 0x4 - disable the usage of this 
	carrier</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this carrier)</para></listitem>
	</itemizedlist>
	<para>
	The Carriers are to be used only from the routing rule definition.
	They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Routing Rules</title>
	<para>
	These are the actual rules which control the routing. Using
	different criterias (prefix, time, priority, etc), they will decide
	to which gateways the call will be sent.
	</para>
	<para>
	Default name for the table storing rule definitions is 
	<quote>dr_rules</quote>.
	</para>
	<para>
	In DR, a carrier is defined by:
	</para>
	<itemizedlist>
	<listitem><para>group (list of numbers) - rules can be grouped (a rule may
	belong to multiple groups in the same time ) and you can
	use only a certain group at a point; like having a <quote>premium</quote> or
	<quote>standard</quote> or <quote>interstate</quote> or 
	<quote>intrastate</quote> groups of rules to be used in different 
	cases</para></listitem>
	<listitem><para>prefix (string with digits only) - prefix to be used for
	matching this rule (longest prefix matching)</para></listitem>
	<listitem><para>time validity (time recurrence string) - when this rule is
	valid from time point of view (see RFC 2445)</para></listitem>
	<listitem><para>priority (number) - priority of the rule - higher value, 
	higher priority (see rule section alg)</para></listitem>
	<listitem><para>script route ID (string) - if defined, then execute the 
	route with the specified ID when this rule is matched. That's it, a route
	which can be used to perform custom operations on message. NOTE that no 
	modification is performed at signaling level and you must NOT do
	any signaling operations in that script route</para></listitem>
	<listitem><para>list of GWs/carriers (string) - a comma separated list
	of gateways or carriers (defined by IDs) to be used for this rule; the 
	carrier IDs are prefixed with <quote>#</quote> sign. For each ID (GW or
	carrier) you may specify a weight. For how this list will be interpreted 
	(as order) see the rule selection section. Example of list: 
	<quote>gw1,gw4,#cr3</quote> or <quote>gw1=10,gw4=10,#cr3=80</quote>
	</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when this rule matched and been used)</para></listitem>
	</itemizedlist>

	<para>
	More on time recurrence:
	</para>
	<itemizedlist>
	<listitem><para>
	A date-time expression that defines the time recurrence to be matched for
	current rule. Time recurrences are based closely on the recurring time
	intervals from the Internet Calendaring and Scheduling
	Core Object Specification (calendar COS), RFC 2445. The set of attributes
	used in routing rule specification is a subset of time recurrence attributes.
	</para></listitem>
	<listitem><para>
	The value stored in database has the format of:
	<![CDATA[
	<dtstart>|<duration>|<freq>|<until>|<interval>|<byday>|<bymonthday>|<byyearday>|<byweekno>|<bymonth>
	]]>
	</para></listitem>
	<listitem><para>
	When an attribute is not specified, the corresponding place must be left
	empty, whenever another attribute that follows in the list has to be
	specified.
	</para></listitem>
	</itemizedlist>
	</section>
</section>


<section>
	<title>Routing Rule Processing</title>
	<para>
	The module can be used to find out which is the best gateway to use for new
	calls terminated to PSTN. The algorithm to select the rule is as follows:
	<itemizedlist mark='bullet'>
	<listitem>
	<para>
	the module discovers the routing group of the originating user. This 
	step is skipped if a routing group is passed from the script as parameter.
	</para>
	</listitem>
	<listitem>
	<para>
	once the group is known, in the subset of the rules for this group the 
	module looks for the one that matches the destination based on "prefix"
	column. The set of rules with the longest prefix is chosen. If no digit 
	from the prefix matches, the default rules are used (rules with no prefix)
	</para>
	</listitem>
	<listitem>
	<para>
	within the set of rules is applied the time criteria, and the rule which
	has the highest priority and matches the time criteria is selected to drive
	the routing.
	</para>
	</listitem>
	<listitem>
	<para>
	Once found the rule, it may contain a route ID to execute. If a certain 
	flag is set, then the processing is stopped after executing the route
	block.
	</para>
	</listitem>
	<listitem>
	<para>
	The rule must contain a chain of gateways and carriers. The module will 
	execute serial forking for each address in the chain (ordering is either done
	by simply using the definition order or it may weight-based - weight selection must be
	enabled). The next address in chain is used only if the previously has failed.
	</para>
	</listitem>
	<listitem>
	<para>
	With the right gateway address found, the prefix (PRI) of the gateway is
	added to the request URI and then the request is forwarded.
	</para>
	</listitem>
	</itemizedlist>
	</para>
	<para>
	If no rule is found to match the selection criteria an default action must
	be taken (e.g., error response sent back). If the gateway in the chain has 
	no prefix the request is forwarded without adding any prefix to the request
	URI.
	</para>
</section>


<section>
	<title>Probing and Disabling destinations</title>
	<para>
	The module has the capability to monitor the status of the destinations by
	doing SIP probing (sending SIP requests like OPTIONS).
	</para>
	<para>
	For each destination, you can configure what kind of probing should be
	done (probe_mode column):
	</para>
	<itemizedlist>
	<listitem>
		<para><emphasis>(0)</emphasis> - no probing at all;</para>
	</listitem>
	<listitem>
		<para><emphasis>(1)</emphasis> - probing only when the destination is
		in disabled mode (disabling via MI command will competely stop the
		probing also). The destination will be automatically re-enabled
		when the probing will succeed next time;</para>
	</listitem>
	<listitem>
		<para><emphasis>(2)</emphasis> - probing all the time. If disabled,
		the destination will be automatically re-enabled when the probing
		will succeed next time;
		</para>
	</listitem>
	</itemizedlist>
	<para>
	A destination can become disabled in two ways:
	<itemizedlist>
	<listitem>
		<emphasis>script detection</emphasis> - by calling from script the
		dr_disable() function after trying the destination. In this case, if
		probing mode for the destination is (1) or (2), the destination will
		be automatically re-enabled when the probing will succeed.
	</listitem>
	<listitem>
		<emphasis>MI command</emphasis> - by calling the dr_gw_status MI
		command for disabling (on demand) the destination. If so, the probing
		and re-enabling of this destination will be completly disabled until
		you re-enable it again via MI command - this is designed to allow
		controlled and complete disabling of some destination during
		maintenance.
	</listitem>
	</itemizedlist>
	</para>
</section>

</section>


	<section>
	<title>Dependencies</title>
	<section>
		<title>&osips; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>a database module</emphasis>.
			</para>
			</listitem>
			</itemizedlist>

			<itemizedlist>
			<listitem>
			<para>
				<emphasis>tm module</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>

	<section>
		<title>External Libraries or Applications</title>
		<itemizedlist>
			<listitem>
			<para>
				<emphasis>none</emphasis>.
			</para>
			</listitem>
		</itemizedlist>

		</section>
	</section>
	
	<section>
	<title>Exported Parameters</title>
	<section>
		<title><varname>db_url</varname>(str)</title>
		<para>
		The database url.
		</para>
		<para>
		<emphasis>	Default value is <quote>NULL</quote>.	
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_url", 
	"mysql://opensips:opensipsrw@localhost/opensips")
...
</programlisting>
		</example>
	</section>
	<section>
		<title><varname>drd_table</varname>(str)</title>
		<para>
		The name of the db table storing gateway addresses.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_gateways</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drd_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drd_table", "dr_gateways")
...
</programlisting>
		</example>
	</section>
	<section>
		<title><varname>drr_table</varname>(str)</title>
		<para>
		The name of the db table storing routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_rules</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drr_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drr_table", "rules")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_table</varname>(str)</title>
		<para>
		The name of the db table storing groups.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_groups</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_table", "groups")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drc_table</varname>(str)</title>
		<para>
		The name of the db table storing definitions of the carriers that will 
		be used directly by the routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_carriers</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drc_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drc_table", "my_dr_carriers")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>ruri_avp</varname> (str)</title>
		<para>
		The name of the avp for storing Request URIs to be later used 
		(alternative destiantions for the current one).
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(0xad346b2f)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>ruri_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "ruri_avp", '$avp(33)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>gw_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current selected
		gateway/destination - once a new destination is selected (via the 
		use_next_gw() function), the AVP will be updated with the ID of the
		new selected gateway/destination.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(0xad346b30)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_id_avp", '$avp(gw_id)')
modparam("drouting", "gw_id_avp", '$avp(334)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>gw_priprefix_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the PRI prefix of the current selected
		destination/gateway - once a new destination is selected (via the 
		use_next_gw() function), the AVP will be updated with the PRI prefix of the
		new used destination.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_priprefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_priprefix_avp", '$avp(gw_priprefix)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>rule_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current matched
		routing rule (see dr_rules table).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_id_avp", '$avp(rule_id)')
modparam("drouting", "rule_id_avp", '$avp(335)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>rule_prefix_avp</varname> (str)</title>
		<para>
		The actual prefix that matched the routing rule (the part from RURI 
		username that matched the routing rule).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_prefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_prefix_avp", '$avp(dr_prefix)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>carrier_id_avp</varname> (str)</title>
		<para>
		AVP to be populate with the ID string for the carrier the 
		current GW belongs to.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>carrier_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "carrier_id_avp", '$avp(carrier_id)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>define_blacklist</varname> (str)</title>
		<para>
		Defines a backlist based on a list of GW types - the list will contain
		the IPs (no port, all protocols) of the GWs with the specified types.
		</para>
		<para>
		Multiple instances of this param are allowed.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>define_blacklist</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "define_blacklist", 'bl_name= 3,5,25,23')
modparam("drouting", "define_blacklist", 'list= 4,2')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>default_group</varname> (int)</title>
		<para>
		Group to be used if the caller (FROM user) is not found in the GROUP
		table.
		</para>
		<para>
		<emphasis>Default value is <quote>NONE</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>default_group</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "default_group", 4)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>force_dns</varname> (int)</title>
		<para>
		Force DNS resolving of GW/destination names (if not IPs) during 
		startup. If not enabled, the GW name will be blindly used during 
		routing.
		</para>
		<para>
		<emphasis>Default value is <quote>1 (enabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>force_dns</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "force_dns", 0)
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>persistent_state</varname> (int)</title>
		<para>
		Specifies whether the <emphasis>state</emphasis> column
		should be loaded at startup and flushed during runtime or not.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote> (enabled).
		</emphasis>
		</para>
		<example>
		<title>Set the <varname>persistent_state</varname> parameter</title>
		<programlisting format="linespecific">
...
# disable all DB operations with the state of a gateway
modparam("drouting", "persistent_state", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_interval</varname> (integer)</title>
		<para>
		How often (in seconds) the probing of a destination should be done. If
		set to 0, the probing will be disabled as functionality (for all
		destinations)
		</para>
		<para>
		<emphasis>
			Default value is <quote>30</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_interval</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_interval", 60)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_method</varname> (string)</title>
		<para>
		The SIP method to be used for the probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"OPTIONS"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_method</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_method", "INFO")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_from</varname> (string)</title>
		<para>
		The FROM SIP URI to be advertised in the SIP probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"sip:prober@localhost"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_from</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_from", "sip:pinger@192.168.2.10")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_reply_codes</varname> (string)</title>
		<para>
		A comma separted list of SIP reply codes. The codes defined here
		will be considered as valid reply codes for probing messages,
		apart for 200.
		</para>
		<para>
		<emphasis>
			Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_reply_codes</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_reply_codes", "501, 403")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>use_domain</varname> (int)</title>
		<para>
			Flag to configure whether to use domain match when querying
			database for user's routing group.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>use_domain</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "use_domain", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_user_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the username is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>username</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_user_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_user_col", "user")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_domain_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the domain is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>domain</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_domain_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_domain_col", "host")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_grpid_col</varname> (str)</title>
		<para>
			The name of the column in group db table where the
			group id is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>groupid</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_grpid_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_grpid_col", "grpid")
...
</programlisting>
		</example>
	</section>

</section>

<section>
	<title>Exported Functions</title>
	<section>
		<title>
		<function moreinfo="none">do_routing([groupID], [flags], [gw_whitelist], [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger routing of the message according to the 
		rules in the database table and the configured parameters.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
			All parameters are optional. Any of them may be ignored, provided
			the necessary separation marks "," are properly placed.
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>groupID</emphasis> - the routing group the
					caller belongs to - this may be a static numerical 
					value or an AVP specification (value must be numerical 
					type, string types are ignored!). If none specified, the
					function will automatically try to query the dr_group 
					table to get this information;
				</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> - Controls the behavior of the
					function. Possible flags are:
				</para>
					<itemizedlist>
					<listitem>
					<para>
						<emphasis role='bold'>W</emphasis> - Instead of using the destination
						(from the rule definition) in the given order, sort them
						based on their weight.
					</para>
					</listitem>
					<listitem>
					<para>
						<emphasis role='bold'>F</emphasis> - Enable rule fallback; normally
						the engine is using a single rule for routing a call; by
						setting this flag, the engine will fallback and use
						rules with less priority or shorter prefix when all the 
						destination from the current rules failed.
					</para>
					</listitem>
					<listitem>
					<para>
						<emphasis role='bold'>L</emphasis> - Do strict length matching over the
						prefix - actually DR engine will do full number maching and 
						not prefix matching anymore.
					</para>
					</listitem>
					<listitem>
					<para>
						<emphasis role='bold'>C</emphasis> - Only check if the dialed number 
						matches any routing rule, without loading / applying any
						routing info (no GW is set, the RURI is not altered)
					</para>
					</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_whitelist</emphasis> - a comma separated white
					list of gateways. This will force routing over, at most, this
					list of carriers or gateways (in other words, the whitelist
					will be intersected with the results of the search through the rules).
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>rule_attrs_pvar</emphasis> (output, optional)- a writable
					pseudo-variable which will be populated with the attributes
					of the matched dynamic routing rule.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, optional) - a writable
					pseudo-variable which will be populated with the attributes
					of the matched carrier.
					</para>
				</listitem>
			</itemizedlist>
		</para>

		<example>
		<title><function>do_routing</function> usage</title>
		<programlisting format="linespecific">
...
# all groups, sort on order
do_routing();
...
# group id 0, sort on order
do_routing("0");
...
# group id from $avp(10), sort on order
do_routing("$avp(10)");
...
# all groups, sort on weights
do_routing("", "W");
...
# group id 2, sort on order, fallback rule and also return the gateway attributes
do_routing("2", "F", , , "$var(gw_attributes)");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">route_to_carrier(carrier_id, [gw_attrs_pvar], [carrier_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given carrier. In this case
		the routing is not done prefix based, but carrier based (call will be
		sent to the GWs of that carrier, based on carrier policy)
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE..
		</para>

		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_id </emphasis> (mandatory) - the
					ID (name) of the carrier to be used; pseudo-variables are accepted
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the currently matched gateway of this carrier.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with the attributes
					of this carrier.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_carrier</function> usage</title>
		<programlisting format="linespecific">
...
if ( route_to_carrier("my_top_carrier", , "$var(carrier_att)") ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">route_to_gw(gw_id, [gw_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given gateway (or list of gateways).
		Attributes and per-gw preocessing will be available.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>

		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>gw_id </emphasis> (mandatory) - the
					ID / comma-separated list of IDs of the gateway(s) to be used.
					pseudo-variables are accepted
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the currently matched gateway.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_gw</function> usage</title>
		<programlisting format="linespecific">
...
if ( route_to_gw("gw_europe") ) {
	t_relay();
	exit;
}
...
if ( route_to_gw("gw1,gw2,gw3", "$var(gw_attrs)") ) {
	xlog("Relaying to first gateway from our list - $var(gw_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">use_next_gw([rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar])/next_routing()</function>
		</title>
		<para>
		The function takes the next available destination (set by do_routing,
		as alternative destinations) and pushes it into the RURI. Note that the
		function just sets the RURI (nothing more).
		</para>
		<para>
		If a new RURI is set, the used destination is removed from the
		pending set of alternative destinations.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		The function returns true only if a new RURI was set. False
		is returned is no other alternative destinations are found or in case
		of an internal processing error. It may take the following optional parameters:
		</para>

		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>rule_attrs_pvar </emphasis> (output, optional) - a writable
					pseudo-variable which will be populated with the attributes
					of the matched dynamic routing rule.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, optional) - a writable
					pseudo-variable which will be populated with the attributes
					of the matched carrier.
					</para>
				</listitem>
		</itemizedlist>
		</para>


		<example>
		<title><function>use_next_gw</function> usage</title>
		<programlisting format="linespecific">
...
if (use_next_gw()) {
	t_relay();
	exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw(, , "$var(carrier_attrs)")) {
	xlog("Carrier attributes of current gateway: $var(carrier_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">goes_to_gw([type], [flags], [gw_attrs_pvar])</function>
		</title>
		<para>
		Function returns true if the destination of the current request
		(destination URI or Request URI) points (as IP) to one of the gateways.
		There no DNS lookups done if the domain part of the URI is not an IP.
		</para>
		<para>
		This function does not change anything in the message.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, BRANCH_ROUTE
		and LOCAL_ROUTE.
		</para>
		<para>
			All parameters are optional. Any of them may be ignored, provided
			the necessary separation marks "," are properly placed.
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination 
					type to be checked; when ommiting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the 
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the 
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the 
							gateway id into gw_id_avp AVP
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port
							number during matching
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>goes_to_gw</function> usage</title>
		<programlisting format="linespecific">
...
if (goes_to_gw("1", , "$var(gw_attrs)")) {
	sl_send_reply("403","Forbidden");
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">is_from_gw([type], [flag], [gw_attrs_pvar])</function>
		</title>
		<para>
		The function checks if the sender of the message is a gateway
		from a certain group.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE
		and ONREPLY_ROUTE.
		</para>
		<para>
			All parameters are optional. Any of them may be ignored, provided
			the necessary separation marks "," are properly placed.
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination
					type to be checked; when ommiting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the 
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the 
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the 
							gateway id into gw_id_avp AVP
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port
							number during matching
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>is_from_gw</function> usage</title>
		<programlisting format="linespecific">
...
if (is_from_gw("3","1") {
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">dr_is_gw(src_avp, [type], [flag], [gw_attrs_pvar])</function>
		</title>
		<para>
		The function checks if the ip address in pvar src_pv is a gateway
		from a certain group.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE, LOCAL_ROUTE, STARTUP_ROUTE, TIMER_ROUTE and EVENT_ROUTE.
		</para>
		<para>
			Meaning of the parameters is as follows:
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>src_avp</emphasis> (mandatory) - avp containing a SIP URI.
					Does not support other OpenSIPS pseudo-variables.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination
					type to be checked; when ommiting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the 
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the 
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the gateway id into gw_id_avp pvar
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port number
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable pseudo-variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>dr_is_gw</function> usage</title>
		<programlisting format="linespecific">
...
if (dr_is_gw("$avp(uac)","3") {
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">dr_disable()</function>
		</title>
		<para>
		Marks as disabled the last destination that was used for the current
		call. The disabling done via this function will prevent the
		destination to be used for usage from now on. The probing mechanism
		can re-enable this peer (see the probing section in the begining)
		</para>
		<para>
		This function can be used from REQUEST_ROUTE and FAILURE_ROUTE.
		</para>
		<example>
		<title><function>dr_disable()</function> usage</title>
		<programlisting format="linespecific">
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
	dr_disable();
	
}

...
</programlisting>
		</example>
	</section>
</section>


<section>
	<title>Exported MI Functions</title>
	<section>
		<title>
		<function moreinfo="none">dr_reload</function>
		</title>
		<para>
		Command to reload routing rules from database.
		</para>
		<para>
			It takes no parameter.
		</para>

		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_reload:fifo_reply
		_empty_line_
		</programlisting>
	</section>

	<section>
		<title><varname>dr_gw_status</varname></title>
		<para>
		Gets or sets the status (enabled or disabled) of a gateway. The
		function may take from 0 to 2 parameters. If none, it will list all
		gateways along with their status. If one parameter is provided, that 
		must be the id of a gateway and the function will return the status
		of that gateway. If 2 parameters are provided, first must be the ID of
		the ID of a GW and the second must be the new status to be forced for
		that GW (0 - disable, 1 - enable).
		</para>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_gw_status:_reply_fifo_file_
		GW_id
		status (optional)
		_empty_line_
		</programlisting>
		<example>
		<title><function>dr_gw_status</function> usage</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_gw_status 2
Enabled:: no
$ ./opensipsctl fifo dr_gw_status 2 1
$ ./opensipsctl fifo dr_gw_status 2
Enabled:: yes
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_carrier_status</varname></title>
		<para>
		Gets or sets the status (enabled or disabled) of a carrier. The
		function may take from 0 to 2 parameters. If none, it will list all
		carriers along with their status. If one parameter is provided, that 
		must be the id of a carrier and the function will return the status
		of that carrier. If 2 parameters are provided, first must be the ID of
		the ID of a carrier and the second must be the new status to be 
		forced for that carrier (0 - disable, 1 - enable).
		</para>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_carrier_status:_reply_fifo_file_
		carrier_id
		status (optional)
		_empty_line_
		</programlisting>
		<example>
		<title><function>dr_carrier_status</function> usage</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: no
$ ./opensipsctl fifo dr_carrier_status CR1 1
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: yes
</programlisting>
		</example>
	</section>


</section>

<section>
	<title>Installation</title>
	<para>
	The module requires 4 tables in the OpenSIPS database: dr_groups,
	dr_gateways, dr_carriers, dr_rules. The SQL syntax to create them can be
	found in the drouting-create.sql script, located in the database directories
	of the opensips/scripts folder. You can also find the complete
	database documentation on the project webpage, &osipsdbdocslink;.
	</para>
</section>

</chapter>

