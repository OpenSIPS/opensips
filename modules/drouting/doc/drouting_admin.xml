<!-- Drouting Module User's Guide -->

<chapter>
	<title>&adminguide;</title>

	<section>
	<title>Overview</title>
	<section>
	<title>Introduction</title>

	<para>Dynamic Routing is a module for selecting (based on multiple
	criteria) the best gateway/destination to be used for delivering a
	certain call. Least Cost Routing (LCR) is a special case of dynamic
	routing - when the rules are ordered based on costs. Dynamic Routing
	comes with many features regarding routing rule selection:
	</para>
	<itemizedlist>
		<listitem><para>prefix based</para></listitem>
		<listitem><para>caller/group based</para></listitem>
		<listitem><para>time based</para></listitem>
		<listitem><para>priority based</para></listitem>
	</itemizedlist>
	<para>
	, processing :
	</para>
	<itemizedlist>
		<listitem><para>stripping and prefixing</para></listitem>
		<listitem><para>default rules</para></listitem>
		<listitem><para>inbound and outbound processing</para></listitem>
		<listitem><para>script route triggering</para></listitem>
	</itemizedlist>
	<para>
	and failure handling:
	<itemizedlist>
		<listitem><para>serial forking</para></listitem>
		<listitem><para>weight based GW selection</para></listitem>
		<listitem><para>random GW selection</para></listitem>
		<listitem><para>GW probing for crashes</para></listitem>

	</itemizedlist>
	</para>
</section>

<section>
	<title>Features</title>
	<para>
	The dynamic routing implementation for &osips; is designed with the
	following properties:
	</para>
	<itemizedlist>
	<listitem>
	<para>
	The routing info (destinations, carriers, rules, groups) is stored in a
	database and loaded into memory at start up time; reload at runtime via
	a Management Interface command.
	</para>
	</listitem>

	<listitem>
	<para>
	weight-based or random selection of the destinations (from a rule or
	 from a carrier), failure detection of gateways (with switching to next
	 available gateway).
	</para>
	</listitem>

	<listitem>
	<para>
	able to handle large volume of routing info (10M of rules) with minimal
	speed/time and memory consumption penalties
	</para>
	</listitem>

	<listitem>
	<para>
	script integration - Pseudo-variable support in functions; scripting
	route triggering when rules are matched
	</para>
	</listitem>

	<listitem>
	<para>
	bidirectional behavior - inbound and outbound processing (strip and
	prefixing when sending and receiving from a destination/GW)
	</para>
	</listitem>

	<listitem>
	<para>
	blacklisting - the module allows definition of blacklists based on the
	destination IPs. This blacklists are to be used to prevent malicious
	forwarding to GWs (based on DNS lookups) when the script logic does
	none-GE forwarding (like foreign domains).
	</para>
	</listitem>

	<listitem>
	<para>
	loading routing information from multiple databases - the gateways, rules, groups and
	carriers can be grouped by partitions, and each partition may be loaded
	from different databases/tables. This makes the routing process partition
	based. In order to be able to use a table from a partition, its name must
	be found in the "version" table belonging to the database defined in the
	partition's db_url.
	</para>
	</listitem>

	</itemizedlist>
</section>


<section>
	<title>Performance</title>
	<para>
	There were several tests performed regarding the performance of the module
	when dealing with a large number of routing rules.
	</para>
	<para>
	The tests were performed with a set of 383000 rules and measured:
	</para>
	<itemizedlist>
	<listitem><para>time to load from DB</para></listitem>
	<listitem><para>used shared memory</para></listitem>
	</itemizedlist>
	<para>
	The time to load was varying between 4 seconds and 8 seconds, depending of
	the caching of the DB client - the first load was the slowest (as the DB
	query hits the disk drive); the following are faster as data is already
	cached in the DB client. So technically speaking, the time to load (without
	the time to query which is DB type dependent) is ~4 seconds
	</para>
	<para>
	After loading the data into shared memory ~ 96M of memory were used
	exclusively for the DR data.
	</para>
</section>


<section>
	<title>Dynamic Routing Concepts</title>
	<para>
	DR engine uses several concepts in order to define how the routing
	should be done (describing all the dependencies between destinations
	and routing rules).
	</para>

	<section>
	<title>Destination/Gateways</title>
	<para>
	These are the end SIP entities where actually the traffic needs to be sent
	after routing. They are stored in a table called <quote>dr_gateways</quote>.
	Gateway addresses are stored in a separate table because of the need to access them
	independent of Dynamic Routing processing (e.g., adding/ removing gateway PRI
	prefix before/after performing other operation -- receiving/relaying to gateway).
	</para>
	<para>
	In DR, a gateway is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>SIP address (SIP URI)</para></listitem>
	<listitem><para>type (number to allow to group GW based on purpose,
	like inbound, outbound, etc)</para></listitem>
	<listitem>strip value (number of digits) from dialled
	number<para></para></listitem>
	<listitem><para>prefix (string) to be added to dialled
	number</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this GW)</para></listitem>
	<listitem><para>probing mode (how the GW should be probed at SIP level
	- see the probing chapter)</para></listitem>
	</itemizedlist>
	<para>
	The Gateways are to be used from the routing rule or from the carrier
	definition. They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Carriers</title>
	<para>
	The carrier concept is used if you need to group gateways in order to
	have a better control on how the GWs will be used by DR rules; like
	in what order the GWs will be used.
	</para>
	<para>
	Basically, a carrier is a set of gateways which have its own sorting
	algorithm and its own attribute string. They are by default defined
	in the <quote>dr_carriers</quote> table.
	</para>
	<para>
	In DR, a carrier is defined by:
	</para>
	<itemizedlist>
	<listitem><para>id (string)</para></listitem>
	<listitem><para>list of gateways with/without weights (string)
	(Ex:<quote>gw1=10,gw4=10</quote> or <quote>gw1,gw2</quote>
	</para></listitem>
	<listitem><para>flags : 0x1 - use weight for sorting the list and
	not definition order; 0x2 - use only the first gateway from the carrier
	(depending on the sorting); 0x4 - disable the usage of this
	carrier</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when routing to this carrier)</para></listitem>
	</itemizedlist>
	<para>
	The Carriers are to be used only from the routing rule definition.
	They are all the time referred by their ID.
	</para>
	</section>

	<section>
	<title>Routing Rules</title>
	<para>
	These are the actual rules which control the routing. Using
	different criterias (prefix, time, priority, etc), they will decide
	to which gateways the call will be sent.
	</para>
	<para>
	Default name for the table storing rule definitions is
	<quote>dr_rules</quote>.
	</para>
	<para>
	In DR, a carrier is defined by:
	</para>
	<itemizedlist>
	<listitem><para>group (list of numbers) - rules can be grouped (a rule may
	belong to multiple groups in the same time ) and you can
	use only a certain group at a point; like having a <quote>premium</quote> or
	<quote>standard</quote> or <quote>interstate</quote> or
	<quote>intrastate</quote> groups of rules to be used in different
	cases</para></listitem>
	<listitem><para>prefix (string with digits only) - prefix to be used for
	matching this rule (longest prefix matching)</para></listitem>
	<listitem><para>time validity (time recurrence string) - when this rule is
	valid from time point of view (see RFC 2445)</para></listitem>
	<listitem><para>priority (number) - priority of the rule - higher value,
	higher priority (see rule section alg)</para></listitem>
	<listitem><para>script route ID (string) - if defined, then execute the
	route with the specified ID when this rule is matched. That's it, a route
	which can be used to perform custom operations on message. NOTE that no
	modification is performed at signaling level and you must NOT do
	any signaling operations in that script route</para></listitem>
	<listitem><para>list of GWs/carriers (string) - a comma separated list
	of gateways or carriers (defined by IDs) to be used for this rule; the
	carrier IDs are prefixed with <quote>#</quote> sign. For each ID (GW or
	carrier) you may specify a weight. For how this list will be interpreted
	(as order) see the rule selection section. Example of list:
	<quote>gw1,gw4,#cr3</quote> or <quote>gw1=10,gw4=10,#cr3=80</quote>
	</para></listitem>
	<listitem><para>attributes (not used by DR engine, but only pushed
	to script level when this rule matched and been used)</para></listitem>
	</itemizedlist>

	<para>
	More on time recurrence:
	</para>
	<itemizedlist>
	<listitem><para>
	A date-time expression that defines the time recurrence to be matched for
	current rule. Time recurrences are based closely on the recurring time
	intervals from the Internet Calendaring and Scheduling
	Core Object Specification (calendar COS), RFC 2445. The set of attributes
	used in routing rule specification is a subset of time recurrence attributes.
	</para></listitem>
	<listitem><para>
	The value stored in database has the format of:
	<![CDATA[
	<dtstart>|<duration>|<freq>|<until>|<interval>|<byday>|<bymonthday>|<byyearday>|<byweekno>|<bymonth>
	]]>
	</para></listitem>
	<listitem><para>
	When an attribute is not specified, the corresponding place must be left
	empty, whenever another attribute that follows in the list has to be
	specified.
	</para></listitem>
	</itemizedlist>
	</section>
</section>


<section>
	<title>Routing Rule Processing</title>
	<para>
	The module can be used to find out which is the best gateway to use for new
	calls terminated to PSTN. The algorithm to select the rule is as follows:
	<itemizedlist mark='bullet'>
	<listitem>
	<para>
	the module discovers the routing group of the originating user. This
	step is skipped if a routing group is passed from the script as parameter.
	</para>
	</listitem>
	<listitem>
	<para>
	once the group is known, in the subset of the rules for this group the
	module looks for the one that matches the destination based on "prefix"
	column. The set of rules with the longest prefix is chosen. If no digit
	from the prefix matches, the default rules are used (rules with no prefix)
	</para>
	</listitem>
	<listitem>
	<para>
	within the set of rules is applied the time criteria, and the rule which
	has the highest priority and matches the time criteria is selected to drive
	the routing.
	</para>
	</listitem>
	<listitem>
	<para>
	Once found the rule, it may contain a route ID to execute. If a certain
	flag is set, then the processing is stopped after executing the route
	block.
	</para>
	</listitem>
	<listitem>
	<para>
	The rule must contain a chain of gateways and carriers. The module will
	execute serial forking for each address in the chain (ordering is either done
	by simply using the definition order or it may weight-based - weight selection must be
	enabled). The next address in chain is used only if the previously has failed.
	</para>
	</listitem>
	<listitem>
	<para>
	With the right gateway address found, the prefix (PRI) of the gateway is
	added to the request URI and then the request is forwarded.
	</para>
	</listitem>
	</itemizedlist>
	</para>
	<para>
	If no rule is found to match the selection criteria an default action must
	be taken (e.g., error response sent back). If the gateway in the chain has
	no prefix the request is forwarded without adding any prefix to the request
	URI.
	</para>
</section>


<section>
	<title>Probing and Disabling destinations</title>
	<para>
	The module has the capability to monitor the status of the destinations by
	doing SIP probing (sending SIP requests like OPTIONS).
	</para>
	<para>
	For each destination, you can configure what kind of probing should be
	done (probe_mode column):
	</para>
	<itemizedlist>
	<listitem>
		<para><emphasis>(0)</emphasis> - no probing at all;</para>
	</listitem>
	<listitem>
		<para><emphasis>(1)</emphasis> - probing only when the destination is
		in disabled mode (disabling via MI command will completely stop the
		probing also). The destination will be automatically re-enabled
		when the probing will succeed next time;</para>
	</listitem>
	<listitem>
		<para><emphasis>(2)</emphasis> - probing all the time. If disabled,
		the destination will be automatically re-enabled when the probing
		will succeed next time;
		</para>
	</listitem>
	</itemizedlist>
	<para>
	A destination can become disabled in two ways:
	<itemizedlist>
	<listitem>
		<emphasis>script detection</emphasis> - by calling from script the
		dr_disable() function after trying the destination. In this case, if
		probing mode for the destination is (1) or (2), the destination will
		be automatically re-enabled when the probing will succeed.
	</listitem>
	<listitem>
		<emphasis>MI command</emphasis> - by calling the dr_gw_status MI
		command for disabling (on demand) the destination. If so, the probing
		and re-enabling of this destination will be completly disabled until
		you re-enable it again via MI command - this is designed to allow
		controlled and complete disabling of some destination during
		maintenance.
	</listitem>
	</itemizedlist>
	</para>
</section>

</section>


	<section>
	<title>Dependencies</title>
	<section>
		<title>&osips; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>

			<listitem>
			<para>
				<emphasis>a database module</emphasis>.
			</para>
			</listitem>
			</itemizedlist>

			<itemizedlist>
			<listitem>
			<para>
				<emphasis>tm module</emphasis>.
			</para>
			</listitem>

			<listitem>
			<para>
				<emphasis>clustere</emphasis> - only if "replicate_status_to"
				option is enabled.
			</para>
			</listitem>

			</itemizedlist>
		</para>
	</section>

	<section>
		<title>External Libraries or Applications</title>
		<itemizedlist>
			<listitem>
			<para>
				<emphasis>none</emphasis>.
			</para>
			</listitem>
		</itemizedlist>

		</section>
	</section>

	<section>
	<title>Exported Parameters</title>
	<section>
		<title><varname>db_url</varname>(str)</title>
		<para>
		The database url.
		</para>
		<para>
		<emphasis>	Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_url",
	"mysql://opensips:opensipsrw@localhost/opensips")
...
</programlisting>
		</example>
	</section>
	<section>
		<title><varname>drd_table</varname>(str)</title>
		<para>
		The name of the db table storing gateway addresses.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_gateways</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drd_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drd_table", "dr_gateways")
...
</programlisting>
		</example>
	</section>
	<section>
		<title><varname>drr_table</varname>(str)</title>
		<para>
		The name of the db table storing routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_rules</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drr_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drr_table", "rules")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_table</varname>(str)</title>
		<para>
		The name of the db table storing groups.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_groups</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_table", "groups")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drc_table</varname>(str)</title>
		<para>
		The name of the db table storing definitions of the carriers that will
		be used directly by the routing rules.
		</para>
		<para>
		<emphasis>	Default value is <quote>dr_carriers</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drc_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drc_table", "my_dr_carriers")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>ruri_avp</varname> (str)</title>
		<para>
		The name of the avp for storing Request URIs to be later used
		(alternative destiantions for the current one).
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_ruri__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_ruri__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>ruri_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "ruri_avp", '$avp(33)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>gw_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current selected
		gateway/destination - once a new destination is selected (via the
		use_next_gw() function), the AVP will be updated with the ID of the
		new selected gateway/destination.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_gw_id__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_gw_id__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_id_avp", '$avp(gw_id)')
modparam("drouting", "gw_id_avp", '$avp(334)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>gw_priprefix_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the PRI prefix of the current selected
		destination/gateway - once a new destination is selected (via the
		use_next_gw() function), the AVP will be updated with the PRI prefix of the
		new used destination.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_priprefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_priprefix_avp", '$avp(gw_priprefix)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>rule_id_avp</varname> (str)</title>
		<para>
		The name of the avp for storing the id of the current matched
		routing rule (see dr_rules table).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_id_avp", '$avp(rule_id)')
modparam("drouting", "rule_id_avp", '$avp(335)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>rule_prefix_avp</varname> (str)</title>
		<para>
		The actual prefix that matched the routing rule (the part from RURI
		username that matched the routing rule).
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_prefix_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_prefix_avp", '$avp(dr_prefix)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>carrier_id_avp</varname> (str)</title>
		<para>
		AVP to be populate with the ID string for the carrier the
		current GW belongs to.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>carrier_id_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "carrier_id_avp", '$avp(carrier_id)')
...
	</programlisting>
		</example>
	</section>


	<section>
		<title><varname>gw_sock_avp</varname> (str)</title>
		<para>
		The name of the avp for storing sockets for alternative destinations
		defined by ruri_avp.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_sock__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_sock__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>gw_sock_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "gw_sock_avp", '$avp(dr_sock)')
modparam("drouting", "gw_sock_avp", '$avp(77)')
...
	</programlisting>
		</example>
	</section>

			<section>
		<title><varname>rule_attrs_avp</varname> (str)</title>
		<para>
		The name of the avp for storing rule attrs in case they are requested at least
		once in the script.
		</para>
		<para>
		<emphasis>Default value is <quote>$avp(___dr_ru_att__)</quote> if <varname>use_partitions</varname> parameter is 0
		or <quote>$avp(___dr_ru_att__partition_name)</quote> where partition_name is the name of the partition
		containing the AVP (as fetched from the database) if <varname>use_partitions</varname> parameter is 1.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>rule_attrs_avp</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "rule_attrs_avp", '$avp(dr_rule_attr)')
modparam("drouting", "rule_attrs_avp", '$avp(11)')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>define_blacklist</varname> (str)</title>
		<para>
		Defines a blacklist based on a list of GW types - the list will contain
		the IPs (no port, all protocols) of the GWs with the specified types.
		</para>
		<para>
		Multiple instances of this param are allowed.
		</para>
		<para>
		<emphasis>Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>define_blacklist</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "define_blacklist", 'bl_name= 3,5,25,23')
modparam("drouting", "define_blacklist", 'list= 4,2')
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>default_group</varname> (int)</title>
		<para>
		Group to be used if the caller (FROM user) is not found in the GROUP
		table.
		</para>
		<para>
		<emphasis>Default value is <quote>NONE</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>default_group</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "default_group", 4)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>force_dns</varname> (int)</title>
		<para>
		Force DNS resolving of GW/destination names (if not IPs) during
		startup. If not enabled, the GW name will be blindly used during
		routing.
		</para>
		<para>
		<emphasis>Default value is <quote>1 (enabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>force_dns</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "force_dns", 0)
...
	</programlisting>
		</example>
	</section>

	<section>
		<title><varname>persistent_state</varname> (int)</title>
		<para>
		Specifies whether the <emphasis>state</emphasis> column
		should be loaded at startup and flushed during runtime or not.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote> (enabled).
		</emphasis>
		</para>
		<example>
		<title>Set the <varname>persistent_state</varname> parameter</title>
		<programlisting format="linespecific">
...
# disable all DB operations with the state of a gateway
modparam("drouting", "persistent_state", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>no_concurrent_reload</varname> (int)</title>
		<para>
			If enabled, the module will not allow do run multiple dr_reload
			MI commands in parallel (with overlapping)  Any new reload will
			be rejected (and discarded) while an existing reload is in
			progress.
			</para>
			<para>
			If you have a large routing set (millions of rules/prefixes), you
			should consider disabling concurrent reload as they will exhaust
			the shared memory (by reloading into memory, in the same time,
			multiple instances of routing data).
			</para>
		<para>
		<emphasis>Default value is <quote>0 (disabled)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>no_concurrent_reload</varname> parameter</title>
		<programlisting format="linespecific">
...
# do not allow parallel reload operations
modparam("drouting", "no_concurrent_reload", 1)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_interval</varname> (integer)</title>
		<para>
		How often (in seconds) the probing of a destination should be done. If
		set to 0, the probing will be disabled as functionality (for all
		destinations)
		</para>
		<para>
		<emphasis>
			Default value is <quote>30</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_interval</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_interval", 60)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_method</varname> (string)</title>
		<para>
		The SIP method to be used for the probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"OPTIONS"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_method</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_method", "INFO")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_from</varname> (string)</title>
		<para>
		The FROM SIP URI to be advertised in the SIP probing requests.
		</para>
		<para>
		<emphasis>
			Default value is <quote>"sip:prober@localhost"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_from</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_from", "sip:pinger@192.168.2.10")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>probing_reply_codes</varname> (string)</title>
		<para>
		A comma separted list of SIP reply codes. The codes defined here
		will be considered as valid reply codes for probing messages,
		apart for 200.
		</para>
		<para>
		<emphasis>
			Default value is <quote>NULL</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>probing_reply_codes</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "probing_reply_codes", "501, 403")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>replicate_status_to</varname> (integer)</title>
		<para>
		A cluster ID for sharing (via BIN replication) the gateways/destination
		and carriers status changes. Whenever such a status is changes
		(following an MI command, a probing result, a script command), the
		module will replicate this status change to all the nodes in this
		given cluster. A value of 0 means that sending replication data is disabled.
		</para>
		<para>
		For more on how to define and populate a cluster (with OpenSIPS nodes)
		see the "clusterer" module.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>replicate_status_to</varname> parameter</title>
		<programlisting format="linespecific">
...
# replicate gw/carrier status with all OpenSIPS in cluster ID 9
modparam("drouting", "replicate_status_to", 9)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>accept_replicated_status</varname> (integer)</title>
		<para>
		A cluster ID for accepting replicated info about the change of gateway/carrier
		status from other OpenSIPS nodes from that cluster. A value of 0 means that accepting is disabled.
		</para>
		<para>
		<emphasis>
			Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>accept_replicated_status</varname> parameter</title>
		<programlisting format="linespecific">
...
# replicate gw/carrier status with all OpenSIPS in cluster ID 9
modparam("drouting", "replicate_status_to", 9)
# but do not accept incoming replication (just send, no receive)
modparam("drouting", "accept_replicated_status", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>use_domain</varname> (int)</title>
		<para>
			Flag to configure whether to use domain match when querying
			database for user's routing group.
		</para>
		<para>
		<emphasis>Default value is <quote>1</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>use_domain</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "use_domain", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_user_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the username is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>username</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_user_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_user_col", "user")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_domain_col</varname> (str)</title>
		<para>
		The name of the column in group db table where the domain is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>domain</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_domain_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_domain_col", "host")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>drg_grpid_col</varname> (str)</title>
		<para>
			The name of the column in group db table where the
			group id is stored.
		</para>
		<para>
		<emphasis>Default value is <quote>groupid</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>drg_grpid_col</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "drg_grpid_col", "grpid")
...
</programlisting>
		</example>
	</section>


	<section>
		<title><varname>use_partitions</varname> (int)</title>
		<para>
		Flag to configure whether to use partitions for routing. If this
		flag is set then the <varname>db_partitions_url</varname> and
		<varname>db_partitions_table</varname>
		variables become mandatory.
		</para>
		<para>
		<emphasis>Default value is <quote>0</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>use_partitions</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "use_partitions", 1)
...
</programlisting>
		</example>
	</section>

<section>
		<title><varname>db_partitions_url</varname> (int)</title>
		<para>
		The url to the database containing partition-specific
		information. (partition-specific information includes
		partition name, url to the database where information about
		the partition is preserved, the names of the tables in which it
		is preserved and the AVPs that can be accessed using the .cfg
		script). The <varname>use_partitions</varname> parameter
	    must be set to 1.
		</para>
		<para>
		<emphasis>Default value is <quote>"NULL"</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_partitions_url</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_partitions_url", "mysql://user:password@localhost/opensips_partitions")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>db_partitions_table</varname> (int)</title>
		<para>
		The name of the table containing partition definitions. To be
		used with <varname>use_partitions</varname> and <varname>db_partitions_url</varname>.
		</para>
		<para>
		<emphasis>Default value is <quote>dr_partitions</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>db_partitions_table</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "db_partitions_table", "partition_defs")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>partition_id_pvar</varname> (pvar)</title>
		<para>
			Variable which will store the name of the name partition when
			<emphasis>wildcard(*)</emphasis> operatior is used.
			<emphasis>Use_partitions</emphasis> must be set in order to
			use this parameter.
		</para>
		<para>
			NOTE: The variable must be WRITABLE!
		</para>
		<para>
		<emphasis>Default value is <quote>null(not used)</quote>.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>partition_id_pvar</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("drouting", "partition_id_pvar", "$var(matched_partition)")
...
</programlisting>
		</example>
	</section>



</section>

<section>
	<title>Exported Functions</title>
	<section>
		<title>
		<function moreinfo="none">do_routing([part_and_or_groupID], [flags], [gw_whitelist], [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger routing of the message according to the
		rules in the database table and the configured parameters.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> to 1 the 
		<emphasis role='bold'>part_or_groupID</emphasis> parameter becomes 
		mandatory.
		</para>
		<para>
		All parameters are optional. Any of them may be ignored, provided
		the necessary separation marks "," are properly placed.
		</para>
		<itemizedlist>
		<listitem>
			<para>
			<emphasis role='bold'>part_and_or_groupID</emphasis> - 
			Specifies the group of the caller for routing purposes. 
			Depending on the value of the 
			<varname>use_partitions</varname> parameter, it contains:
			</para>
			<itemizedlist>
			<listitem>
				<para>
				the routing group the caller belongs to if 
				<varname>use_partitions</varname> is 0 - this may be a statical
				numerical value or a variable (value must be numerical type, 
				string types are ignored!). If none specified the function will
				automatically try to query the dr_group table to get this 
				information
				</para>
			</listitem>
			<listitem>
				<para>
				the partition and routing group the caller belongs to, the 
				format is: "partition':'[groupID]" if 
				<varname>use_partitions</varname> parameter is 1 - both the 
				partition name and the groupId may be statical values or AVP 
				specifications. If no group is specified the function will
				try to query the dr_group table for the given partition to get
				this information. If <emphasis>* (wildcard)</emphasis> 
				operator is used all partitions shall be checked.
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>flags</emphasis> - Controls the behavior 
			of the function. Possible flags are:
			</para>
			<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>W</emphasis> - Instead of using the 
				destination (from the rule definition) in the given order, 
				sort them based on their weight.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>F</emphasis> - Enable rule fallback; 
				normally the engine is using a single rule for routing a call;
				by setting this flag, the engine will fallback and use
				rules with less priority or shorter prefix when all the
				destination from the current rules failed.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>L</emphasis> - Do strict length matching
				over the prefix - actually DR engine will do full number 
				matching and not prefix matching anymore.
				</para>
			</listitem>
			<listitem>
				<para>
				<emphasis role='bold'>C</emphasis> - Only check if the dialed
				number matches any routing rule, without loading / applying any
				routing info (no GW is set, the RURI is not altered)
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>gw_whitelist</emphasis> - a comma separated
			white list of gateways. This will force routing over, at most, this
			list of carriers or gateways (in other words, the whitelist
			will be intersected with the results of the search through the
			rules).
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>rule_attrs_pvar</emphasis> (output, 
			optional)- a writable variable which will be populated 
			with the attributes of the matched dynamic routing rule.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
			a writable variable which will be populated with
			the attributes of the matched gateway.
			</para>
		</listitem>
		<listitem>
			<para>
			<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, 
			optional) - a writable variable which will be populated with 
			the attributes of the matched carrier.
			</para>
		</listitem>
		</itemizedlist>

		<example>
		<title><function>do_routing</function> usage</title>
		<programlisting format="linespecific">
...
# all groups, sort on order, <varname>use_partitions</varname> is 0
do_routing();
...
# all groups, sort on order, <varname>use_partitions</varname> is 1, route by partition named "part"
do_routing("part:");
...
# group id 0, sort on order, <varname>use_partitions</varname> is 0
do_routing("0");
...
# group id 0, sort on order, <varname>use_partitions</varname> is 1, route by partition named "part"
do_routing("part:0");
...
# group id from $var(id), sort on order, <varname>use_partitions</varname> is 0
do_routing("$var(id)");
...
# all groups, sort on weights, <varname>use_partitions</varname> is 0
do_routing("", "W");
...
# all groups, <varname>use_partitions</varname> is 1, partition and group supplied by AVPs, do strict length matching
do_routing("$avp(partition):$avp(grp)","L")
...
# group id 2, sort on order, fallback rule and also return the gateway attributes
do_routing("2", "F", , , "$var(gw_attributes)");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">route_to_carrier(part_and_or_carrier_id, [gw_attrs_pvar], [carrier_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given carrier. In this case
		the routing is not done prefix based, but carrier based (call will be
		sent to the GWs of that carrier, based on carrier policy).
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE..
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must supply
		the partition in which the carrier has been defined.
		</para>
		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>part_and_or_carrier_id </emphasis> (mandatory):
					</para>
					<itemizedlist>
						<listitem>
							<para>
								the ID (name) of the carrier to be used, if <varname>use_partitions</varname>
								parameter is 0; variables are accepted.
							</para>
						</listitem>
						<listitem>
							<para>
								the partition and carrier to be used, if <varname>use_partitions</varname> parameter
								is 1. The format is "partition_name':'carrierId"; variables are accepted.
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the currently matched gateway of this carrier.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, optional)
					- a writable variable which will be populated with the attributes
					of this carrier.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_carrier</function> usage when <varname>use_partitions</varname>
		parameter is 0</title>
		<programlisting format="linespecific">
...
if ( route_to_carrier("my_top_carrier", , "$var(carrier_att)") ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
</programlisting>
		</example>

	<example>
		<title><function>route_to_carrier</function> usage when <varname>use_partitions</varname>
		parameter is 1</title>
		<programlisting format="linespecific">
...
if ( route_to_carrier("my_partition:my_top_carrier", , "$var(carrier_att)") ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
<example>
		<title><function>route_to_carrier</function> usage when <varname>use_partitions</varname>
		parameter is 1 with variables</title>
		<programlisting format="linespecific">
...
if ( route_to_carrier("$var(my_partition):$var(carrierId)") ) {
	xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
	t_on_failure("next_gw");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">route_to_gw(gw_id, [gw_attrs_pvar])</function>
		</title>
		<para>
		Function to trigger the direct routing to a given gateway (or list of gateways).
		Attributes and per-gw processing will be available.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		If you set <varname>use_partitions</varname> parameter to 1 you must supply
		the partition in which the gateway has been defined.
		</para>
		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>gw_id </emphasis> (mandatory) - the list
					of gateways to be used.
					<itemizedlist>
						<listitem>
							<para>
								a comma separated list of gateway ID's to be used, if
								no <varname>use_partition</varname> parameter is 0. Pseudo-variables
								are accepted.
							</para>
						</listitem>
						<listitem>
							<para>
								the desired partition, followed by a comma separated list of gateway ID's
								from that partition to be used, if <varname>use_partition</varname> parameter
								is 1. The format is: "partition_name':'gwId1, gwId2, gwId3". Pseudo-variables
								are accepted.
							</para>
						</listitem>
					</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the currently matched gateway.
					</para>
				</listitem>
		</itemizedlist>
		</para>

		<example>
		<title><function>route_to_gw</function> usage when <varname>use_partition</varname>
		parameter is 0</title>
		<programlisting format="linespecific">
...
if ( route_to_gw("gw_europe") ) {
	t_relay();
	exit;
}
...
if ( route_to_gw("gw1,gw2,gw3", "$var(gw_attrs)") ) {
	xlog("Relaying to first gateway from our list - $var(gw_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>

		<example>
		<title><function>route_to_gw</function> usage when <varname>use_partition</varname>
		parameter is 1</title>
		<programlisting format="linespecific">
...
if ( route_to_gw("my_partition:gw_europe") ) {
	t_relay();
	exit;
}
...
if ( route_to_gw("my_partition:gw1,gw2,gw3", "$var(gw_attrs)") ) {
	xlog("Relaying to first gateway from our list - $var(gw_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">use_next_gw([partition','] [rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar])/next_routing()</function>
		</title>
		<para>
		The function takes the next available destination (set by do_routing,
		as alternative destinations) and pushes it into the RURI. Note that the
		function just sets the RURI (nothing more).
		</para>
		<para>
		If a new RURI is set, the used destination is removed from the
		pending set of alternative destinations.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and LOCAL_ROUTE.
		</para>
		<para>
		The function returns true only if a new RURI was set. False
		is returned is no other alternative destinations are found or in case
		of an internal processing error. It may take the following optional parameters:
		</para>
		<para>
			If you set <varname>use_partitions</varname> parameter to 1 you must supply
			the partition (the partition becomes mandatory) in which the gateways have been defined.
		</para>
		<para>
		<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (mandatory if <varname>use_partitions
					</varname> parameter is 1, otherwise it will be omitted altogether) It is
					the partition in which the gateways have been defined.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>rule_attrs_pvar </emphasis> (output, optional) - a writable
					variable which will be populated with the attributes
					of the matched dynamic routing rule.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>carrier_attrs_pvar </emphasis> (output, optional) - a writable
					variable which will be populated with the attributes
					of the matched carrier.
					</para>
				</listitem>
		</itemizedlist>
		</para>


		<example>
		<title><function>use_next_gw</function> usage</title>
		<programlisting format="linespecific">
...
if (use_next_gw()) {
	t_relay();
	exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw(, , "$var(carrier_attrs)")) {
	xlog("Carrier attributes of current gateway: $var(carrier_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>

		<example>
		<title><function>use_next_gw</function> usage when <varname>use_partition</varname>
		parameter is 1</title>
		<programlisting format="linespecific">
...
if (use_next_gw("my_partition")) {
	t_relay();
	exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw("my_partition", , "$var(carrier_attrs)")) {
	xlog("Carrier attributes of current gateway: $var(carrier_attrs)\n");
	t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">goes_to_gw([partition','] [type], [flags], [gw_attrs_pvar])</function>
		</title>
		<para>
		Function returns true if the destination of the current request
		(destination URI or Request URI) points (as IP) to one of the gateways.
		There no DNS lookups done if the domain part of the URI is not an IP.
		</para>
		<para>
		This function does not change anything in the message.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE, BRANCH_ROUTE
		and LOCAL_ROUTE.
		</para>
		<para>
			If you set <varname>use_partitions</varname> parameter to 1 you must supply
			the partition (the partition becomes mandatory) in which the gateways have been defined.
		</para>
		<para>
			If <varname>use_partitions</varname> parameter is 0
			all parameters are optional. Any of them may be ignored, provided
			the necessary separation marks "," are properly placed.
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (mandatory if <varname>use_partitions
					</varname> parameter is 1, otherwise it will be omitted altogether) - the name
					of the partition containing the gateway/destination to be checked.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination
					type to be checked; when omitting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					(in a given partition if <varname>use_partition</varname> parameter is 1; if
					<varname>use_partitions</varname> is 1 the partition being mandatory at this
					point, it is not possible to do matching against all the partitions)
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the
							gateway id into gw_id_avp AVP
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port
							number during matching
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>goes_to_gw</function> usage when <varname>use_partitions</varname> parameter is 0</title>
		<programlisting format="linespecific">
...
if (goes_to_gw("1", , "$var(gw_attrs)")) {
	sl_send_reply("403","Forbidden");
	exit;
}
...
</programlisting>
		</example>
	<example>
	<title><function>goes_to_gw</function> usage, when <varname>use_partitions</varname> parameter is 1</title>
		<programlisting format="linespecific">
...
if (goes_to_gw("my_partition", "1", , "$var(gw_attrs)")) {
	sl_send_reply("403","Forbidden");
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">is_from_gw([partition','] [type], [flag], [gw_attrs_pvar])</function>
		</title>
		<para>
		The function checks if the sender of the message (its source IP)
		is a gateway from a certain group.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE
		and ONREPLY_ROUTE.
		</para>
		<para>
			If you set <varname>use_partitions</varname> parameter to 1 you must supply
			the partition (the partition becomes mandatory) in which the gateways have been defined.
		</para>
		<para>
			If <varname>use_partitions</varname> parameter is 0
			all parameters are optional. Any of them may be ignored, provided
			the necessary separation marks "," are properly placed.
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (mandatory if <varname>use_partitions
					</varname> parameter is 1, otherwise it will be omitted altogether) - Partition
					containing the destination/gw to be checked. If <emphasis>*(wildcard)</emphasis>
					operator is used all partitions shall be checked.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination
					type to be checked; when omitting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the
							gateway id into gw_id_avp AVP
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port
							number during matching
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>is_from_gw</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
...
if (is_from_gw("3","1") {
}
...
</programlisting>
		</example>

		<example>
		<title><function>is_from_gw</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
...
if (is_from_gw("my_partition","3","1") {
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">dr_is_gw([partition,] src_avp, [type], [flag], [gw_attrs_pvar])</function>
		</title>
		<para>
		The function checks if the ip address in pvar src_pv is a gateway
		from a certain group.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE, FAILURE_ROUTE,
		BRANCH_ROUTE, LOCAL_ROUTE, STARTUP_ROUTE, TIMER_ROUTE and EVENT_ROUTE.
		</para>
		<para>
			If you set <varname>use_partitions</varname> parameter to 1 you must supply
			the partition (the partition becomes mandatory) in which the gateways have been defined.
		</para>
		<para>
			Meaning of the parameters is as follows:
			<itemizedlist>
				<listitem>
					<para>
					<emphasis role='bold'>partition</emphasis> (mandatory if <varname>use_partitions
					</varname> parameter is 1, otherwise it will be omitted altogether) - Partition
					containing the destinations/gateways to be checked.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>src_avp</emphasis> (mandatory) - avp containing a SIP URI.
					Does not support other OpenSIPS variables.
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>type</emphasis> (optional) - GW/destination
					type to be checked; when omitting this parameter or specifying
					a negative value i.e. "-1", matching will be done against all groups
					</para>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>flags</emphasis> (optional) - what operations
					should be performed when a GW matches:
					</para>
					<itemizedlist>
						<listitem>
							<para>
							<emphasis role='bold'>'s'</emphasis> (Strip) - apply to the
							username of RURI the strip defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'p'</emphasis> (Prefix) - apply to the
							username of RURI the prefix defined by the GW
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'i'</emphasis> (Gateway ID) - return the gateway id into gw_id_avp pvar
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'n'</emphasis> (Ignore port) - ignores port number
							</para>
						</listitem>
						<listitem>
							<para>
							<emphasis role='bold'>'c'</emphasis> (Carrier ID) - return the
							carrier id into carrier_id_avp AVP
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
					<emphasis role='bold'>gw_attrs_pvar</emphasis> (output, optional)
					- a writable variable which will be populated with
					the attributes of the matched gateway.
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<example>
		<title><function>dr_is_gw</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
...
if (dr_is_gw("$avp(uac)","3") {
}
...
</programlisting>
		</example>
		<example>
		<title><function>dr_is_gw</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
...
if (dr_is_gw("my_partition","$avp(uac)","3") {
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">dr_disable()</function>
		</title>
		<para>
		Marks as disabled the last destination that was used for the current
		call. The disabling done via this function will prevent the
		destination to be used for usage from now on. The probing mechanism
		can re-enable this peer (see the probing section in the beginning)
		</para>
		<para>
		This function can be used from REQUEST_ROUTE and FAILURE_ROUTE.
		</para>
		<para>
			If you set <varname>use_partitions</varname> parameter to 1 you must supply
			the partition (the partition becomes mandatory) in which the gateway to be
			disabled is defined.
		</para>
		<itemizedlist>
			<listitem>
				<para>
				<emphasis role='bold'>partition</emphasis> (mandatory if <varname>use_partitions
				</varname> parameter is 1, otherwise it will be omitted altogether) - Partition
					containing the destination/gateway to be disabled.
				</para>
			</listitem>
		</itemizedlist>
		<example>
		<title><function>dr_disable()</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
	dr_disable();

}

...
</programlisting>
		</example>
		<example>
		<title><function>dr_disable()</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
	dr_disable("my_partition");

}

...
</programlisting>
		</example>
	</section>
</section>


<section>
	<title>Exported MI Functions</title>
	<section>
		<title>
		<function moreinfo="none">dr_reload</function>
		</title>
		<para>
		Command to reload routing rules from database. If <varname>use_partitions</varname> is set to 1
		you can reload just a partition given a parameter, if no parameter is supplied then all the
		partitions will be reloaded.
		</para>
		<para>
			If <varname>use_partitions</varname> is 0 it takes no parameter.
		</para>

		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_reload:fifo_reply
		partition_name (optional)
		_empty_line_
		</programlisting>
	</section>

	<section>
		<title><varname>dr_gw_status</varname></title>
		<para>
		Gets or sets the status (enabled or disabled) of a gateway. The
		function may take from 0 to 3 parameters.
		<itemizedlist>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 0 - if no parameter
				is provided, it will list all
				gateways along with their status. If one parameter is provided, that
				must be the id of a gateway and the function will return the status
				of that gateway. If 2 parameters are provided, first must be the ID of
				the ID of a GW and the second must be the new status to be forced for
				that GW (0 - disable, 1 - enable).
				</para>
			</listitem>
			<listitem>
				<para>
				if <varname>use_partitions</varname> is set to 1 - the first parameter
				must be the partition (the partition is mandatory). If just one parameter
				is provided it will the display the statuses of all the gateways in the
				given partition. If two parameters are provided,
				the first must be the partition, and the second must be the gateway Id. If three
				parameters are provided, the first must be the partition, the second must be the gateway
				and the third will be the new status to be forced for tat GW (0 - disable, 1 - enable)
				</para>
			</listitem>
		</itemizedlist>
		</para>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_gw_status:_reply_fifo_file_
		partition_name (mandatory if <varname>use_partitions</varname> is 1, otherwise will be omitted altogether)
		GW_id
		status (optional)
		_empty_line_
		</programlisting>
		<example>
		<title><function>dr_gw_status</function> usage when <varname>use_partitions</varname> is set to 0</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_gw_status 2
State:: Active
$ ./opensipsctl fifo dr_gw_status 2 0
$ ./opensipsctl fifo dr_gw_status 2
Enabled:: Disabled MI
$ ./opensipsctl fifo dr_gw_status 3
Enabled:: Inactive
</programlisting>
		</example>

		<example>
		<title><function>dr_gw_status</function> usage when <varname>use_partitions</varname>is set to 1</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_gw_status part_1 my_gw
State:: Active
$ ./opensipsctl fifo dr_gw_status my_partition 3 0
$ ./opensipsctl fifo dr_gw_status partition7 dsbl_gw 2
Enabled:: Disabled MI
$ ./opensipsctl fifo dr_gw_status partition8 gw3
Enabled:: Inactive
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_carrier_status</varname></title>
		<para>
		Gets or sets the status (enabled or disabled) of a carrier. The
		function may take from 0 to 3 parameters.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 - if no parameter
					is provided it will list all the carriers along with their status. If
					one parameter is provided, that must be the id of carrier and the function
					will return the status of that carrier. If 2 parameters are provided, first
					must be the Id of a carrier and the second must be the new status to be
					forced for that carrier
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1 - the first parameter
					must be the partition (the partition becomes mandatory). If one parameter
					is supplied, it will be the partition, and it will display the statuses
					of the carriers contained in that partition. If two parameters are supplied,
					the second must be the carrierId, and the command will display the status
					of the selected carrier. If three parameters are supplied, the first two
					will be the partition name and the carrierId while the third parameter will be
					the new status to be forced for that carrier.
				</para>
			</listitem>
		</itemizedlist>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_carrier_status:_reply_fifo_file_
		partition_name (mandatory if <varname>use_partition</varname> is 1, otherwise it will be omitted)
		carrier_id
		status (optional)
		_empty_line_
		</programlisting>
		<example>
		<title><function>dr_carrier_status</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: no
$ ./opensipsctl fifo dr_carrier_status CR1 1
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: yes
</programlisting>
		</example>
		<example>
		<title><function>dr_carrier_status</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_carrier_status my_partition CR1
Enabled:: no
$ ./opensipsctl fifo dr_carrier_status partition_1 CR1 1
$ ./opensipsctl fifo dr_carrier_status partition_3 CR1
Enabled:: yes
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_reload_status</varname></title>
		<para>
			Gets the time of the last reload for any partition. The function
			may take at most one parameter.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 - the function
					doesn't receive any parameter. It will list the date of the
					last reload for the default (and only) partition.
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1 - if no parameter
					is supplied it will list the time of the last update for every
					partition. If one parameter is supplied, then this must be the
					partition name, and the function will list the time of the last
					reload for that given partition.
				</para>
			</listitem>
		</itemizedlist>
		<para>
		MI FIFO Command Format:
		</para>
		<programlisting  format="linespecific">
		:dr_reload_status:_reply_fifo_file_
		partition_name (if <varname>use_partition</varname> is 1 it may be omitted, but if <varname>use_partition</varname>
is 0 it must be omitted)
		_empty_line_
		</programlisting>
		<example>
		<title><function>dr_reload_status</function> usage when <varname>use_partitions</varname> is 0</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_reload_status
Date:: Tue Aug 12 12:26:00 2014
</programlisting>
		</example>
		<example>
		<title><function>dr_reload_status</function> usage when <varname>use_partitions</varname> is 1</title>
		<programlisting format="linespecific">
$ ./opensipsctl fifo dr_reload_status
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
Partition:: part_2 Date=Tue Aug 12 12:24:13 2014
$ ./opensipsctl fifo dr_reload_status part_test
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>dr_number_routing</varname></title>
		<para>
			Gets the matched prefix along with the  list of the gateways / carriers to which a number
			would be routed when using the do_routing function
		</para>
		<itemizedlist>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 1 the function
					will have 3 parameters:
					<itemizedlist>
						<listitem>
							partition name
						</listitem>
						<listitem>
							group id - the group id of the rules to check against
						</listitem>
						<listitem>
							number - the number to test against
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					if <varname>use_partition</varname> is set to 0 the function will have 2 parameters:
					<itemizedlist>
						<listitem>
							group id - the group id of the rules to check against
						</listitem>
						<listitem>
							number - the number to test against
						</listitem>
					</itemizedlist>
				</para>
			</listitem>
		</itemizedlist>
		<para> Note: The group id may be omitted - just as with the do_routing function.</para>
	</section>

</section>

<section>
	<title>Exported Events</title>
	<section>
		<title>
		<function moreinfo="none">E_DROUTING_STATUS</function>
		</title>
		<para>
			This event is raised when the module changes the state of a gateway,
			either through an MI command, probing or script function.
		</para>
		<para>Parameters:</para>
		<itemizedlist>
			<listitem><para>
				<emphasis>partition</emphasis> - the name of the partition.
			</para></listitem>
			<listitem><para>
				<emphasis>gwid</emphasis> - the gateway identifier.
			</para></listitem>
			<listitem><para>
				<emphasis>address</emphasis> - the address of the gateway.
			</para></listitem>
			<listitem><para>
				<emphasis>status</emphasis> - <emphasis>disabled MI</emphasis> if
				the gateway was disabled using MI commands,
				<emphasis>probing</emphasis> if the gateway is being pinged,
				<emphasis>inactive</emphasis> if it was disabled from the script or
				<emphasis>active</emphasis> if the gateway is enabled.
			</para></listitem>
		</itemizedlist>
	</section>
</section>


<section>
	<title>Installation</title>
	<para>
	The module requires 4 tables in the OpenSIPS database: dr_groups,
	dr_gateways, dr_carriers, dr_rules. The SQL syntax to create them can be
	found in the drouting-create.sql script, located in the database directories
	of the opensips/scripts folder. You can also find the complete
	database documentation on the project webpage, &osipsdbdocslink;.
	</para>
</section>

</chapter>

