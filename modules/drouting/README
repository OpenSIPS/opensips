Dynamic Routing Module

Bogdan-Andrei Iancu

   www.opensips-solutions.com

Edited by

Bogdan-Andrei Iancu

Edited by

Anca-Maria Vamanu

   Copyright © 2005-2008 Voice Sistem SRL

   Copyright © 2009-2012 www.opensips-solutions.com
   Revision History
   Revision $Revision: 8834 $ $Date$
     __________________________________________________________

   Table of Contents

   1. Admin Guide

        1.1. Overview

              1.1.1. Introduction
              1.1.2. Features
              1.1.3. Performance
              1.1.4. Dynamic Routing Concepts
              1.1.5. Routing Rule Processing
              1.1.6. Probing and Disabling destinations

        1.2. Dependencies

              1.2.1. OpenSIPS Modules
              1.2.2. External Libraries or Applications

        1.3. Exported Parameters

              1.3.1. db_url(str)
              1.3.2. drd_table(str)
              1.3.3. drr_table(str)
              1.3.4. drg_table(str)
              1.3.5. drc_table(str)
              1.3.6. ruri_avp (str)
              1.3.7. gw_id_avp (str)
              1.3.8. gw_priprefix_avp (str)
              1.3.9. rule_id_avp (str)
              1.3.10. rule_prefix_avp (str)
              1.3.11. carrier_id_avp (str)
              1.3.12. gw_sock_avp (str)
              1.3.13. gw_attrs_avp (str)
              1.3.14. rule_attrs_avp (str)
              1.3.15. define_blacklist (str)
              1.3.16. default_group (int)
              1.3.17. force_dns (int)
              1.3.18. persistent_state (int)
              1.3.19. no_concurrent_reload (int)
              1.3.20. probing_interval (integer)
              1.3.21. probing_method (string)
              1.3.22. probing_from (string)
              1.3.23. probing_reply_codes (string)
              1.3.24. use_domain (int)
              1.3.25. drg_user_col (str)
              1.3.26. drg_domain_col (str)
              1.3.27. drg_grpid_col (str)
              1.3.28. use_partitions (int)
              1.3.29. db_partitions_url (int)
              1.3.30. db_partitions_table (int)
              1.3.31. partition_id_pvar (pvar)

        1.4. Exported Functions

              1.4.1. do_routing([part_and_or_groupID], [flags],
                      [gw_whitelist], [rule_attrs_pvar],
                      [gw_attrs_pvar], [carrier_attrs_pvar])

              1.4.2. route_to_carrier(part_and_or_carrier_id,
                      [gw_attrs_pvar], [carrier_attrs_pvar])

              1.4.3. route_to_gw(gw_id, [gw_attrs_pvar])
              1.4.4. use_next_gw([partition','] [rule_attrs_pvar],
                      [gw_attrs_pvar],
                      [carrier_attrs_pvar])/next_routing()

              1.4.5. goes_to_gw([partition','] [type], [flags],
                      [gw_attrs_pvar])

              1.4.6. is_from_gw([partition','] [type], [flag],
                      [gw_attrs_pvar])

              1.4.7. dr_is_gw([partition,] src_avp, [type],
                      [flag], [gw_attrs_pvar])

              1.4.8. dr_disable()

        1.5. Exported MI Functions

              1.5.1. dr_reload
              1.5.2. dr_gw_status
              1.5.3. dr_carrier_status
              1.5.4. dr_reload_status
              1.5.5. dr_number_routing

        1.6. Exported Events

              1.6.1. E_DROUTING_STATUS

        1.7. Installation

   2. Developer Guide

   List of Examples

   1.1. Set db_url parameter
   1.2. Set drd_table parameter
   1.3. Set drr_table parameter
   1.4. Set drg_table parameter
   1.5. Set drc_table parameter
   1.6. Set ruri_avp parameter
   1.7. Set gw_id_avp parameter
   1.8. Set gw_priprefix_avp parameter
   1.9. Set rule_id_avp parameter
   1.10. Set rule_prefix_avp parameter
   1.11. Set carrier_id_avp parameter
   1.12. Set gw_sock_avp parameter
   1.13. Set gw_attrs_avp parameter
   1.14. Set rule_attrs_avp parameter
   1.15. Set define_blacklist parameter
   1.16. Set default_group parameter
   1.17. Set force_dns parameter
   1.18. Set the persistent_state parameter
   1.19. Set no_concurrent_reload parameter
   1.20. Set probing_interval parameter
   1.21. Set probing_method parameter
   1.22. Set probing_from parameter
   1.23. Set probing_reply_codes parameter
   1.24. Set use_domain parameter
   1.25. Set drg_user_col parameter
   1.26. Set drg_domain_col parameter
   1.27. Set drg_grpid_col parameter
   1.28. Set use_partitions parameter
   1.29. Set db_partitions_url parameter
   1.30. Set db_partitions_table parameter
   1.31. Set partition_id_pvar parameter
   1.32. do_routing usage
   1.33. route_to_carrier usage when use_partitions parameter is 0
   1.34. route_to_carrier usage when use_partitions parameter is 1
   1.35. route_to_carrier usage when use_partitions parameter is 1
          with pseudovariables

   1.36. route_to_gw usage when use_partition parameter is 0
   1.37. route_to_gw usage when use_partition parameter is 1
   1.38. use_next_gw usage
   1.39. use_next_gw usage when use_partition parameter is 1
   1.40. goes_to_gw usage when use_partitions parameter is 0
   1.41. goes_to_gw usage, when use_partitions parameter is 1
   1.42. is_from_gw usage when use_partitions is 0
   1.43. is_from_gw usage when use_partitions is 1
   1.44. dr_is_gw usage when use_partitions is 0
   1.45. dr_is_gw usage when use_partitions is 1
   1.46. dr_disable() usage when use_partitions is 0
   1.47. dr_disable() usage when use_partitions is 1
   1.48. dr_gw_status usage when use_partitions is set to 0
   1.49. dr_gw_status usage when use_partitionsis set to 1
   1.50. dr_carrier_status usage when use_partitions is 0
   1.51. dr_carrier_status usage when use_partitions is 1
   1.52. dr_reload_status usage when use_partitions is 0
   1.53. dr_reload_status usage when use_partitions is 1

Chapter 1. Admin Guide

1.1. Overview

1.1.1. Introduction

   Dynamic Routing is a module for selecting (based on multiple
   criteria) the best gateway/destination to be used for
   delivering a certain call. Least Cost Routing (LCR) is a
   special case of dynamic routing - when the rules are ordered
   based on costs. Dynamic Routing comes with many features
   regarding routing rule selection:
     * prefix based
     * caller/group based
     * time based
     * priority based

   , processing :
     * stripping and prefixing
     * default rules
     * inbound and outbound processing
     * script route triggering

   and failure handling:
     * serial forking
     * weight based GW selection
     * random GW selection
     * GW probing for crashes

1.1.2. Features

   The dynamic routing implementation for OpenSIPS is designed
   with the following properties:
     * The routing info (destinations, carriers, rules, groups) is
       stored in a database and loaded into memory at start up
       time; reload at runtime via a Management Interface command.
     * weight-based or random selection of the destinations (from
       a rule or from a carrier), failure detection of gateways
       (with switching to next available gateway).
     * able to handle large volume of routing info (10M of rules)
       with minimal speed/time and memory consumption penalties
     * script integration - Pseudo-variable support in functions;
       scripting route triggering when rules are matched
     * bidirectional behavior - inbound and outbound processing
       (strip and prefixing when sending and receiving from a
       destination/GW)
     * blacklisting - the module allows definition of blacklists
       based on the destination IPs. This blacklists are to be
       used to prevent malicious forwarding to GWs (based on DNS
       lookups) when the script logic does none-GE forwarding
       (like foreign domains).
     * loading routing information from multiple databases - the
       gateways, rules, groups and carriers can be grouped by
       partitions, and each partition may be loaded from different
       databases/tables. This makes the routing process partition
       based. In order to be able to use a table from a partition,
       its name must be found in the "version" table belonging to
       the database defined in the partition's db_url.

1.1.3. Performance

   There were several tests performed regarding the performance of
   the module when dealing with a large number of routing rules.

   The tests were performed with a set of 383000 rules and
   measured:
     * time to load from DB
     * used shared memory

   The time to load was varying between 4 seconds and 8 seconds,
   depending of the caching of the DB client - the first load was
   the slowest (as the DB query hits the disk drive); the
   following are faster as data is already cached in the DB
   client. So technically speaking, the time to load (without the
   time to query which is DB type dependent) is ~4 seconds

   After loading the data into shared memory ~ 96M of memory were
   used exclusively for the DR data.

1.1.4. Dynamic Routing Concepts

   DR engine uses several concepts in order to define how the
   routing should be done (describing all the dependencies between
   destinations and routing rules).

1.1.4.1. Destination/Gateways

   These are the end SIP entities where actually the traffic needs
   to be sent after routing. They are stored in a table called
   “dr_gateways”. Gateway addresses are stored in a separate table
   because of the need to access them independent of Dynamic
   Routing processing (e.g., adding/ removing gateway PRI prefix
   before/after performing other operation -- receiving/relaying
   to gateway).

   In DR, a gateway is defined by:
     * id (string)
     * SIP address (SIP URI)
     * type (number to allow to group GW based on purpose, like
       inbound, outbound, etc)
     * strip value (number of digits) from dialled number
     * prefix (string) to be added to dialled number
     * attributes (not used by DR engine, but only pushed to
       script level when routing to this GW)
     * probing mode (how the GW should be probed at SIP level -
       see the probing chapter)

   The Gateways are to be used from the routing rule or from the
   carrier definition. They are all the time referred by their ID.

1.1.4.2. Carriers

   The carrier concept is used if you need to group gateways in
   order to have a better control on how the GWs will be used by
   DR rules; like in what order the GWs will be used.

   Basically, a carrier is a set of gateways which have its own
   sorting algorithm and its own attribute string. They are by
   default defined in the “dr_carriers” table.

   In DR, a carrier is defined by:
     * id (string)
     * list of gateways with/without weights (string)
       (Ex:“gw1=10,gw4=10” or “gw1,gw2”
     * flags : 0x1 - use weight for sorting the list and not
       definition order; 0x2 - use only the first gateway from the
       carrier (depending on the sorting); 0x4 - disable the usage
       of this carrier
     * attributes (not used by DR engine, but only pushed to
       script level when routing to this carrier)

   The Carriers are to be used only from the routing rule
   definition. They are all the time referred by their ID.

1.1.4.3. Routing Rules

   These are the actual rules which control the routing. Using
   different criterias (prefix, time, priority, etc), they will
   decide to which gateways the call will be sent.

   Default name for the table storing rule definitions is
   “dr_rules”.

   In DR, a carrier is defined by:
     * group (list of numbers) - rules can be grouped (a rule may
       belong to multiple groups in the same time ) and you can
       use only a certain group at a point; like having a
       “premium” or “standard” or “interstate” or “intrastate”
       groups of rules to be used in different cases
     * prefix (string with digits only) - prefix to be used for
       matching this rule (longest prefix matching)
     * time validity (time recurrence string) - when this rule is
       valid from time point of view (see RFC 2445)
     * priority (number) - priority of the rule - higher value,
       higher priority (see rule section alg)
     * script route ID (string) - if defined, then execute the
       route with the specified ID when this rule is matched.
       That's it, a route which can be used to perform custom
       operations on message. NOTE that no modification is
       performed at signaling level and you must NOT do any
       signaling operations in that script route
     * list of GWs/carriers (string) - a comma separated list of
       gateways or carriers (defined by IDs) to be used for this
       rule; the carrier IDs are prefixed with “#” sign. For each
       ID (GW or carrier) you may specify a weight. For how this
       list will be interpreted (as order) see the rule selection
       section. Example of list: “gw1,gw4,#cr3” or
       “gw1=10,gw4=10,#cr3=80”
     * attributes (not used by DR engine, but only pushed to
       script level when this rule matched and been used)

   More on time recurrence:
     * A date-time expression that defines the time recurrence to
       be matched for current rule. Time recurrences are based
       closely on the recurring time intervals from the Internet
       Calendaring and Scheduling Core Object Specification
       (calendar COS), RFC 2445. The set of attributes used in
       routing rule specification is a subset of time recurrence
       attributes.
     * The value stored in database has the format of:
       <dtstart>|<duration>|<freq>|<until>|<interval>|<byday>|<bym
       onthday>|<byyearday>|<byweekno>|<bymonth>
     * When an attribute is not specified, the corresponding place
       must be left empty, whenever another attribute that follows
       in the list has to be specified.

1.1.5. Routing Rule Processing

   The module can be used to find out which is the best gateway to
   use for new calls terminated to PSTN. The algorithm to select
   the rule is as follows:
     * the module discovers the routing group of the originating
       user. This step is skipped if a routing group is passed
       from the script as parameter.
     * once the group is known, in the subset of the rules for
       this group the module looks for the one that matches the
       destination based on "prefix" column. The set of rules with
       the longest prefix is chosen. If no digit from the prefix
       matches, the default rules are used (rules with no prefix)
     * within the set of rules is applied the time criteria, and
       the rule which has the highest priority and matches the
       time criteria is selected to drive the routing.
     * Once found the rule, it may contain a route ID to execute.
       If a certain flag is set, then the processing is stopped
       after executing the route block.
     * The rule must contain a chain of gateways and carriers. The
       module will execute serial forking for each address in the
       chain (ordering is either done by simply using the
       definition order or it may weight-based - weight selection
       must be enabled). The next address in chain is used only if
       the previously has failed.
     * With the right gateway address found, the prefix (PRI) of
       the gateway is added to the request URI and then the
       request is forwarded.

   If no rule is found to match the selection criteria an default
   action must be taken (e.g., error response sent back). If the
   gateway in the chain has no prefix the request is forwarded
   without adding any prefix to the request URI.

1.1.6. Probing and Disabling destinations

   The module has the capability to monitor the status of the
   destinations by doing SIP probing (sending SIP requests like
   OPTIONS).

   For each destination, you can configure what kind of probing
   should be done (probe_mode column):
     * (0) - no probing at all;
     * (1) - probing only when the destination is in disabled mode
       (disabling via MI command will completely stop the probing
       also). The destination will be automatically re-enabled
       when the probing will succeed next time;
     * (2) - probing all the time. If disabled, the destination
       will be automatically re-enabled when the probing will
       succeed next time;

   A destination can become disabled in two ways:
     * script detection - by calling from script the dr_disable()
       function after trying the destination. In this case, if
       probing mode for the destination is (1) or (2), the
       destination will be automatically re-enabled when the
       probing will succeed.
     * MI command - by calling the dr_gw_status MI command for
       disabling (on demand) the destination. If so, the probing
       and re-enabling of this destination will be completly
       disabled until you re-enable it again via MI command - this
       is designed to allow controlled and complete disabling of
       some destination during maintenance.

1.2. Dependencies

1.2.1. OpenSIPS Modules

   The following modules must be loaded before this module:
     * a database module.

     * tm module.

1.2.2. External Libraries or Applications

     * none.

1.3. Exported Parameters

1.3.1. db_url(str)

   The database url.

   Default value is “NULL”.

   Example 1.1. Set db_url parameter
...
modparam("drouting", "db_url",
        "mysql://opensips:opensipsrw@localhost/opensips")
...

1.3.2. drd_table(str)

   The name of the db table storing gateway addresses.

   Default value is “dr_gateways”.

   Example 1.2. Set drd_table parameter
...
modparam("drouting", "drd_table", "dr_gateways")
...

1.3.3. drr_table(str)

   The name of the db table storing routing rules.

   Default value is “dr_rules”.

   Example 1.3. Set drr_table parameter
...
modparam("drouting", "drr_table", "rules")
...

1.3.4. drg_table(str)

   The name of the db table storing groups.

   Default value is “dr_groups”.

   Example 1.4. Set drg_table parameter
...
modparam("drouting", "drg_table", "groups")
...

1.3.5. drc_table(str)

   The name of the db table storing definitions of the carriers
   that will be used directly by the routing rules.

   Default value is “dr_carriers”.

   Example 1.5. Set drc_table parameter
...
modparam("drouting", "drc_table", "my_dr_carriers")
...

1.3.6. ruri_avp (str)

   The name of the avp for storing Request URIs to be later used
   (alternative destiantions for the current one).

   Default value is “$avp(___dr_ruri__)” if use_partitions
   parameter is 0 or “$avp(___dr_ruri__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.6. Set ruri_avp parameter
...
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "ruri_avp", '$avp(33)')
...

1.3.7. gw_id_avp (str)

   The name of the avp for storing the id of the current selected
   gateway/destination - once a new destination is selected (via
   the use_next_gw() function), the AVP will be updated with the
   ID of the new selected gateway/destination.

   Default value is “$avp(___dr_gw_id__)” if use_partitions
   parameter is 0 or “$avp(___dr_gw_id__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.7. Set gw_id_avp parameter
...
modparam("drouting", "gw_id_avp", '$avp(gw_id)')
modparam("drouting", "gw_id_avp", '$avp(334)')
...

1.3.8. gw_priprefix_avp (str)

   The name of the avp for storing the PRI prefix of the current
   selected destination/gateway - once a new destination is
   selected (via the use_next_gw() function), the AVP will be
   updated with the PRI prefix of the new used destination.

   Default value is “NULL”.

   Example 1.8. Set gw_priprefix_avp parameter
...
modparam("drouting", "gw_priprefix_avp", '$avp(gw_priprefix)')
...

1.3.9. rule_id_avp (str)

   The name of the avp for storing the id of the current matched
   routing rule (see dr_rules table).

   Default value is “NULL”.

   Example 1.9. Set rule_id_avp parameter
...
modparam("drouting", "rule_id_avp", '$avp(rule_id)')
modparam("drouting", "rule_id_avp", '$avp(335)')
...

1.3.10. rule_prefix_avp (str)

   The actual prefix that matched the routing rule (the part from
   RURI username that matched the routing rule).

   Default value is “NULL”.

   Example 1.10. Set rule_prefix_avp parameter
...
modparam("drouting", "rule_prefix_avp", '$avp(dr_prefix)')
...

1.3.11. carrier_id_avp (str)

   AVP to be populate with the ID string for the carrier the
   current GW belongs to.

   Default value is “NULL”.

   Example 1.11. Set carrier_id_avp parameter
...
modparam("drouting", "carrier_id_avp", '$avp(carrier_id)')
...

1.3.12. gw_sock_avp (str)

   The name of the avp for storing sockets for alternative
   destinations defined by ruri_avp.

   Default value is “$avp(___dr_sock__)” if use_partitions
   parameter is 0 or “$avp(___dr_sock__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.12. Set gw_sock_avp parameter
...
modparam("drouting", "gw_sock_avp", '$avp(dr_sock)')
modparam("drouting", "gw_sock_avp", '$avp(77)')
...

1.3.13. gw_attrs_avp (str)

   The name of the avp for storing GW attrs in case they are
   requested at least once in the script.

   Default value is “$avp(___dr_gw_att__)” if use_partitions
   parameter is 0 or “$avp(___dr_gw_att__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.13. Set gw_attrs_avp parameter
...
modparam("drouting", "gw_attrs_avp", '$avp(dr_attrs_gw)')
modparam("drouting", "gw_attrs_avp", '$avp(11)')
...

1.3.14. rule_attrs_avp (str)

   The name of the avp for storing rule attrs in case they are
   requested at least once in the script.

   Default value is “$avp(___dr_ru_att__)” if use_partitions
   parameter is 0 or “$avp(___dr_ru_att__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.14. Set rule_attrs_avp parameter
...
modparam("drouting", "rule_attrs_avp", '$avp(dr_rule_attr)')
modparam("drouting", "rule_attrs_avp", '$avp(11)')
...

1.3.15. define_blacklist (str)

   Defines a blacklist based on a list of GW types - the list will
   contain the IPs (no port, all protocols) of the GWs with the
   specified types.

   Multiple instances of this param are allowed.

   Default value is “NULL”.

   Example 1.15. Set define_blacklist parameter
...
modparam("drouting", "define_blacklist", 'bl_name= 3,5,25,23')
modparam("drouting", "define_blacklist", 'list= 4,2')
...

1.3.16. default_group (int)

   Group to be used if the caller (FROM user) is not found in the
   GROUP table.

   Default value is “NONE”.

   Example 1.16. Set default_group parameter
...
modparam("drouting", "default_group", 4)
...

1.3.17. force_dns (int)

   Force DNS resolving of GW/destination names (if not IPs) during
   startup. If not enabled, the GW name will be blindly used
   during routing.

   Default value is “1 (enabled)”.

   Example 1.17. Set force_dns parameter
...
modparam("drouting", "force_dns", 0)
...

1.3.18. persistent_state (int)

   Specifies whether the state column should be loaded at startup
   and flushed during runtime or not.

   Default value is “1” (enabled).

   Example 1.18. Set the persistent_state parameter
...
# disable all DB operations with the state of a gateway
modparam("drouting", "persistent_state", 0)
...

1.3.19. no_concurrent_reload (int)

   If enabled, the module will not allow do run multiple dr_reload
   MI commands in parallel (with overlapping) Any new reload will
   be rejected (and discarded) while an existing reload is in
   progress.

   If you have a large routing set (millions of rules/prefixes),
   you should consider disabling concurrent reload as they will
   exhaust the shared memory (by reloading into memory, in the
   same time, multiple instances of routing data).

   Default value is “0 (disabled)”.

   Example 1.19. Set no_concurrent_reload parameter
...
# do not allow parallel reload operations
modparam("drouting", "no_concurrent_reload", 1)
...

1.3.20. probing_interval (integer)

   How often (in seconds) the probing of a destination should be
   done. If set to 0, the probing will be disabled as
   functionality (for all destinations)

   Default value is “30”.

   Example 1.20. Set probing_interval parameter
...
modparam("drouting", "probing_interval", 60)
...

1.3.21. probing_method (string)

   The SIP method to be used for the probing requests.

   Default value is “"OPTIONS"”.

   Example 1.21. Set probing_method parameter
...
modparam("drouting", "probing_method", "INFO")
...

1.3.22. probing_from (string)

   The FROM SIP URI to be advertised in the SIP probing requests.

   Default value is “"sip:prober@localhost"”.

   Example 1.22. Set probing_from parameter
...
modparam("drouting", "probing_from", "sip:pinger@192.168.2.10")
...

1.3.23. probing_reply_codes (string)

   A comma separted list of SIP reply codes. The codes defined
   here will be considered as valid reply codes for probing
   messages, apart for 200.

   Default value is “NULL”.

   Example 1.23. Set probing_reply_codes parameter
...
modparam("drouting", "probing_reply_codes", "501, 403")
...

1.3.24. use_domain (int)

   Flag to configure whether to use domain match when querying
   database for user's routing group.

   Default value is “1”.

   Example 1.24. Set use_domain parameter
...
modparam("drouting", "use_domain", 0)
...

1.3.25. drg_user_col (str)

   The name of the column in group db table where the username is
   stored.

   Default value is “username”.

   Example 1.25. Set drg_user_col parameter
...
modparam("drouting", "drg_user_col", "user")
...

1.3.26. drg_domain_col (str)

   The name of the column in group db table where the domain is
   stored.

   Default value is “domain”.

   Example 1.26. Set drg_domain_col parameter
...
modparam("drouting", "drg_domain_col", "host")
...

1.3.27. drg_grpid_col (str)

   The name of the column in group db table where the group id is
   stored.

   Default value is “groupid”.

   Example 1.27. Set drg_grpid_col parameter
...
modparam("drouting", "drg_grpid_col", "grpid")
...

1.3.28. use_partitions (int)

   Flag to configure whether to use partitions for routing. If
   this flag is set then the db_partitions_url and
   db_partitions_table variables become mandatory.

   Default value is “0”.

   Example 1.28. Set use_partitions parameter
...
modparam("drouting", "use_partitions", 1)
...

1.3.29. db_partitions_url (int)

   The url to the database containing partition-specific
   information. (partition-specific information includes partition
   name, url to the database where information about the partition
   is preserved, the names of the tables in which it is preserved
   and the AVPs that can be accessed using the .cfg script). The
   use_partitions parameter must be set to 1.

   Default value is “"NULL"”.

   Example 1.29. Set db_partitions_url parameter
...
modparam("drouting", "db_partitions_url", "mysql://user:password@localho
st/opensips_partitions")
...

1.3.30. db_partitions_table (int)

   The name of the table containing partition definitions. To be
   used with use_partitions and db_partitions_url.

   Default value is “dr_partitions”.

   Example 1.30. Set db_partitions_table parameter
...
modparam("drouting", "db_partitions_table", "partition_defs")
...

1.3.31. partition_id_pvar (pvar)

   Variable which will store the name of the name partition when
   wildcard(*) operatior is used. Use_partitions must be set in
   order to use this parameter.

   NOTE: The variable must be WRITABLE!

   Default value is “null(not used)”.

   Example 1.31. Set partition_id_pvar parameter
...
modparam("drouting", "partition_id_pvar", "$var(matched_partition)")
...

1.4. Exported Functions

1.4.1.  do_routing([part_and_or_groupID], [flags], [gw_whitelist],
[rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar])

   Function to trigger routing of the message according to the
   rules in the database table and the configured parameters.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and
   LOCAL_ROUTE.

   If you set use_partitions to 1 the part_or_groupID parameter
   becomes mandatory.

   All parameters are optional. Any of them may be ignored,
   provided the necessary separation marks "," are properly
   placed.
     * part_and_or_groupID - Specifies the group of the caller for
       routing purposes. Depending on the value of the
       use_partitions parameter, it contains:
          + the routing group the caller belongs to if
            use_partitions is 0 - this may be a statical numerical
            value or an AVP specification (value must be numerical
            type, string types are ignored!). If none specified
            the function will automatically try to query the
            dr_group table to get this information
          + the partition and routing group the caller belongs to,
            the format is: "partition':'[groupID]" if
            use_partitions parameter is 1 - both the partition
            name and the groupId may be statical values or AVP
            specifications. If no group is specified the function
            will try to query the dr_group table for the given
            partition to get this information. If * (wildcard)
            operator is used all partitions shall be checked.
     * flags - Controls the behavior of the function. Possible
       flags are:
          + W - Instead of using the destination (from the rule
            definition) in the given order, sort them based on
            their weight.
          + F - Enable rule fallback; normally the engine is using
            a single rule for routing a call; by setting this
            flag, the engine will fallback and use rules with less
            priority or shorter prefix when all the destination
            from the current rules failed.
          + L - Do strict length matching over the prefix -
            actually DR engine will do full number matching and
            not prefix matching anymore.
          + C - Only check if the dialed number matches any
            routing rule, without loading / applying any routing
            info (no GW is set, the RURI is not altered)
     * gw_whitelist - a comma separated white list of gateways.
       This will force routing over, at most, this list of
       carriers or gateways (in other words, the whitelist will be
       intersected with the results of the search through the
       rules).
     * rule_attrs_pvar (output, optional)- a writable
       pseudo-variable which will be populated with the attributes
       of the matched dynamic routing rule.
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched gateway.
     * carrier_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched carrier.

   Example 1.32. do_routing usage
...
# all groups, sort on order, use_partitions is 0
do_routing();
...
# all groups, sort on order, use_partitions is 1, route by partition nam
ed "part"
do_routing("part:");
...
# group id 0, sort on order, use_partitions is 0
do_routing("0");
...
# group id 0, sort on order, use_partitions is 1, route by partition nam
ed "part"
do_routing("part:0");
...
# group id from $avp(10), sort on order, use_partitions is 0
do_routing("$avp(10)");
...
# all groups, sort on weights, use_partitions is 0
do_routing("", "W");
...
# all groups, use_partitions is 1, partition and group supplied by AVPs,
 do strict length matching
do_routing("$avp(partition):$avp(grp)","L")
...
# group id 2, sort on order, fallback rule and also return the gateway a
ttributes
do_routing("2", "F", , , "$var(gw_attributes)");
...

1.4.2.  route_to_carrier(part_and_or_carrier_id, [gw_attrs_pvar],
[carrier_attrs_pvar])

   Function to trigger the direct routing to a given carrier. In
   this case the routing is not done prefix based, but carrier
   based (call will be sent to the GWs of that carrier, based on
   carrier policy).

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and
   LOCAL_ROUTE..

   If you set use_partitions parameter to 1 you must supply the
   partition in which the carrier has been defined.

     * part_and_or_carrier_id (mandatory):
          + the ID (name) of the carrier to be used, if
            use_partitions parameter is 0; pseudo-variables are
            accepted.
          + the partition and carrier to be used, if
            use_partitions parameter is 1. The format is
            "partition_name':'carrierId"; pseudo-variables are
            accepted.
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the currently matched gateway of this carrier.
     * carrier_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of this carrier.

   Example 1.33. route_to_carrier usage when use_partitions
   parameter is 0
...
if ( route_to_carrier("my_top_carrier", , "$var(carrier_att)") ) {
        xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...

   Example 1.34. route_to_carrier usage when use_partitions
   parameter is 1
...
if ( route_to_carrier("my_partition:my_top_carrier", , "$var(carrier_att
)") ) {
        xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...

   Example 1.35. route_to_carrier usage when use_partitions
   parameter is 1 with pseudovariables
...
if ( route_to_carrier("$var(my_partition):$var(carrierId)") ) {
        xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...

1.4.3.  route_to_gw(gw_id, [gw_attrs_pvar])

   Function to trigger the direct routing to a given gateway (or
   list of gateways). Attributes and per-gw processing will be
   available.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and
   LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   partition in which the gateway has been defined.

     * gw_id (mandatory) - the list of gateways to be used.
          + a comma separated list of gateway ID's to be used, if
            no use_partition parameter is 0. Pseudo-variables are
            accepted.
          + the desired partition, followed by a comma separated
            list of gateway ID's from that partition to be used,
            if use_partition parameter is 1. The format is:
            "partition_name':'gwId1, gwId2, gwId3".
            Pseudo-variables are accepted.
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the currently matched gateway.

   Example 1.36. route_to_gw usage when use_partition parameter is
   0
...
if ( route_to_gw("gw_europe") ) {
        t_relay();
        exit;
}
...
if ( route_to_gw("gw1,gw2,gw3", "$var(gw_attrs)") ) {
        xlog("Relaying to first gateway from our list - $var(gw_attrs)\n
");
        t_relay();
        exit;
}
...

   Example 1.37. route_to_gw usage when use_partition parameter is
   1
...
if ( route_to_gw("my_partition:gw_europe") ) {
        t_relay();
        exit;
}
...
if ( route_to_gw("my_partition:gw1,gw2,gw3", "$var(gw_attrs)") ) {
        xlog("Relaying to first gateway from our list - $var(gw_attrs)\n
");
        t_relay();
        exit;
}
...

1.4.4.  use_next_gw([partition','] [rule_attrs_pvar],
[gw_attrs_pvar], [carrier_attrs_pvar])/next_routing()

   The function takes the next available destination (set by
   do_routing, as alternative destinations) and pushes it into the
   RURI. Note that the function just sets the RURI (nothing more).

   If a new RURI is set, the used destination is removed from the
   pending set of alternative destinations.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and
   LOCAL_ROUTE.

   The function returns true only if a new RURI was set. False is
   returned is no other alternative destinations are found or in
   case of an internal processing error. It may take the following
   optional parameters:

   If you set use_partitions parameter to 1 you must supply the
   partition (the partition becomes mandatory) in which the
   gateways have been defined.

     * partition (mandatory if use_partitions parameter is 1,
       otherwise it will be omitted altogether) It is the
       partition in which the gateways have been defined.
     * rule_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched dynamic routing rule.
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched gateway.
     * carrier_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched carrier.

   Example 1.38. use_next_gw usage
...
if (use_next_gw()) {
        t_relay();
        exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw(, , "$var(carrier_attrs)")) {
        xlog("Carrier attributes of current gateway: $var(carrier_attrs)
\n");
        t_relay();
        exit;
}
...

   Example 1.39. use_next_gw usage when use_partition parameter is
   1
...
if (use_next_gw("my_partition")) {
        t_relay();
        exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw("my_partition", , "$var(carrier_attrs)")) {
        xlog("Carrier attributes of current gateway: $var(carrier_attrs)
\n");
        t_relay();
        exit;
}
...

1.4.5.  goes_to_gw([partition','] [type], [flags], [gw_attrs_pvar])

   Function returns true if the destination of the current request
   (destination URI or Request URI) points (as IP) to one of the
   gateways. There no DNS lookups done if the domain part of the
   URI is not an IP.

   This function does not change anything in the message.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   partition (the partition becomes mandatory) in which the
   gateways have been defined.

   If use_partitions parameter is 0 all parameters are optional.
   Any of them may be ignored, provided the necessary separation
   marks "," are properly placed.
     * partition (mandatory if use_partitions parameter is 1,
       otherwise it will be omitted altogether) - the name of the
       partition containing the gateway/destination to be checked.
     * type (optional) - GW/destination type to be checked; when
       omitting this parameter or specifying a negative value i.e.
       "-1", matching will be done against all groups (in a given
       partition if use_partition parameter is 1; if
       use_partitions is 1 the partition being mandatory at this
       point, it is not possible to do matching against all the
       partitions)
     * flags (optional) - what operations should be performed when
       a GW matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp AVP
          + 'n' (Ignore port) - ignores port number during
            matching
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched gateway.

   Example 1.40. goes_to_gw usage when use_partitions parameter is
   0
...
if (goes_to_gw("1", , "$var(gw_attrs)")) {
        sl_send_reply("403","Forbidden");
        exit;
}
...

   Example 1.41. goes_to_gw usage, when use_partitions parameter
   is 1
...
if (goes_to_gw("my_partition", "1", , "$var(gw_attrs)")) {
        sl_send_reply("403","Forbidden");
        exit;
}
...

1.4.6.  is_from_gw([partition','] [type], [flag], [gw_attrs_pvar])

   The function checks if the sender of the message (its source
   IP) is a gateway from a certain group.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE and
   ONREPLY_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   partition (the partition becomes mandatory) in which the
   gateways have been defined.

   If use_partitions parameter is 0 all parameters are optional.
   Any of them may be ignored, provided the necessary separation
   marks "," are properly placed.
     * partition (mandatory if use_partitions parameter is 1,
       otherwise it will be omitted altogether) - Partition
       containing the destination/gw to be checked. If *(wildcard)
       operator is used all partitions shall be checked.
     * type (optional) - GW/destination type to be checked; when
       omitting this parameter or specifying a negative value i.e.
       "-1", matching will be done against all groups
     * flags (optional) - what operations should be performed when
       a GW matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp AVP
          + 'n' (Ignore port) - ignores port number during
            matching
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched gateway.

   Example 1.42. is_from_gw usage when use_partitions is 0
...
if (is_from_gw("3","1") {
}
...

   Example 1.43. is_from_gw usage when use_partitions is 1
...
if (is_from_gw("my_partition","3","1") {
}
...

1.4.7.  dr_is_gw([partition,] src_avp, [type], [flag],
[gw_attrs_pvar])

   The function checks if the ip address in pvar src_pv is a
   gateway from a certain group.

   This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE,
   FAILURE_ROUTE, BRANCH_ROUTE, LOCAL_ROUTE, STARTUP_ROUTE,
   TIMER_ROUTE and EVENT_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   partition (the partition becomes mandatory) in which the
   gateways have been defined.

   Meaning of the parameters is as follows:
     * partition (mandatory if use_partitions parameter is 1,
       otherwise it will be omitted altogether) - Partition
       containing the destinations/gateways to be checked.
     * src_avp (mandatory) - avp containing a SIP URI. Does not
       support other OpenSIPS pseudo-variables.
     * type (optional) - GW/destination type to be checked; when
       omitting this parameter or specifying a negative value i.e.
       "-1", matching will be done against all groups
     * flags (optional) - what operations should be performed when
       a GW matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp pvar
          + 'n' (Ignore port) - ignores port number
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (output, optional) - a writable
       pseudo-variable which will be populated with the attributes
       of the matched gateway.

   Example 1.44. dr_is_gw usage when use_partitions is 0
...
if (dr_is_gw("$avp(uac)","3") {
}
...

   Example 1.45. dr_is_gw usage when use_partitions is 1
...
if (dr_is_gw("my_partition","$avp(uac)","3") {
}
...

1.4.8.  dr_disable()

   Marks as disabled the last destination that was used for the
   current call. The disabling done via this function will prevent
   the destination to be used for usage from now on. The probing
   mechanism can re-enable this peer (see the probing section in
   the beginning)

   This function can be used from REQUEST_ROUTE and FAILURE_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   partition (the partition becomes mandatory) in which the
   gateway to be disabled is defined.
     * partition (mandatory if use_partitions parameter is 1,
       otherwise it will be omitted altogether) - Partition
       containing the destination/gateway to be disabled.

   Example 1.46. dr_disable() usage when use_partitions is 0
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
        dr_disable();

}

...

   Example 1.47. dr_disable() usage when use_partitions is 1
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
        dr_disable("my_partition");

}

...

1.5. Exported MI Functions

1.5.1.  dr_reload

   Command to reload routing rules from database. If
   use_partitions is set to 1 you can reload just a partition
   given a parameter, if no parameter is supplied then all the
   partitions will be reloaded.

   If use_partitions is 0 it takes no parameter.

   MI FIFO Command Format:
                :dr_reload:fifo_reply
                partition_name (optional)
                _empty_line_

1.5.2. dr_gw_status

   Gets or sets the status (enabled or disabled) of a gateway. The
   function may take from 0 to 3 parameters.
     * if use_partitions is set to 0 - if no parameter is
       provided, it will list all gateways along with their
       status. If one parameter is provided, that must be the id
       of a gateway and the function will return the status of
       that gateway. If 2 parameters are provided, first must be
       the ID of the ID of a GW and the second must be the new
       status to be forced for that GW (0 - disable, 1 - enable).
     * if use_partitions is set to 1 - the first parameter must be
       the partition (the partition is mandatory). If just one
       parameter is provided it will the display the statuses of
       all the gateways in the given partition. If two parameters
       are provided, the first must be the partition, and the
       second must be the gateway Id. If three parameters are
       provided, the first must be the partition, the second must
       be the gateway and the third will be the new status to be
       forced for tat GW (0 - disable, 1 - enable)

   MI FIFO Command Format:
                :dr_gw_status:_reply_fifo_file_
                partition_name (mandatory if use_partitions is 1, otherw
ise will be omitted altogether)
                GW_id
                status (optional)
                _empty_line_

   Example 1.48. dr_gw_status usage when use_partitions is set to
   0
$ ./opensipsctl fifo dr_gw_status 2
State:: Active
$ ./opensipsctl fifo dr_gw_status 2 0
$ ./opensipsctl fifo dr_gw_status 2
Enabled:: Disabled MI
$ ./opensipsctl fifo dr_gw_status 3
Enabled:: Inactive

   Example 1.49. dr_gw_status usage when use_partitionsis set to 1
$ ./opensipsctl fifo dr_gw_status part_1 my_gw
State:: Active
$ ./opensipsctl fifo dr_gw_status my_partition 3 0
$ ./opensipsctl fifo dr_gw_status partition7 dsbl_gw 2
Enabled:: Disabled MI
$ ./opensipsctl fifo dr_gw_status partition8 gw3
Enabled:: Inactive

1.5.3. dr_carrier_status

   Gets or sets the status (enabled or disabled) of a carrier. The
   function may take from 0 to 3 parameters.
     * if use_partition is set to 0 - if no parameter is provided
       it will list all the carriers along with their status. If
       one parameter is provided, that must be the id of carrier
       and the function will return the status of that carrier. If
       2 parameters are provided, first must be the Id of a
       carrier and the second must be the new status to be forced
       for that carrier
     * if use_partition is set to 1 - the first parameter must be
       the partition (the partition becomes mandatory). If one
       parameter is supplied, it will be the partition, and it
       will display the statuses of the carriers contained in that
       partition. If two parameters are supplied, the second must
       be the carrierId, and the command will display the status
       of the selected carrier. If three parameters are supplied,
       the first two will be the partition name and the carrierId
       while the third parameter will be the new status to be
       forced for that carrier.

   MI FIFO Command Format:
                :dr_carrier_status:_reply_fifo_file_
                partition_name (mandatory if use_partition is 1, otherwi
se it will be omitted)
                carrier_id
                status (optional)
                _empty_line_

   Example 1.50. dr_carrier_status usage when use_partitions is 0
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: no
$ ./opensipsctl fifo dr_carrier_status CR1 1
$ ./opensipsctl fifo dr_carrier_status CR1
Enabled:: yes

   Example 1.51. dr_carrier_status usage when use_partitions is 1
$ ./opensipsctl fifo dr_carrier_status my_partition CR1
Enabled:: no
$ ./opensipsctl fifo dr_carrier_status partition_1 CR1 1
$ ./opensipsctl fifo dr_carrier_status partition_3 CR1
Enabled:: yes

1.5.4. dr_reload_status

   Gets the time of the last reload for any partition. The
   function may take at most one parameter.
     * if use_partition is set to 0 - the function doesn't receive
       any parameter. It will list the date of the last reload for
       the default (and only) partition.
     * if use_partition is set to 1 - if no parameter is supplied
       it will list the time of the last update for every
       partition. If one parameter is supplied, then this must be
       the partition name, and the function will list the time of
       the last reload for that given partition.

   MI FIFO Command Format:
                :dr_reload_status:_reply_fifo_file_
                partition_name (if use_partition is 1 it may be omitted,
 but if use_partition
is 0 it must be omitted)
                _empty_line_

   Example 1.52. dr_reload_status usage when use_partitions is 0
$ ./opensipsctl fifo dr_reload_status
Date:: Tue Aug 12 12:26:00 2014

   Example 1.53. dr_reload_status usage when use_partitions is 1
$ ./opensipsctl fifo dr_reload_status
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
Partition:: part_2 Date=Tue Aug 12 12:24:13 2014
$ ./opensipsctl fifo dr_reload_status part_test
Partition:: part_test Date=Tue Aug 12 12:24:13 2014

1.5.5. dr_number_routing

   Gets the matched prefix along with the list of the gateways /
   carriers to which a number would be routed when using the
   do_routing function
     * if use_partition is set to 1 the function will have 3
       parameters:
          + partition name
          + group id - the group id of the rules to check against
          + number - the number to test against
     * if use_partition is set to 0 the function will have 2
       parameters:
          + group id - the group id of the rules to check against
          + number - the number to test against

   Note: The group id may be omitted - just as with the do_routing
   function.

1.6. Exported Events

1.6.1.  E_DROUTING_STATUS

   This event is raised when the module changes the state of a
   gateway, either through MI or probing.

   Parameters:
     * gwid - the gateway identifier.
     * address - the address of the gateway.
     * status - disabled MI if the gateway was disabled using MI
       commands, probing if the gateway is being pinged, inactive
       if it was disabled from the script or active if the gateway
       is enabled.

1.7. Installation

   The module requires 4 tables in the OpenSIPS database:
   dr_groups, dr_gateways, dr_carriers, dr_rules. The SQL syntax
   to create them can be found in the drouting-create.sql script,
   located in the database directories of the opensips/scripts
   folder. You can also find the complete database documentation
   on the project webpage,
   http://www.opensips.org/html/docs/db/db-schema-devel.html.

Chapter 2. Developer Guide

   The module provides no function to be used by other OpenSIPS
   modules.
