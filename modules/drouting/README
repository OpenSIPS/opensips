Dynamic Routing Module
     __________________________________________________________

   Table of Contents

   1. Admin Guide

        1.1. Overview

              1.1.1. Introduction
              1.1.2. Features
              1.1.3. Performance
              1.1.4. Dynamic Routing Concepts
              1.1.5. Routing Rule Processing
              1.1.6. Probing and Disabling destinations

        1.2. Dependencies

              1.2.1. OpenSIPS Modules
              1.2.2. External Libraries or Applications

        1.3. Exported Parameters

              1.3.1. db_url(str)
              1.3.2. drd_table(str)
              1.3.3. drr_table(str)
              1.3.4. drg_table(str)
              1.3.5. drc_table(str)
              1.3.6. ruri_avp (str)
              1.3.7. gw_id_avp (str)
              1.3.8. gw_priprefix_avp (str)
              1.3.9. rule_id_avp (str)
              1.3.10. rule_prefix_avp (str)
              1.3.11. carrier_id_avp (str)
              1.3.12. gw_sock_avp (str)
              1.3.13. rule_attrs_avp (str)
              1.3.14. define_blacklist (str)
              1.3.15. default_group (int)
              1.3.16. force_dns (int)
              1.3.17. persistent_state (int)
              1.3.18. no_concurrent_reload (int)
              1.3.19. probing_interval (integer)
              1.3.20. probing_method (string)
              1.3.21. probing_from (string)
              1.3.22. probing_reply_codes (string)
              1.3.23. probing_socket (string)
              1.3.24. cluster_id (integer)
              1.3.25. cluster_sharing_tag (string)
              1.3.26. use_domain (int)
              1.3.27. drg_user_col (str)
              1.3.28. drg_domain_col (str)
              1.3.29. drg_grpid_col (str)
              1.3.30. use_partitions (int)
              1.3.31. db_partitions_url (int)
              1.3.32. db_partitions_table (int)
              1.3.33. partition_id_pvar (pvar)
              1.3.34. enable_restart_persistency (pvar)
              1.3.35. extra_prefix_chars (srt)

        1.4. Exported Functions

              1.4.1. do_routing([groupID], [flags],
                      [gw_whitelist], [rule_attrs_pvar],
                      [gw_attrs_pvar], [carrier_attrs_pvar],
                      [partition])

              1.4.2. route_to_carrier( carriers, [gw_attrs_pvar],
                      [carrier_attrs_pvar], [partition])

              1.4.3. route_to_gw(gw_id, [gw_attrs_var],
                      [partition])

              1.4.4. use_next_gw( [rule_attrs_pvar],
                      [gw_attrs_pvar], [carrier_attrs_pvar],
                      [partition])

              1.4.5. goes_to_gw( [type], [flags], [gw_attrs_pvar],
                      [partition])

              1.4.6. is_from_gw([type], [flag], [gw_attrs_pvar],
                      [partition])

              1.4.7. dr_is_gw( sip_uri, [type], [flag],
                      [gw_attrs_pvar], [partition])

              1.4.8. dr_disable([partition])

        1.5. Exported MI Functions

              1.5.1. dr_reload
              1.5.2. dr_gw_status
              1.5.3. dr_carrier_status
              1.5.4. dr_reload_status
              1.5.5. dr_number_routing
              1.5.6. dr_enable_probing

        1.6. Exported Events

              1.6.1. E_DROUTING_STATUS

        1.7. Installation

   2. Developer Guide
   3. Contributors

        3.1. By Commit Statistics
        3.2. By Commit Activity

   4. Documentation

        4.1. Contributors

   List of Tables

   3.1. Top contributors by DevScore^(1), authored commits^(2) and
          lines added/removed^(3)

   3.2. Most recently active contributors^(1) to this module

   List of Examples

   1.1. Set db_url parameter
   1.2. Set drd_table parameter
   1.3. Set drr_table parameter
   1.4. Set drg_table parameter
   1.5. Set drc_table parameter
   1.6. Set ruri_avp parameter
   1.7. Set gw_id_avp parameter
   1.8. Set gw_priprefix_avp parameter
   1.9. Set rule_id_avp parameter
   1.10. Set rule_prefix_avp parameter
   1.11. Set carrier_id_avp parameter
   1.12. Set gw_sock_avp parameter
   1.13. Set rule_attrs_avp parameter
   1.14. Set define_blacklist parameter
   1.15. Set default_group parameter
   1.16. Set force_dns parameter
   1.17. Set the persistent_state parameter
   1.18. Set no_concurrent_reload parameter
   1.19. Set probing_interval parameter
   1.20. Set probing_method parameter
   1.21. Set probing_from parameter
   1.22. Set probing_reply_codes parameter
   1.23. Set probing_socket parameter
   1.24. Set cluster_id parameter
   1.25. Set cluster_sharing_tag parameter
   1.26. Set use_domain parameter
   1.27. Set drg_user_col parameter
   1.28. Set drg_domain_col parameter
   1.29. Set drg_grpid_col parameter
   1.30. Set use_partitions parameter
   1.31. Set db_partitions_url parameter
   1.32. Set db_partitions_table parameter
   1.33. Set partition_id_pvar parameter
   1.34. Set enable_restart_persistency parameter
   1.35. Set extra_prefix_chars parameter
   1.36. do_routing usage
   1.37. route_to_carrier usage
   1.38. route_to_gw usage
   1.39. use_next_gw usage
   1.40. goes_to_gw usage
   1.41. is_from_gw usage
   1.42. dr_is_gw usage
   1.43. dr_disable() usage
   1.44. dr_gw_status usage when use_partitions is set to 0
   1.45. dr_gw_status usage when use_partitionsis set to 1
   1.46. dr_carrier_status usage when use_partitions is 0
   1.47. dr_carrier_status usage when use_partitions is 1
   1.48. dr_reload_status usage when use_partitions is 0
   1.49. dr_reload_status usage when use_partitions is 1
   1.50. dr_enable_probing usage

Chapter 1. Admin Guide

1.1. Overview

1.1.1. Introduction

   Dynamic Routing is a module for selecting (based on multiple
   criteria) the best gateway/destination to be used for
   delivering a certain call. Least Cost Routing (LCR) is a
   special case of dynamic routing - when the rules are ordered
   based on costs. Dynamic Routing comes with many features
   regarding routing rule selection:
     * prefix based
     * caller/group based
     * time based
     * priority based

   , processing :
     * stripping and prefixing
     * default rules
     * inbound and outbound processing
     * script route triggering

   and failure handling:
     * serial forking
     * weight based GW selection
     * random GW selection
     * GW probing for crashes

1.1.2. Features

   The dynamic routing implementation for OpenSIPS is designed
   with the following properties:
     * The routing info (destinations, carriers, rules, groups) is
       stored in a database and loaded into memory at start up
       time; reload at runtime via a Management Interface command.
     * weight-based or random selection of the destinations (from
       a rule or from a carrier), failure detection of gateways
       (with switching to next available gateway).
     * able to handle large volume of routing info (10M of rules)
       with minimal speed/time and memory consumption penalties
     * script integration - Pseudo-variable support in functions;
       scripting route triggering when rules are matched
     * bidirectional behavior - inbound and outbound processing
       (strip and prefixing when sending and receiving from a
       destination/GW)
     * blacklisting - the module allows definition of blacklists
       based on the destination IPs. This blacklists are to be
       used to prevent malicious forwarding to GWs (based on DNS
       lookups) when the script logic does none-GE forwarding
       (like foreign domains).
     * loading routing information from multiple databases - the
       gateways, rules, groups and carriers can be grouped by
       partitions, and each partition may be loaded from different
       databases/tables. This makes the routing process partition
       based. In order to be able to use a table from a partition,
       its name must be found in the "version" table belonging to
       the database defined in the partition's db_url.

1.1.3. Performance

   There were several tests performed regarding the performance of
   the module when dealing with a large number of routing rules.

   The tests were performed with a set of 383000 rules and
   measured:
     * time to load from DB
     * used shared memory

   The time to load was varying between 4 seconds and 8 seconds,
   depending of the caching of the DB client - the first load was
   the slowest (as the DB query hits the disk drive); the
   following are faster as data is already cached in the DB
   client. So technically speaking, the time to load (without the
   time to query which is DB type dependent) is ~4 seconds

   After loading the data into shared memory ~ 96M of memory were
   used exclusively for the DR data.

1.1.4. Dynamic Routing Concepts

   DR engine uses several concepts in order to define how the
   routing should be done (describing all the dependencies between
   destinations and routing rules).

1.1.4.1. Destination/Gateways

   These are the end SIP entities where actually the traffic needs
   to be sent after routing. They are stored in a table called
   “dr_gateways”. Gateway addresses are stored in a separate table
   because of the need to access them independent of Dynamic
   Routing processing (e.g., adding/ removing gateway PRI prefix
   before/after performing other operation -- receiving/relaying
   to gateway).

   In DR, a gateway is defined by:
     * id (string)
     * SIP address (SIP URI)
     * type (integer which allows GWs to be grouped by purpose,
       e.g. inbound, outbound, etc.)
     * strip value (number of digits) from dialled number
     * prefix (string) to be added to dialled number
     * attributes (not used by DR engine, but only pushed to
       script level when routing to this GW)
     * probing mode (how the GW should be probed at SIP level -
       see the probing chapter)

   The Gateways are to be used from the routing rule or from the
   carrier definition. They are all the time referred by their ID.

1.1.4.2. Carriers

   The carrier concept is used if you need to group gateways in
   order to have a better control on how the GWs will be used by
   DR rules; like in what order the GWs will be used.

   Basically, a carrier is a set of gateways which have its own
   sorting algorithm and its own attribute string. They are by
   default defined in the “dr_carriers” table.

   In DR, a carrier is defined by:
     * id (string)
     * list of gateways with/without weights (string)
       (Ex:“gw1=10,gw4=10” or “gw1,gw2”
     * flags : 0x1 - use weight for sorting the list and not
       definition order; 0x2 - use only the first gateway from the
       carrier (depending on the sorting); 0x4 - disable the usage
       of this carrier
     * attributes (not used by DR engine, but only pushed to
       script level when routing to this carrier)

   The Carriers are to be used only from the routing rule
   definition. They are all the time referred by their ID.

1.1.4.3. Routing Rules

   These are the actual rules which control the routing. Using
   different criterias (prefix, time, priority, etc), they will
   decide to which gateways the call will be sent.

   Default name for the table storing rule definitions is
   “dr_rules”.

   In DR, a routing rule is defined by:
     * group (list of numbers) - rules can be grouped (a rule may
       belong to multiple groups in the same time ) and you can
       use only a certain group at a point; like having a
       “premium” or “standard” or “interstate” or “intrastate”
       groups of rules to be used in different cases
     * prefix (string with digits only) - prefix to be used for
       matching this rule (longest prefix matching)
     * time validity (time recurrence string) - when this rule is
       valid from time point of view (see RFC 2445)
     * priority (number) - priority of the rule - higher value,
       higher priority (see rule section alg)
     * script route ID (string) - if defined, then execute the
       route with the specified ID when this rule is matched.
       That's it, a route which can be used to perform custom
       operations on message. NOTE that no modification is
       performed at signaling level and you must NOT do any
       signaling operations in that script route
     * list of GWs/carriers (string) - a comma separated list of
       gateways or carriers (defined by IDs) to be used for this
       rule; the carrier IDs are prefixed with “#” sign. For each
       ID (GW or carrier) you may specify a weight. For how this
       list will be interpreted (as order) see the rule selection
       section. Example of list: “gw1,gw4,#cr3” or
       “gw1=10,gw4=10,#cr3=80”
     * attributes (not used by DR engine, but only pushed to
       script level when this rule matched and been used)

   More on time recurrence:
     * A date-time expression that defines the time recurrence to
       be matched for current rule. Time recurrences are based
       closely on the recurring time intervals from the Internet
       Calendaring and Scheduling Core Object Specification
       (calendar COS), RFC 2445. The set of attributes used in
       routing rule specification is a subset of time recurrence
       attributes.
     * The value stored in database has the format of:
       <dtstart>|<duration>|<freq>|<until>|<interval>|<byday>|<bym
       onthday>|<byyearday>|<byweekno>|<bymonth>
     * When an attribute is not specified, the corresponding place
       must be left empty, whenever another attribute that follows
       in the list has to be specified.

1.1.5. Routing Rule Processing

   The module can be used to find out which is the best gateway to
   use for new calls terminated to PSTN. The algorithm to select
   the rule is as follows:
     * the module discovers the routing group of the originating
       user. This step is skipped if a routing group is passed
       from the script as parameter.
     * once the group is known, in the subset of the rules for
       this group the module looks for the one that matches the
       destination based on "prefix" column. The set of rules with
       the longest prefix is chosen. If no digit from the prefix
       matches, the default rules are used (rules with no prefix)
     * within the set of rules is applied the time criteria, and
       the rule which has the highest priority and matches the
       time criteria is selected to drive the routing.
     * Once found the rule, it may contain a route ID to execute.
       If a certain flag is set, then the processing is stopped
       after executing the route block.
     * The rule must contain a chain of gateways and carriers. The
       module will execute serial forking for each address in the
       chain (ordering is either done by simply using the
       definition order or it may weight-based - weight selection
       must be enabled). The next address in chain is used only if
       the previously has failed.
     * With the right gateway address found, the prefix (PRI) of
       the gateway is added to the request URI and then the
       request is forwarded.

   If no rule is found to match the selection criteria an default
   action must be taken (e.g., error response sent back). If the
   gateway in the chain has no prefix the request is forwarded
   without adding any prefix to the request URI.

1.1.6. Probing and Disabling destinations

   The module has the capability to monitor the status of the
   destinations by doing SIP probing (sending SIP requests like
   OPTIONS).

   For each destination, you can configure what kind of probing
   should be done (probe_mode column):
     * (0) - no probing at all;
     * (1) - probing only when the destination is in disabled mode
       (disabling via MI command will completely stop the probing
       also). The destination will be automatically re-enabled
       when the probing will succeed next time;
     * (2) - probing all the time. If disabled, the destination
       will be automatically re-enabled when the probing will
       succeed next time;

   A destination can become disabled in two ways:
     * script detection - by calling from script the dr_disable()
       function after trying the destination. In this case, if
       probing mode for the destination is (1) or (2), the
       destination will be automatically re-enabled when the
       probing will succeed.
     * MI command - by calling the dr_gw_status MI command for
       disabling (on demand) the destination. If so, the probing
       and re-enabling of this destination will be completly
       disabled until you re-enable it again via MI command - this
       is designed to allow controlled and complete disabling of
       some destination during maintenance.

1.2. Dependencies

1.2.1. OpenSIPS Modules

   The following modules must be loaded before this module:
     * a database module.

     * tm module.
     * clusterer - only if "cluster_id" option is enabled.

1.2.2. External Libraries or Applications

     * none.

1.3. Exported Parameters

1.3.1. db_url(str)

   The database url.

   Default value is “NULL”.

   Example 1.1. Set db_url parameter
...
modparam("drouting", "db_url",
        "mysql://opensips:opensipsrw@localhost/opensips")
...

1.3.2. drd_table(str)

   The name of the db table storing gateway addresses.

   Default value is “dr_gateways”.

   Example 1.2. Set drd_table parameter
...
modparam("drouting", "drd_table", "dr_gateways")
...

1.3.3. drr_table(str)

   The name of the db table storing routing rules.

   Default value is “dr_rules”.

   Example 1.3. Set drr_table parameter
...
modparam("drouting", "drr_table", "rules")
...

1.3.4. drg_table(str)

   The name of the db table storing groups.

   Default value is “dr_groups”.

   Example 1.4. Set drg_table parameter
...
modparam("drouting", "drg_table", "groups")
...

1.3.5. drc_table(str)

   The name of the db table storing definitions of the carriers
   that will be used directly by the routing rules.

   Default value is “dr_carriers”.

   Example 1.5. Set drc_table parameter
...
modparam("drouting", "drc_table", "my_dr_carriers")
...

1.3.6. ruri_avp (str)

   The name of the avp for storing Request URIs to be later used
   (alternative destiantions for the current one).

   Default value is “$avp(___dr_ruri__)” if use_partitions
   parameter is 0 or “$avp(___dr_ruri__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.6. Set ruri_avp parameter
...
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "ruri_avp", '$avp(33)')
...

1.3.7. gw_id_avp (str)

   The name of the avp for storing the id of the current selected
   gateway/destination - once a new destination is selected (via
   the use_next_gw() function), the AVP will be updated with the
   ID of the new selected gateway/destination.

   Default value is “$avp(___dr_gw_id__)” if use_partitions
   parameter is 0 or “$avp(___dr_gw_id__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.7. Set gw_id_avp parameter
...
modparam("drouting", "gw_id_avp", '$avp(gw_id)')
modparam("drouting", "gw_id_avp", '$avp(334)')
...

1.3.8. gw_priprefix_avp (str)

   The name of the avp for storing the PRI prefix of the current
   selected destination/gateway - once a new destination is
   selected (via the use_next_gw() function), the AVP will be
   updated with the PRI prefix of the new used destination.

   Default value is “NULL”.

   Example 1.8. Set gw_priprefix_avp parameter
...
modparam("drouting", "gw_priprefix_avp", '$avp(gw_priprefix)')
...

1.3.9. rule_id_avp (str)

   The name of the avp for storing the id of the current matched
   routing rule (see dr_rules table).

   Default value is “NULL”.

   Example 1.9. Set rule_id_avp parameter
...
modparam("drouting", "rule_id_avp", '$avp(rule_id)')
modparam("drouting", "rule_id_avp", '$avp(335)')
...

1.3.10. rule_prefix_avp (str)

   The actual prefix that matched the routing rule (the part from
   RURI username that matched the routing rule).

   Default value is “NULL”.

   Example 1.10. Set rule_prefix_avp parameter
...
modparam("drouting", "rule_prefix_avp", '$avp(dr_prefix)')
...

1.3.11. carrier_id_avp (str)

   AVP to be populate with the ID string for the carrier the
   current GW belongs to.

   Default value is “NULL”.

   Example 1.11. Set carrier_id_avp parameter
...
modparam("drouting", "carrier_id_avp", '$avp(carrier_id)')
...

1.3.12. gw_sock_avp (str)

   The name of the avp for storing sockets for alternative
   destinations defined by ruri_avp.

   Default value is “$avp(___dr_sock__)” if use_partitions
   parameter is 0 or “$avp(___dr_sock__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.12. Set gw_sock_avp parameter
...
modparam("drouting", "gw_sock_avp", '$avp(dr_sock)')
modparam("drouting", "gw_sock_avp", '$avp(77)')
...

1.3.13. rule_attrs_avp (str)

   The name of the avp for storing rule attrs in case they are
   requested at least once in the script.

   Default value is “$avp(___dr_ru_att__)” if use_partitions
   parameter is 0 or “$avp(___dr_ru_att__partition_name)” where
   partition_name is the name of the partition containing the AVP
   (as fetched from the database) if use_partitions parameter is
   1.

   Example 1.13. Set rule_attrs_avp parameter
...
modparam("drouting", "rule_attrs_avp", '$avp(dr_rule_attr)')
modparam("drouting", "rule_attrs_avp", '$avp(11)')
...

1.3.14. define_blacklist (str)

   Defines a blacklist based on a list of GW types - the blacklist
   will be populated with the IPs (no port, all protocols) of the
   GWs having the specified types.

   If partitions are used, prefix the blacklist definition string
   with the name of the partition followed by ":" separator.

   Multiple instances of this param are allowed.

   Default value is “NULL”.

   Example 1.14. Set define_blacklist parameter
...
modparam("drouting", "define_blacklist", 'bl_name= 3,5,25,23')
modparam("drouting", "define_blacklist", 'list= 4,2')
modparam("drouting", "define_blacklist", 'pstn:list2 = 5,6')
modparam("drouting", "define_blacklist", 'pstn:list3 = 7,8')
...

1.3.15. default_group (int)

   Group to be used if the caller (FROM user) is not found in the
   GROUP table.

   Default value is “NONE”.

   Example 1.15. Set default_group parameter
...
modparam("drouting", "default_group", 4)
...

1.3.16. force_dns (int)

   Force DNS resolving of GW/destination names (if not IPs) during
   startup. If not enabled, the GW name will be blindly used
   during routing.

   Default value is “1 (enabled)”.

   Example 1.16. Set force_dns parameter
...
modparam("drouting", "force_dns", 0)
...

1.3.17. persistent_state (int)

   Specifies whether the state column should be loaded at startup
   and flushed during runtime or not.

   Default value is “1” (enabled).

   Example 1.17. Set the persistent_state parameter
...
# disable all DB operations with the state of a gateway
modparam("drouting", "persistent_state", 0)
...

1.3.18. no_concurrent_reload (int)

   If enabled, the module will not allow do run multiple dr_reload
   MI commands in parallel (with overlapping) Any new reload will
   be rejected (and discarded) while an existing reload is in
   progress.

   If you have a large routing set (millions of rules/prefixes),
   you should consider disabling concurrent reload as they will
   exhaust the shared memory (by reloading into memory, in the
   same time, multiple instances of routing data).

   Default value is “0 (disabled)”.

   Example 1.18. Set no_concurrent_reload parameter
...
# do not allow parallel reload operations
modparam("drouting", "no_concurrent_reload", 1)
...

1.3.19. probing_interval (integer)

   How often (in seconds) the probing of a destination should be
   done. If set to 0, the probing will be disabled as
   functionality (for all destinations)

   Default value is “30”.

   Example 1.19. Set probing_interval parameter
...
modparam("drouting", "probing_interval", 60)
...

1.3.20. probing_method (string)

   The SIP method to be used for the probing requests.

   Default value is “"OPTIONS"”.

   Example 1.20. Set probing_method parameter
...
modparam("drouting", "probing_method", "INFO")
...

1.3.21. probing_from (string)

   The FROM SIP URI to be advertised in the SIP probing requests.

   Default value is “"sip:prober@localhost"”.

   Example 1.21. Set probing_from parameter
...
modparam("drouting", "probing_from", "sip:pinger@192.168.2.10")
...

1.3.22. probing_reply_codes (string)

   A comma separted list of SIP reply codes. The codes defined
   here will be considered as valid reply codes for probing
   messages, apart for 200.

   Default value is “NULL”.

   Example 1.22. Set probing_reply_codes parameter
...
modparam("drouting", "probing_reply_codes", "501, 403")
...

1.3.23. probing_socket (string)

   A socket description [proto:]host[:port] of the local socket
   (which is used by OpenSIPS for SIP traffic) to be used (if
   multiple) for sending the probing messages from.

   For probing gateway the highest priority has socket from
   gateway configuration in dr_gateways table. Then socket from
   global probing_socket parameter and the lowest priority is
   default behaviour with auto selected socket wich OpenSIPS
   listens on.

   Default value is “NULL”.

   Example 1.23. Set probing_socket parameter
...
modparam("drouting", "probing_socket", "udp:192.168.1.100:5060")
...

1.3.24. cluster_id (integer)

   The ID of the cluster the module is part of. The clustering
   support is used in drouting module for two purposes: for
   sharing the status of the gateways/carriers and for controlling
   the pinging to gateways.

   If clustering enbled, the module will automatically share
   changes over the status of the gateways/destinations/carriers
   with the other OpenSIPS instances that are part of a cluster.
   Whenever such a status changes (following an MI command, a
   probing result, a script command), the module will replicate
   this status change to all the nodes in this given cluster.

   The clustering with sharing tag support may be used to control
   which node in the cluster will perform the pinging/probing to
   gateways. See the cluster_sharing_tag option.

   For more info on how to define and populate a cluster (with
   OpenSIPS nodes) see the "clusterer" module.

   Default value is “0 (none)”.

   Example 1.24. Set cluster_id parameter
...
# replicate gw/carrier status with all OpenSIPS in cluster ID 9
modparam("drouting", "cluster_id", 9)
...

1.3.25. cluster_sharing_tag (string)

   The name of the sharing tag (as defined per clusterer modules)
   to control which node is responsible for perform the
   self-triggered actions in the module. Such actions may be the
   gateway probing or sharing the gateway/carrier status changes.
   If defined, only the node with active status of this tag will
   perform the actions (pinging and sharing status).

   The cluster_id must be defined for this option to work.

   This is an optional parameter. If not set, all the nodes in the
   cluster will individually do the probing and share the status
   changes.

   Default value is “empty (none)”.

   Example 1.25. Set cluster_sharing_tag parameter
...
# only the node with the active "vip" sharing tag will perform pinging
# and broadcast the status changes
modparam("drouting", "cluster_id", 9)
modparam("drouting", "cluster_sharing_tag", "vip")
...

1.3.26. use_domain (int)

   Flag to configure whether to use domain match when querying
   database for user's routing group.

   Default value is “1”.

   Example 1.26. Set use_domain parameter
...
modparam("drouting", "use_domain", 0)
...

1.3.27. drg_user_col (str)

   The name of the column in group db table where the username is
   stored.

   Default value is “username”.

   Example 1.27. Set drg_user_col parameter
...
modparam("drouting", "drg_user_col", "user")
...

1.3.28. drg_domain_col (str)

   The name of the column in group db table where the domain is
   stored.

   Default value is “domain”.

   Example 1.28. Set drg_domain_col parameter
...
modparam("drouting", "drg_domain_col", "host")
...

1.3.29. drg_grpid_col (str)

   The name of the column in group db table where the group id is
   stored.

   Default value is “groupid”.

   Example 1.29. Set drg_grpid_col parameter
...
modparam("drouting", "drg_grpid_col", "grpid")
...

1.3.30. use_partitions (int)

   Flag to configure whether to use partitions for routing. If
   this flag is set then the db_partitions_url and
   db_partitions_table variables become mandatory.

   Default value is “0”.

   Example 1.30. Set use_partitions parameter
...
modparam("drouting", "use_partitions", 1)
...

1.3.31. db_partitions_url (int)

   The url to the database containing partition-specific
   information. (partition-specific information includes partition
   name, url to the database where information about the partition
   is preserved, the names of the tables in which it is preserved
   and the AVPs that can be accessed using the .cfg script). The
   use_partitions parameter must be set to 1.

   Default value is “"NULL"”.

   Example 1.31. Set db_partitions_url parameter
...
modparam("drouting", "db_partitions_url", "mysql://user:password@localho
st/opensips_partitions")
...

1.3.32. db_partitions_table (int)

   The name of the table containing partition definitions. To be
   used with use_partitions and db_partitions_url.

   Default value is “dr_partitions”.

   Example 1.32. Set db_partitions_table parameter
...
modparam("drouting", "db_partitions_table", "partition_defs")
...

1.3.33. partition_id_pvar (pvar)

   Variable which will store the name of the name partition when
   wildcard(*) operatior is used. Use_partitions must be set in
   order to use this parameter.

   NOTE: The variable must be WRITABLE!

   Default value is “null(not used)”.

   Example 1.33. Set partition_id_pvar parameter
...
modparam("drouting", "partition_id_pvar", "$var(matched_partition)")
...

1.3.34. enable_restart_persistency (pvar)

   Parameter set to enable restart persistency for the Dynamic
   Routing module. When this parameter is set, the drouting module
   no longer loads the data from the database after restart, but
   uses the persistent storage file, and loads data from it “on
   demand”, improving the startup performance.

   NOTE: If the restart persistent cache is not populated from a
   previous run, then the data will be loaded from database at
   startup!

   NOTE: A reload will update the cached data.

   Default value is “0 (disabled)”.

   Example 1.34. Set enable_restart_persistency parameter
...
modparam("drouting", "enable_restart_persistency", yes)
...

1.3.35. extra_prefix_chars (srt)

   List of ASCII (0-127) characters to be additionally accepted in
   the prefixes. By default only '0' - '9' chars (digits) are
   accepted.

   Default value is “NULL”.

   Example 1.35. Set extra_prefix_chars parameter
...
modparam("drouting", "extra_prefix_chars", "#-%")
...

1.4. Exported Functions

1.4.1.  do_routing([groupID], [flags], [gw_whitelist],
[rule_attrs_pvar], [gw_attrs_pvar], [carrier_attrs_pvar],
[partition])

   Function to trigger routing of the message according to the
   rules in the database table and the configured parameters.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and LOCAL_ROUTE.

   If you set use_partitions to 1 the partition last parameter
   becomes mandatory.

   All parameters are optional. Any of them may be ignored,
   provided the necessary separation marks "," are properly
   placed.
     * groupID (int, optional) - number to specify the group of
       the caller for routing purposes. If none specified the
       function will automatically try to query the dr_group table
       to get this
     * flags (string, optional) - a list of letter-like flags for
       controlling the routing behavior. Possible flags are:
          + W - Instead of using the destination (from the rule
            definition) in the given order, sort them based on
            their weight.
          + F - Enable rule fallback; normally the engine is using
            a single rule for routing a call; by setting this
            flag, the engine will fallback and use rules with less
            priority or shorter prefix when all the destination
            from the current rules failed.
          + L - Do strict length matching over the prefix -
            actually DR engine will do full number matching and
            not prefix matching anymore.
          + C - Only check if the dialed number matches any
            routing rule, without loading / applying any routing
            info (no GW is set, the RURI is not altered)
     * gw_whitelist (string, optional) - a comma separated white
       list of gateways. This will force routing over, at most,
       this list of carriers or gateways (in other words, the
       whitelist will be intersected with the results of the
       search through the rules).
     * rule_attrs_pvar (var, optional) - a writable variable which
       will be populated with the attributes of the matched
       dynamic routing rule.
     * gw_attrs_pvar (var, optional) - a writable variable which
       will be populated with the attributes of the matched
       gateway.
     * carrier_attrs_pvar (var, optional) - a a writable variable
       which will be populated with the attributes of the matched
       carrier.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Besides
       specifing the name of one partition, you can use the "*"
       wildcard sign to force routing over all partitions.

   Example 1.36. do_routing usage
...
# all groups, sort on order, use_partitions is 0
do_routing();
...
# all groups, sort on order, use_partitions is 1, route by partition nam
ed "part"
do_routing( , , , , , ,"part");
...
# group id 0, sort on order, use_partitions is 0
do_routing(0);
...
# group id 0, sort on order, use_partitions is 1, route by partition nam
ed "part"
do_routing(0, , , , , , "part");
...
# group id from $var(id), sort on order, use_partitions is 0
do_routing($var(id));
...
# all groups, sort on weights, use_partitions is 0
do_routing(, "W");
...
# use_partitions is 1, partition and group supplied by AVPs, do strict l
ength matching
do_routing( $avp(grp),"L", , , , ,$avp(partition))
...
# group id 2, sort on order, fallback rule and also return the gateway a
ttributes
do_routing(2, "F", , , $var(gw_attributes));
...

1.4.2.  route_to_carrier( carriers, [gw_attrs_pvar],
[carrier_attrs_pvar], [partition])

   Function to trigger the direct routing to a given set carriers
   (one or more). So, the routing is not done prefix based, but
   carrier based (call will be sent to the GWs of that carrier,
   based on carrier policy).

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter also (where the carrier are to be found).

     * carriers (string) - comma separated carrier IDs (names)
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the
       currently matched gateway of this carrier.
     * carrier_attrs_pvar (var, optional) - an output writable
       variable which will be populated with the attributes of
       this carrier.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is not accepted by the function.

   Example 1.37. route_to_carrier usage
...
# use_partitions is not set
if ( route_to_carrier("my_top_carrier, def_carrier", , $var(carrier_att)
) ) {
        xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...
# use_partitions is enabled
if ( route_to_carrier("my_top_carrier", , $var(carrier_att), "part") ) {
        xlog("Routing to \"my_top_carrier\" - $var(carrier_att)\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...
# use_partitions is enabled
if ( route_to_carrier($var(carrierId), , , $var(my_partition)) ) {
        xlog("Routing to \"my_top_carrier\"\n");
        t_on_failure("next_gw");
        t_relay();
        exit;
}
...

1.4.3.  route_to_gw(gw_id, [gw_attrs_var], [partition])

   Function to trigger the direct routing to a given gateway (or
   list of gateways). Attributes and per-gw processing will be
   available.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

     * gw_id (string) - comma separated list of gateway IDs to be
       used.
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the
       currently matched gateway.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is not accepted by the function.

   Example 1.38. route_to_gw usage
...
# use_partitions is not set
if ( route_to_gw("gw_europe") ) {
        t_relay();
        exit;
}
...
# use_partitions is not set
if ( route_to_gw("gw1,gw2,gw3", $var(gw_attrs)) ) {
        xlog("Relaying to first gateway from our list - $var(gw_attrs)\n
");
        t_relay();
        exit;
}
...
# use_partitions is enabled
if ( route_to_gw("gw_europe", , "my_partition") ) {
        t_relay();
        exit;
}
...
# use_partitions is enabled
if ( route_to_gw("gw1,gw2,gw3", $var(gw_attrs), "my_partition") ) {
        xlog("Relaying to first gateway from our list - $var(gw_attrs)\n
");
        t_relay();
        exit;
}
...

1.4.4.  use_next_gw( [rule_attrs_pvar], [gw_attrs_pvar],
[carrier_attrs_pvar], [partition])

   The function takes the next available destination (set by
   do_routing, as alternative destinations) and pushes it into the
   RURI. Note that the function just sets the RURI (nothing more).

   If a new RURI is set, the used destination is removed from the
   pending set of alternative destinations.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

   The function returns true only if a new RURI was set. False is
   returned is no other alternative destinations are found or in
   case of an internal processing error. It may take the following
   optional parameters:
     * rule_attrs_pvar (var, optional) - an output writable
       variable which will be populated with the attributes of the
       matched dynamic routing rule.
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the matched
       gateway.
     * carrier_attrs_pvar (var, optional) - an output writable
       variable which will be populated with the attributes of the
       matched carrier.
     * partition (optinal, string) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is not accepted by the function.

   Example 1.39. use_next_gw usage
...
# use_partitions is not set
if (use_next_gw()) {
        t_relay();
        exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw(, , $var(carrier_attrs))) {
        xlog("Carrier attributes of current gateway: $var(carrier_attrs)
\n");
        t_relay();
        exit;
}
...
# use_partitions is enabled
if (use_next_gw( , , ,"my_partition")) {
        t_relay();
        exit;
}
...
# Also fetch the carrier attributes, if any
if (use_next_gw( , ,$var(carrier_attrs), "my_partition")) {
        xlog("Carrier attributes of current gateway: $var(carrier_attrs)
\n");
        t_relay();
        exit;
}
...

1.4.5.  goes_to_gw( [type], [flags], [gw_attrs_pvar], [partition])

   Function returns true if the destination of the current request
   (destination URI or Request URI) points (as IP) to one of the
   gateways. There no DNS lookups done if the domain part of the
   URI is not an IP.

   This function does not change anything in the message.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and ONREPLY_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

   It may take the following optional parameters:
     * type (int, optional) - number for the GW/destination type
       to be checked; when omitting this parameter or specifying
       the special value "-1", matching will be done against all
       types.
     * flags (string, optional) - letter like flags for
       controlling what operations should be performed when a GW
       matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp AVP
          + 'n' (Ignore port) - ignores port number during
            matching
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the matched
       gateway.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is accepted by this function.

   Example 1.40. goes_to_gw usage
...
# use_partitions is not set
if (goes_to_gw( 1, , $var(gw_attrs))) {
        sl_send_reply(403,"Forbidden");
        exit;
}
...
# use_partitions is enabledt
if (goes_to_gw(1, , $var(gw_attrs), "my_partition")) {
        sl_send_reply(403,"Forbidden");
        exit;
}
...

1.4.6.  is_from_gw([type], [flag], [gw_attrs_pvar], [partition])

   The function checks if the sender of the message (source IP +
   source port) is a gateway from a certain group.

   This function does not change anything in the message.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and ONREPLY_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

   It may take the following optional parameters:
     * type (int, optional) - number for the GW/destination type
       to be checked; when omitting this parameter or specifying
       the special value "-1", matching will be done against all
       types.
     * flags (string, optional) - letter like flags for
       controlling what operations should be performed when a GW
       matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp AVP
          + 'n' (Ignore port) - ignores port number during
            matching
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the matched
       gateway.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is accepted by this function.

   Example 1.41. is_from_gw usage
# use_partitions is not set
# match the source IP (only) against all gateways
if (is_from_gw(3, "n")) {
        ...
}

# use_partitions is enabled
# match the source IP and port against all gws from "outbound" partition
 and
# return its carrier
if (is_from_gw(3, "c", , "outbound")) {
        ...
}

1.4.7.  dr_is_gw( sip_uri, [type], [flag], [gw_attrs_pvar],
[partition])

   The function checks if the SIP URI hostname part stored inside
   the "src_pv" pseudo-variable is a gateway from a certain group.

   This function does not change anything in the message.

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE and ONREPLY_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

   It may take the following optional parameters:
     * sip_uri (string) - SIP URI. If the URI hostname part is a
       FQDN, it will be resolved prior to matching.
     * type (int, optional) - number for the GW/destination type
       to be checked; when omitting this parameter or specifying
       the special value "-1", matching will be done against all
       types.
     * flags (string, optional) - letter like flags for
       controlling what operations should be performed when a GW
       matches:
          + 's' (Strip) - apply to the username of RURI the strip
            defined by the GW
          + 'p' (Prefix) - apply to the username of RURI the
            prefix defined by the GW
          + 'i' (Gateway ID) - return the gateway id into
            gw_id_avp AVP
          + 'n' (Ignore port) - ignores port number during
            matching
          + 'c' (Carrier ID) - return the carrier id into
            carrier_id_avp AVP
     * gw_attrs_pvar (var, optional) - an output writable variable
       which will be populated with the attributes of the matched
       gateway.
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is accepted by this function.

   Example 1.42. dr_is_gw usage
# match the SIP URI host within $var(uac) against all gateways
if (dr_is_gw( $var(uac), , "n")) {
        ...
}


# match the SIP URI host within $var(uac) against
# all gws in "outbound" partition
if (dr_is_gw( $avp(uac), , "n", , "partition")) {
        ...
}

1.4.8.  dr_disable([partition])

   Marks as disabled the last destination that was used for the
   current call. The disabling done via this function will prevent
   the destination to be used for usage from now on. The probing
   mechanism can re-enable this peer (see the probing section in
   the beginning)

   This function can be used from REQUEST_ROUTE, FAILURE_ROUTE,
   BRANCH_ROUTE, ONREPLY_ROUTE and LOCAL_ROUTE.

   If you set use_partitions parameter to 1 you must supply the
   "partition" parameter to instruct on the partition where the
   gateway has been defined.

   It may take the following parameters:
     * partition (string, optional) - the name of the DR partition
       to be used. This parameter is to be defined ONLY if the
       "use_partition" module parameter is turned on. Wildcard
       sign is accepted by this function.

   Example 1.43. dr_disable() usage
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
        dr_disable();

}
...
if (t_check_status("(408)|(5[0-9][0-9])")) {
        dr_disable("my_partition");

}
...

1.5. Exported MI Functions

1.5.1.  dr_reload

   Command to reload routing rules from database.
     * if use_partition is set to 0 - all routing rules will be
       reloaded.
     * if use_partition is set to 1, the parameters are:
          + partition_name (optional) - if not provided all the
            partitions will be reloaded, otherwise just the
            partition given as parameter will be reloaded.

   MI FIFO Command Format:
                opensips-cli -x mi dr_reload part_1

1.5.2. dr_gw_status

   Gets the status (enabled or disabled) of one or multiple
   gateways. The function can also be used to set the status of a
   single gateway.
     * if use_partitions is set to 0, the parameters are:
          + gw_id (optional) - the id of a gateway. If provided,
            the function will return/set (depnding if the second
            parameter is given) the status of that gateway,
            otherwise it will list all gateways along with their
            statuses.
          + status (optional) - the new status to be forced for a
            GW (0 - disable, 1 - enable). Only makes sense if
            gw_id is provided.
     * if use_partitions is set to 1, the parameters are:
          + partition_name
          + gw_id (optional) - the id of a gateway. If provided,
            the function will return/set (depnding if the third
            parameter is given) the status of that gateway,
            otherwise it will list all gateways in the given
            partition along with their statuses.
          + status (optional) - the new status to be forced for a
            GW (0 - disable, 1 - enable). Only makes sense if
            gw_id is provided.

   Example 1.44. dr_gw_status usage when use_partitions is set to
   0
$ opensips-cli -x mi dr_gw_status 2
State:: Active
$ opensips-cli -x mi dr_gw_status 2 0
$ opensips-cli -x mi dr_gw_status 2
Enabled:: Disabled MI
$ opensips-cli -x mi dr_gw_status 3
Enabled:: Inactive

   Example 1.45. dr_gw_status usage when use_partitionsis set to 1
$ opensips-cli -x mi dr_gw_status part_1 my_gw
State:: Active
$ opensips-cli -x mi dr_gw_status part_1 my_gw 0
$ opensips-cli -x mi dr_gw_status part_1 my_gw
Enabled:: Disabled MI
$ opensips-cli -x mi dr_gw_status partition8 3
Enabled:: Inactive

1.5.3. dr_carrier_status

   Gets the status (enabled or disabled) of one or multiple
   carriers. The function can also be used to set the status of a
   single carrier.
     * if use_partitions is set to 0, the parameters are:
          + carrier_id (optional) - the id of a carrier. If
            provided, the function will return/set (depnding if
            the second parameter is given) the status of that
            carrier, otherwise it will list all carriers along
            with their statuses.
          + status (optional) - the new status to be forced for a
            carrier (0 - disable, 1 - enable). Only makes sense if
            carrier_id is provided.
     * if use_partitions is set to 1, the parameters are:
          + partition_name
          + carrier_id (optional) - the id of a carrier. If
            provided, the function will return/set (depnding if
            the third parameter is given) the status of that
            carrier, otherwise it will list all carriers contained
            in the given partition along with their statuses.
          + status (optional) - the new status to be forced for a
            carrier (0 - disable, 1 - enable). Only makes sense if
            carrier_id is provided.

   Example 1.46. dr_carrier_status usage when use_partitions is 0
$ opensips-cli -x mi dr_carrier_status CR1
Enabled:: no
$ opensips-cli -x mi dr_carrier_status CR1 1
$ opensips-cli -x mi dr_carrier_status CR1
Enabled:: yes

   Example 1.47. dr_carrier_status usage when use_partitions is 1
$ opensips-cli -x mi dr_carrier_status my_partition CR1
Enabled:: no
$ opensips-cli -x mi dr_carrier_status partition_1 CR1 1
$ opensips-cli -x mi dr_carrier_status partition_3 CR1
Enabled:: yes

1.5.4. dr_reload_status

   Gets the time of the last reload for any partition.
     * if use_partition is set to 0 - the function doesn't receive
       any parameter. It will list the date of the last reload for
       the default (and only) partition.
     * if use_partition is set to 1, the parameters are:
          + partition_name (optional) - if not provided the
            function will list the time of the last update for
            every partition. Otherwise, the function will list the
            time of the last reload for the given partition.

   Example 1.48. dr_reload_status usage when use_partitions is 0
$ opensips-cli -x mi dr_reload_status
Date:: Tue Aug 12 12:26:00 2014

   Example 1.49. dr_reload_status usage when use_partitions is 1
$ opensips-cli -x mi dr_reload_status
Partition:: part_test Date=Tue Aug 12 12:24:13 2014
Partition:: part_2 Date=Tue Aug 12 12:24:13 2014
$ opensips-cli -x mi dr_reload_status part_test
Partition:: part_test Date=Tue Aug 12 12:24:13 2014

1.5.5. dr_number_routing

   Gets the matched prefix along with the list of the gateways /
   carriers to which a number would be routed when using the
   do_routing function.
     * if use_partition is set to 1 the function will have 3
       parameters:
          + partition name
          + group id (optional) - the group id of the rules to
            check against
          + number - the number to test against
     * if use_partition is set to 0 the function will have 2
       parameters:
          + group id (optional) - the group id of the rules to
            check against
          + number - the number to test against

   MI FIFO Command Format:
                opensips-cli -x mi dr_number_routing part1 3 012340987

1.5.6.  dr_enable_probing

   Enables/disables gateway probing or returns the current gateway
   probing status.

   Parameters:
     * status (optional) - 1 - enable, 0 - disable gateway probing

   Example 1.50. dr_enable_probing usage
$ opensips-cli -x mi dr_enable_probing
Status:: 1
$ opensips-cli -x mi dr_enable_probing 0
$ opensips-cli -x mi dr_enable_probing
Status:: 0

1.6. Exported Events

1.6.1.  E_DROUTING_STATUS

   This event is raised when the module changes the state of a
   gateway, either through an MI command, probing or script
   function.

   Parameters:
     * partition - the name of the partition.
     * gwid - the gateway identifier.
     * address - the address of the gateway.
     * status - disabled MI if the gateway was disabled using MI
       commands, probing if the gateway is being pinged, inactive
       if it was disabled from the script or active if the gateway
       is enabled.

1.7. Installation

   The module requires 4 tables in the OpenSIPS database:
   dr_groups, dr_gateways, dr_carriers, dr_rules. The SQL syntax
   to create them can be found in the drouting-create.sql script,
   located in the database directories of the opensips/scripts
   folder. You can also find the complete database documentation
   on the project webpage,
   http://www.opensips.org/html/docs/db/db-schema-devel.html.

Chapter 2. Developer Guide

   The module provides no function to be used by other OpenSIPS
   modules.

Chapter 3. Contributors

3.1. By Commit Statistics

   Table 3.1. Top contributors by DevScore^(1), authored
   commits^(2) and lines added/removed^(3)
     Name DevScore Commits Lines ++ Lines --
   1. Bogdan-Andrei Iancu (@bogdan-iancu) 371 171 12770 5536
   2. Razvan Crainea (@razvancrainea) 91 43 1110 2141
   3. Liviu Chircu (@liviuchircu) 50 33 855 533
   4. Mihai Tiganus (@tallicamike) 48 10 3130 710
   5. Vlad Patrascu (@rvlad-patrascu) 40 17 1090 728
   6. Vlad Paiu (@vladpaiu) 23 20 244 47
   7. Andrei Datcu (@andrei-datcu) 20 12 551 134
   8. Ovidiu Sas (@ovidiusas) 15 11 132 70
   9. Ionut Ionita (@ionutrazvanionita) 14 9 370 108
   10. Andrei Dragus 10 3 657 40

   All remaining contributors: Anca Vamanu, Jeremy Martinez, Dusan
   Klinec, Matt Lehner, Julián Moreno Patiño, Sergio Gutierrez, Le
   Roy Christophe, Nick Altmann (@nikbyte), Peter Lemenkov
   (@lemenkov), Alexey Vasilyev (@vasilevalex), Ozzyboshi, Walter
   Doekes (@wdoekes).

   (1) DevScore = author_commits + author_lines_added /
   (project_lines_added / project_commits) + author_lines_deleted
   / (project_lines_deleted / project_commits)

   (2) including any documentation-related commits, excluding
   merge commits. Regarding imported patches/code, we do our best
   to count the work on behalf of the proper owner, as per the
   "fix_authors" and "mod_renames" arrays in
   opensips/doc/build-contrib.sh. If you identify any
   patches/commits which do not get properly attributed to you,
   please submit a pull request which extends "fix_authors" and/or
   "mod_renames".

   (3) ignoring whitespace edits, renamed files and auto-generated
   files

3.2. By Commit Activity

   Table 3.2. Most recently active contributors^(1) to this module
                      Name                   Commit Activity
   1.  Vlad Patrascu (@rvlad-patrascu)     Mar 2017 - Jan 2020
   2.  Razvan Crainea (@razvancrainea)     Sep 2010 - Jan 2020
   3.  Bogdan-Andrei Iancu (@bogdan-iancu) Oct 2008 - Dec 2019
   4.  Liviu Chircu (@liviuchircu)         Nov 2012 - Nov 2018
   5.  Vlad Paiu (@vladpaiu)               Aug 2011 - Nov 2018
   6.  Alexey Vasilyev (@vasilevalex)      Oct 2018 - Oct 2018
   7.  Peter Lemenkov (@lemenkov)          Jun 2018 - Jun 2018
   8.  Ovidiu Sas (@ovidiusas)             May 2012 - Mar 2017
   9.  Jeremy Martinez                     Feb 2017 - Feb 2017
   10. Le Roy Christophe                   Feb 2017 - Feb 2017

   All remaining contributors: Ionut Ionita (@ionutrazvanionita),
   Ozzyboshi, Julián Moreno Patiño, Dusan Klinec, Andrei Datcu
   (@andrei-datcu), Mihai Tiganus (@tallicamike), Walter Doekes
   (@wdoekes), Nick Altmann (@nikbyte), Matt Lehner, Anca Vamanu,
   Andrei Dragus, Sergio Gutierrez.

   (1) including any documentation-related commits, excluding
   merge commits

Chapter 4. Documentation

4.1. Contributors

   Last edited by: Bogdan-Andrei Iancu (@bogdan-iancu), Vlad
   Patrascu (@rvlad-patrascu), Razvan Crainea (@razvancrainea),
   Liviu Chircu (@liviuchircu), Alexey Vasilyev (@vasilevalex),
   Peter Lemenkov (@lemenkov), Ionut Ionita (@ionutrazvanionita),
   Vlad Paiu (@vladpaiu), Mihai Tiganus (@tallicamike), Andrei
   Datcu (@andrei-datcu), Matt Lehner, Anca Vamanu, Andrei Dragus,
   Sergio Gutierrez.

   Documentation Copyrights:

   Copyright © 2009-2012 www.opensips-solutions.com

   Copyright © 2005-2008 Voice Sistem SRL
