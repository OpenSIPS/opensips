<!-- Module User's Guide -->

<chapter>
	
	<title>&adminguide;</title>
	
	<section>
	<title>Overview</title>
	<para>
		<acronym>TM</acronym> module enables stateful processing of SIP 
		transactions. The main use of stateful logic, which is costly in 
		terms of memory and <acronym>CPU</acronym>, is some services 
		inherently need state. For example, transaction-based accounting 
		(module acc) needs to process transaction state as opposed to 
		individual messages, and any kinds of forking must be implemented 
		statefully. Other use of stateful processing is it trading
		<acronym>CPU</acronym> caused by retransmission processing for memory.
		That makes however only sense if <acronym>CPU</acronym> consumption 
		per request is huge. For example, if you want to avoid costly 
		<acronym>DNS</acronym> resolution for every retransmission of a 
		request to an unresolvable destination, use stateful mode. Then,
		only the initial message burdens server by <acronym>DNS</acronym> 
		queries, subsequent retransmissions will be dropped and will not 
		result in more processes blocked by <acronym>DNS</acronym> resolution.
		The price is more memory consumption and higher processing latency.
	</para>
	<para>
		From user's perspective, the major function is t_relay(). It setup 
		transaction state, absorb retransmissions from upstream, generate 
		downstream retransmissions and correlate replies to requests.
	</para>
	<para>
		In general, if <acronym>TM</acronym> is used, it copies clones of 
		received SIP messages in shared memory. That costs the memory and 
		also <acronym>CPU</acronym> time (memcpys, lookups, shmem locks, etc.)
		Note that non-<acronym>TM</acronym> functions operate over the 
		received message in private memory, that means that any core 
		operations will have no effect on statefully processed messages after 
		creating the transactional state. For example, calling record_route 
		<emphasis>after</emphasis> t_relay is pretty useless, as the 
		<acronym>RR</acronym> is added to privately held message whereas its
		<acronym>TM</acronym> clone is being forwarded.
	</para>
	<para>
		<acronym>TM</acronym> is quite big and uneasy to program--lot of 
		mutexes, shared memory access, malloc and free, timers--you really 
		need to be careful when you do anything. To simplify 
		<acronym>TM</acronym> programming, there is the instrument of 
		callbacks. The callback mechanisms allow programmers to register 
		their functions to specific event. See t_hooks.h for a list of 
		possible events.
	</para>
	<para>
		Other things programmers may want to know is UAC--it is a very 
		simplistic code which allows you to generate your own transactions. 
		Particularly useful for things like NOTIFYs or <acronym>IM</acronym> 
		gateways. The UAC takes care of all the transaction machinery: 
		retransmissions , FR timeouts, forking, etc.  See t_uac prototype 
		in uac.h for more details. Who wants to see the transaction result 
		may register for a callback.
	</para>
	<section id="branch-flags">
		<title>Per-Branch flags</title>
		<para>
		First what is the idea with the branch concept: branch route is a 
		route to be execute separately for each branch before being sent 
		out - changes in that route should reflect only on that branch.
		</para>
		<para>
		There are several types of flags in &osips; :
		</para>
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>message/transaction</emphasis> flags - they are 
				visible everywhere in the transaction (in all routes and in 
				all sequential replies/request).
			</para>
			</listitem>
			<listitem>
			<para>
				<emphasis>branch</emphasis> flags - flags that are visible only
				from a specific branch - in all replies and routes connected 
				to this branch.
			</para>
			</listitem>
			<listitem>
			<para>
				<emphasis>script</emphasis> flags - flags that exist only
				during script execution. They are not store anywhere and are
				lost once the top level route was left.
			</para>
			</listitem>
			</itemizedlist>
		<para>
		For example: I have a call parallel forking to GW and to a user. And I 
		would like to know from which branch I will get the final negative 
		reply (if so). I will set a branch route before relaying the calls 
		(with the 2 branches). The branch route will be separately executed 
		for each branch; in the branch going to GW (I can identified it by 
		looking to RURI), I will set a branch flag. This flag will appear 
		only in the onreply route run for replied from GW. It will be also be 
		visible in failure route if the final elected reply belongs to the 
		GW branch. This flags will not be visible in the other branch 
		(in routes executing replies from the other branch).
		</para>
		<para>
		For how to define branch flags and use via script, see 
		<xref linkend="branch-route"/> and the setbflag(), resetbflag() and
		isbflagset() script functions.
		</para>
		<para>
		Also, modules may set branch flags before transaction creation 
		(for the moment this feature is not available in script). The 
		REGISTRAR module was the first to use this type of flags. The NAT flag 
		is pushed in branch flags instead in message flags
		</para>
	</section>
	<section id="timer-based-failover">
		<title>Timeout-Based Failover</title>
		<para>
		Timeouts can be used to trigger failover behavior. E.g. if we send a call
		to a gateway and the gateway does not send a provisional response within 3
		seconds, we want to cancel this call and send the call to another 
		gateway. Another example is to ring a SIP client only for 30 seconds 
		and then redirect the call to the voicemail.
		</para>
		<para>
		The transaction module exports two types of timeouts:
		</para>
			<itemizedlist>
			<listitem>
			<para>
				<emphasis role='bold'>fr_timeout</emphasis> - used when no response was
				received yet. If there is no response after
				<emphasis>fr_timeout</emphasis> seconds, the timer triggers
				(and failure route will be executed if t_on_failure() was
				called). For INVITE transactions, if a provisional response was
				received, the timeout is reset to <emphasis>fr_inv_timeout</emphasis>
				seconds and RT_T2 for all other transactions. Once a final response
				is received, the transaction has finished.
			</para>
			</listitem>
			<listitem>
			<para>
				<emphasis role='bold'>fr_inv_timeout</emphasis> - this timeout
				starts counting down once a provisional response was received
				for an INVITE transaction.
			</para>
			</listitem>
			</itemizedlist>
		<para>
		For example: You want to have failover if there is no provisional 
		response after 3 seconds, but you want to ring for 60 seconds. 
		Thus, set the <emphasis>fr_timeout</emphasis> to 3 and 
		<emphasis>fr_inv_timeout</emphasis> to 60.
		</para>
	</section>
	<section>
		<title>DNS Failover</title>
		<para>
		DNS based failover can be use when relaying stateful requests. 
		According to RFC 3263, DNS failover should be done on transport level
		or transaction level. TM module supports them both.
		</para>
		<para>
		Failover at transport level may be triggered by a failure of sending
		out the request message. A failure occurs if the corresponding 
		interface was found for sending the request, if the TCP connection
		was refused or if a generic internal error happened during send. There
		is no ICMP error report support.
		</para>
		<para>
		Failover at transaction level may be triggered when the transaction
		completed either with a 503 reply, either with a timeout without
		any received reply. In such a case, automatically, a new branch will
		be forked if any other destination IPs can be used to deliver the 
		requests. The new branch will be a clone of the winning branch.
		</para>
		<para>
		The set of destinations IPs is step-by-step build (on demand) based on
		the NAPTR, SRV and A records available for the destination domain.
		</para>
		<para>
		DNS-based failover is by default applied excepting when this failover
		is globally disabled (see the core parameter disable_dns_failover) or
		when the relay flag (per transaction) is set (see the t_relay()
		function).
		</para>
	</section>
	<section>
		<title>Usage Scope</title>
		<para>
		Transaction functions and variables are only designed to be
		called on SIP request messages where a transaction can be created, or
		in routes that are transaction aware, such as
		<emphasis>branch_route[name]</emphasis>,
		<emphasis>failure_route[name]</emphasis> or
		<emphasis>onreply_route[name]</emphasis>. Using TM functtions or
		variables in a route that is not transaction aware, such as
		the generic <emphasis>onreply_route</emphasis>,
		<emphasis>error_route</emphasis> or
		<emphasis>timer_route[name, timer]</emphasis> may lead to undefined
		behavior, and most of the time in bogus or malformed signalling.
		Therefore it is strongly recommended to avoid using them in non-tm
		context aware routes.
		</para>
	</section>
	</section>

	<section>
	<title>Dependencies</title>
	<section>
		<title>&osips; Modules</title>
		<para>
		The following modules must be loaded before this module:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>No dependencies on other &osips; modules</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	<section>
		<title>External Libraries or Applications</title>
		<para>
		The following libraries or applications must be installed before 
		running &osips; with this module loaded:
			<itemizedlist>
			<listitem>
			<para>
				<emphasis>None</emphasis>.
			</para>
			</listitem>
			</itemizedlist>
		</para>
	</section>
	</section>

	<section>
	<title>Exported Parameters</title>
	<section id='fr_timeout' xreflabel='fr_timeout'>
		<title><varname>fr_timeout</varname> (integer)</title>
		<para>
		Timeout which is triggered if no final reply for a request or ACK for a 
		negative INVITE reply arrives (in seconds).
		</para>
		<para>
		<emphasis>
			Default value is 30 seconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>fr_timeout</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "fr_timeout", 10)
...
</programlisting>
		</example>
	</section>

	<section id='fr_inv_timeout' xreflabel='fr_inv_timeout'>
		<title><varname>fr_inv_timeout</varname> (integer)</title>
		<para>
		Timeout which is triggered if no final reply for an INVITE arrives after a 
		provisional message was received (in seconds). This timeout starts
		counting down once the first provisional response is received. Thus,
		fast failover (no 100 trying from gateway) can be achieved by setting
		<emphasis> fr_timeout</emphasis> to low values. See example below.
		</para>
		<para>
		<emphasis>
			Default value is 120 seconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>fr_inv_timeout</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "fr_inv_timeout", 200)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>wt_timer</varname> (integer)</title>
		<para>
		Time for which a transaction stays in memory to absorb delayed 
		messages after it completed; also, when this timer hits, 
		retransmission of local cancels is stopped (a puristic but complex 
		behavior would be not to enter wait state until local branches
		are finished by a final reply or FR timer--we simplified).
		</para>
		<para>
		For non-INVITE transaction this timer relates to timer J of RFC 3261 
		section 17.2.2. According to the RFC this timer should be 64*T1 
		(= 32 seconds). But this would increase memory usage as the transactions
		are kept in memory very long.
		</para>
		<para>
		<emphasis>
			Default value is 5 seconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>wt_timer</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "wt_timer", 10)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>delete_timer</varname> (integer)</title>
		<para>
		Time after which a to-be-deleted transaction currently ref-ed by a
		process will be tried to be deleted again.
		</para>
		<para>
		<emphasis>
			Default value is 2 seconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>delete_timer</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "delete_timer", 5)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>T1_timer</varname> (integer)</title>
		<para>
		Retransmission T1 period, in milliseconds.
		</para>
		<para>
		<emphasis>
			Default value is 500 milliseconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>T1_timer</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "T1_timer", 700)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>T2_timer</varname> (integer)</title>
		<para>
		Maximum retransmission period, in milliseconds.
		</para>
		<para>
		<emphasis>
			Default value is 4000 milliseconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>T2_timer</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "T2_timer", 8000)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>ruri_matching</varname> (integer)</title>
		<para>
		Should be request-uri matching used as a part of pre-3261 transaction
		matching as the standard wants us to do so? Turn only off for better 
		interaction with devices that are broken and send different r-uri in
		CANCEL/ACK than in original INVITE.
		</para>
		<para>
		<emphasis>
			Default value is 1 (true).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>ruri_matching</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "ruri_matching", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>via1_matching</varname> (integer)</title>
		<para>
		Should be top most VIA matching used as a part of pre-3261 transaction
		matching as the standard wants us to do so? Turn only off for better 
		interaction with devices that are broken and send different top most
		VIA in CANCEL/ACK than in original INVITE.
		</para>
		<para>
		<emphasis>
			Default value is 1 (true).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>via1_matching</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "via1_matching", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>unix_tx_timeout</varname> (integer)</title>
		<para>
		Send timeout to be used by function which use UNIX sockets 
		(as t_write_unix).
		</para>
		<para>
		<emphasis>
			Default value is 2 seconds.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>unix_tx_timeout</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "unix_tx_timeout", 5)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>restart_fr_on_each_reply</varname> (integer)</title>
		<para>
		If true (non null value), the final response timer will be re-triggered
		for each received provisional reply. In this case, final response
		timeout may occur after a time longer than <emphasis>fr_inv_timeout</emphasis>
		(if UAS keeps sending provisional replies)
		</para>
		<para>
		<emphasis>
			Default value is 1 (true).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>restart_fr_on_each_reply</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "restart_fr_on_each_reply", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>tw_append</varname> (string)</title>
		<para>
		List of additional information to be appended by t_write_req and
		t_write_unix functions.
		</para>
		<para>
		<emphasis>
			Default value is null string.
		</emphasis>
		</para>
		<para>
		Syntax of the parameter is:
		<itemizedlist>
			<listitem><para><emphasis>
			tw_append = append_name':' element (';'element)*
			</emphasis></para></listitem>
			<listitem><para><emphasis>
			element = ( [name '='] variable)
			</emphasis></para></listitem>
		</itemizedlist>
		</para>
		<para>
		Each element will be appended per line in 
		<quote>name: value</quote> format. Element 
		<quote>$rb (message body)</quote>
		is the only one which does not accept name; the body it will be
		printed all the time at the end, disregarding its position in the
		definition string.
		</para>
		<example>
		<title>Set <varname>tw_append</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "tw_append",
   "test: ua=$hdr(User-Agent) ;avp=$avp(avp);$rb;time=$Ts")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>pass_provisional_replies</varname> (integer)</title>
		<para>
		Enable/disable passing of provisional replies to FIFO applications.
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>pass_provisional_replies</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "pass_provisional_replies", 1)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>syn_branch</varname> (integer)</title>
		<para>
		Enable/disable the usage of stateful synonym branch IDs in the 
		generated Via headers. They are faster but not reboot-safe.
		</para>
		<para>
		<emphasis>
			Default value is 1 (use synonym branches).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>syn_branch</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "syn_branch", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>onreply_avp_mode</varname> (integer)</title>
		<para>
		Describes how the AVPs should be handled in reply route:
		<itemizedlist>
			<listitem><para>
			<emphasis>0</emphasis> - the AVPs will be per message only; they 
			will not interfere with the AVPS stored in transaction; initially
			there will be an empty list and at the end of the route, all AVPs
			that were created will be discarded.
			</para></listitem>
			<listitem><para>
			<emphasis>1</emphasis> - the AVPs will be the transaction AVPs;
			initially the transaction AVPs will be visible; at the end of the
			route, the list will attached back to transaction (with all the 
			changes)
			</para></listitem>
		</itemizedlist>
		</para>
		<para>
		In mode 1, you can see the AVPs you set in request route, branch route
		or failure route. The side efect is performance as more locking is 
		required in order to keep the AVP's list integrity.
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>onreply_avp_mode</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "onreply_avp_mode", 1)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>disable_6xx_block</varname> (integer)</title>
		<para>
		Tells how the 6xx replies should be internally handled:
		<itemizedlist>
			<listitem><para>
			<emphasis>0</emphasis> - the 6xx replies will block any further
			serial forking (adding new branches). This is the RFC3261
			behaviour.
			</para></listitem>
			<listitem><para>
			<emphasis>1</emphasis> - the 6xx replies will be handled as any
			other negative reply - serial forking will be allowed.
			Logically, you need to break RFC3261 if you want to do redirects
			to announcement and voicemail services.
			</para></listitem>
		</itemizedlist>
		</para>
		<para>
		<emphasis>
			Default value is 0.
		</emphasis>
		</para>
		<example>
		<title>Set <varname>disable_6xx_block</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "disable_6xx_block", 1)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>enable_stats</varname> (integer)</title>
		<para>
		Enables statistics support in TM module - If enabled, the TM module
		will internally keep several statistics and export them via the 
		MI - Management Interface.
		</para>
		<para>
		<emphasis>
			Default value is 1 (enabled).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>enable_stats</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "enable_stats", 0)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>minor_branch_flag</varname> (string/integer)</title>
		<para>
		A branch flag index to be used in script to mark the minor branches 
		( before t_relay() ).
		</para>
		<para>
		A minor branch is a branch OpenSIPS will not wait to complete during
		parallel forking. So, if the rest of the branches are negativly replied
		OpenSIPS will not wait for a final answer from the minor branch, but
		it will simply cancel it.
		</para>
		<para>
		Main applicability of minor branch is to fork a branch to a media 
		server for injecting (via 183 Early Media) some pre-call media - of
		course, this branch will be transparanent for the rest of the call
		branches (from branch selection point of view).
		</para>
		<para>
		<emphasis>
			Default value is none (disabled).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>minor_branch_flag</varname> parameter</title>
		<programlisting format="linespecific">
...
modparam("tm", "minor_branch_flag", "MINOR_BFLAG")
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>timer_partitions</varname> (integer)</title>
		<para>
		The number of partitions for the internal TM timers (retransmissions,
		delete, wait, etc). Partitioning the timers increase the throughput
		under heavly load by handling timer events in parallel, rather than
		all serial.
		</para>
		<para>
		Recomanded range for timer partitions is max 16 (soft limit).
		</para>
		<para>
		<emphasis>
			Default value is 1 (disabled).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>timer_partitions</varname> parameter</title>
		<programlisting format="linespecific">
...
# Enable two timer partitions
modparam("tm", "timer_partitions", 2)
...
</programlisting>
		</example>
	</section>

	<section>
		<title><varname>auto_100trying</varname> (integer)</title>
		<para>
		This parameter controls if the TM module should automatically 
		generate an 100 Trying stateful reply when an INVITE transaction
		is created.
		</para>
		<para>
		You may want to disable this behavior if you want to control from
		script level when the 100 Trying is to be sent out.
		</para>
		<para>
		<emphasis>
			Default value is 1 (enabled).
		</emphasis>
		</para>
		<example>
		<title>Set <varname>auto_100trying</varname> parameter</title>
		<programlisting format="linespecific">
...
# Disable automatic 100 Trying
modparam("tm", "auto_100trying", 0)
...
</programlisting>
		</example>
	</section>

	</section>


	<section>
	<title>Exported Functions</title>
	<section id="t_relay" xreflabel='t_relay'>
		<title>
		<function moreinfo="none">t_relay([flags])</function>
		</title>
		<para>
		Relay a message statefully to destination indicated in current URI. 
		(If the original URI was rewritten by UsrLoc, RR, strip/prefix, etc., 
		the new URI will be taken). Returns a negative value on failure--you 
		may still want to send a negative reply upstream statelessly not to 
		leave upstream UAC in lurch.
		</para>
		<para>
		The coresponding transaction may or may not be already created. If not
		yet created, the function will automatically create it.
		</para>
		<para>
		The function may take as parameter an optional set of flags for 
		controlling the internal behaviour. The flags may be given in decimal 
		or hexa format; supported flags are:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>0x01</emphasis> - deprecated, not used any more
				</para>
			</listitem>
			<listitem>
				<para><emphasis>0x02</emphasis> - do not internally send a 
				negative reply in case of forward failure (due internal error,
				bad RURI, bad message, etc).  When a forward failure occurs, no
				SIP request is relayed and therefore no negative reply or
				timeout will show up on the failure_route (if one is set).
				It applies only when the transaction is created.
				By default one negative reply is sent.
				Useful if you want to implement a serial forking in case of failure.
				</para>
			</listitem>
			<listitem>
				<para><emphasis>0x04</emphasis> - disable the DNS failover
				for the transaction. Only first IP will be used. It disable
				the failover both at transaport and transaction level.
				</para>
			</listitem>
			<listitem>
				<para><emphasis>0x08</emphasis> - If the request is a CANCEL,
				trust and pass further the Reason header from the received
				CANCEL - shortly, will propagate the Reason header.
				</para>
			</listitem>
		</itemizedlist>
		<para>
		In case of error, the function returns the following codes:
		</para>
		<itemizedlist>
			<listitem>
				<para><emphasis>-1</emphasis> - generic internal error
				</para>
			</listitem>
			<listitem>
				<para><emphasis>-2</emphasis> - bad message (parsing errors)
				</para>
			</listitem>
			<listitem>
				<para><emphasis>-3</emphasis> - no destination available 
				(no branches were added or request already cancelled)
				</para>
			</listitem>
			<listitem>
				<para><emphasis>-4</emphasis> - bad destination 
				(unresolvable address)
				</para>
			</listitem>
			<listitem>
				<para><emphasis>-5</emphasis> - destination filtered 
				(black listed)
				</para>
			</listitem>
			<listitem>
				<para><emphasis>-6</emphasis> - generic send failed
				</para>
			</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_relay</function> usage</title>
		<programlisting format="linespecific">
...
if (!t_relay()) {
    sl_reply_error();
    exit;
}
...
</programlisting>
		</example>
	</section>

	<section id="trelay-1">
		<title>
		<function moreinfo="none">t_relay(proto:host:port,[flags])</function>
		</title>
		<para>
		Relay a message statefully to a fixed destination. The destination is
		specified as <quote>[proto:]host[:port]</quote>. If a destination URI
		<quote>$du</quote> for this message was set before the function
		is called then this value will be used as the destination instead of the
		function parameter.
		</para>
		<para>
		The function may take as parameter an optional set of flags for 
		controlling the internal behaviour - for details see the above 
		<quote>t_relay([flags])</quote> function.
		</para>
		<para>
		This functions can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_relay</function> usage</title>
		<programlisting format="linespecific">
...
t_relay("tcp:192.168.1.10:5060");
t_relay("mydomain.com:5070","0x1");
t_relay("udp:mydomain.com");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_reply(code, reason_phrase)</function>
		</title>
		<para>
		Sends a stateful SIP reply to the currently processed requests. Note 
		that if the transaction was not created yet, it will automatically
		created by internally using the
		<function>t_newtran</function> function.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>code</emphasis> - Reply code number.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>reason_phrase</emphasis> - Reason string.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		Both parameters accept any kind of variables.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_reply</function> usage</title>
		<programlisting format="linespecific">
...
t_reply("404", "Use $rU not found");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_reply_with_body(code, reason_phrase, body)</function>
		</title>
		<para>
		Sends a stateful SIP reply with a body to the currently processed 
		requests. Note that if the transaction was not created yet, it will 
		automatically created by internally using the
		<function>t_newtran</function> function.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>code</emphasis> - Reply code number.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>reason_phrase</emphasis> - Reason string.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>body</emphasis> - Reply body.
			</para>
		</listitem>
		</itemizedlist>

		<para>
		All parameters accept any kind of variables.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_reply_with_body</function> usage</title>
		<programlisting format="linespecific">
...
	if(is_method("INVITE"))
	{
		append_to_reply("Contact: $var(contact)\r\n"
				"Content-Type: application/sdp\r\n");
		t_reply_with_body("200", "Ok", "$var(body)");
		exit;
	}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_newtran()</function>
		</title>
		<para>
		Creates the SIP transaction for the currently processed SIP requests.
		Basically you switch to a stateful processing from this point furhter,
		with automatic detection of retransmission and auto sending of
		100 Trying reply on INVITEs.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE.
		</para>
		<example>
		<title><function>t_newtran</function> usage</title>
		<programlisting format="linespecific">
...
t_newtran();  # 100 Trying is fired here
xlog("doing my complicated routing logic");
....
t_relay(); # send the call further
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_check_trans()</function>
		</title>
		<para>
		Returns true if the current request is associated to a transaction. 
		The relationship between the request and transaction is defined as
		follows:
		</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>non-CANCEL/non-ACK requests</emphasis> - if the
			request belongs to a transaction (it's a retransmision), the
			function will do a standard processing of the retransmission and
			will break/stop the script. The function returns false if the
			request is not a retransmission.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>CANCEL request</emphasis> - true if the cancelled
			INVITE transaction exists.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>ACK request</emphasis> - true if the ACK is a
			hop-by-hop ACK (to a negative reply) corresponding to an previous
			INVITE transaction. IMPORTANT: end-to-end ACKs (to 2xx replies) are
			not detected by this function as end-to-end ACKs form a different
			transaction.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		Note: To detect retransmissions using this function you have to make 
		sure that the initial request has already created a transaction, e.g. 
		by using t_relay(). If the processing of requests may take long time 
		(e.g. DB lookups) and the retransmission arrives before t_relay() is 
		called, you can use the t_newtran() function to manually create a 
		transaction.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE and BRANCH_ROUTE.
		</para>
		<example>
		<title><function>t_check_trans</function> usage</title>
		<programlisting format="linespecific">
...
if ( is_method("CANCEL") ) {
	if ( t_check_trans() )
		t_relay();
	exit;
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_check_status(re)</function>
		</title>
		<para>
		Returns true if the regualr expression <quote>re</quote> match the 
		reply code of the response message as follows:
		<itemizedlist>
		<listitem>
			<para><emphasis>in routing block</emphasis> - the code of the
			last sent reply.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>in on_reply block</emphasis> - the code of the
			current received reply.
			</para>
		</listitem>
		<listitem>
			<para><emphasis>in on_failure block</emphasis> - the code of the
			selected negative final reply.
			</para>
		</listitem>
		</itemizedlist>
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, ONREPLY_ROUTE, 
		FAILURE_ROUTE and BRANCH_ROUTE .
		</para>
		<example>
		<title><function>t_check_status</function> usage</title>
		<programlisting format="linespecific">
...
if (t_check_status("(487)|(408)")) {
    log("487 or 408 negative reply\n");
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_local_replied(reply)</function>
		</title>
		<para>
		Returns true if all or last (depending of the parameter) reply(es) were
		local generated (and not received).
		</para>
		<para>
		Parameter may be <quote>all</quote> or <quote>last</quote>.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE, BRANCH_ROUTE,
		FAILURE_ROUTE and ONREPLY_ROUTE.
		</para>
		<example>
		<title><function>t_local_replied</function> usage</title>
		<programlisting format="linespecific">
...
if (t_local_replied("all")) {
	log ("no reply received\n");
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_was_cancelled()</function>
		</title>
		<para>
		Retuns true if called for an INVITE transaction that was explicitly
		cancelled by UAC side via a CANCEL request.
		</para>
		<para>
		This function can be used from ONREPLY_ROUTE, FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_was_cancelled</function> usage</title>
		<programlisting format="linespecific">
...
if (t_was_cancelled()) {
    log("transaction was cancelled by UAC\n");
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_cancel_branch([flags])</function>
		</title>
		<para>
		This function is to be call when a reply is received for cancelling a
		set of branches (see flags) of the current call.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>flags</emphasis> - (optional) - set of flags 
			(char based flags) to control what branches to be cancelled:
			</para>
			<itemizedlist>
			<listitem>
				<para><emphasis>a</emphasis> - all - cancel all pending 
				branches
				</para>
			</listitem>
			<listitem>
				<para><emphasis>o</emphasis> - others - cancel all the other
				pending branches except the current one
				</para>
			</listitem>
			<listitem>
				<para><emphasis>empty</emphasis> - current - cancel only the
				current branch
				</para>
			</listitem>
			</itemizedlist>
		</listitem>
		</itemizedlist>

		<para>
		This function can be used from ONREPLY_ROUTE.
		</para>
		<example>
		<title><function>t_cancel_branch</function> usage</title>
		<programlisting format="linespecific">
onreply_route[3] {
...
	if (t_check_status("183")) {
		# no support for early media
		t_cancel_branch();
	}
...
}
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_new_request(method,RURI,from,to[,body[,ctx]])</function>
		</title>
		<para>
		This function generates and sends out a new SIP request (in a stateful way).
		The new request is completly unrelated to the currently processed SIP message.
		</para>
		<para>Meaning of the parameters is as follows (all do accept variables):</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>method</emphasis> - the SIP method
			</para>
		</listitem>
		<listitem>
			<para><emphasis>RURI</emphasis> - the SIP Request URI (the request 
			will be sent out to this destination)
			</para>
		</listitem>
		<listitem>
			<para><emphasis>from</emphasis> - the SIP From hdr information as
			"[display ]URI"
			</para>
		</listitem>
		<listitem>
			<para><emphasis>from</emphasis> - the SIP To hdr information as
			"[display ]URI"
			</para>
		</listitem>
		<listitem>
			<para><emphasis>body</emphasis> - (optional) the SIP body content
			starting with the content type string: "conten_type body"
			</para>
		</listitem>
		<listitem>
			<para><emphasis>ctx</emphasis> - a context string that will be added to the
			new transaction as an AVP with name "uac_ctx" (it may be visible in local
			route)
			</para>
		</listitem>
		</itemizedlist>

		<example>
		<title><function>t_new_request</function> usage</title>
		<programlisting format="linespecific">
...
	# send a MESSAGE request
	t_new_request("MESSAGE","sip:alice@192.168.2.2","BOB sip:userB@mydomain.net","ALICE sip:userA@mydomain.net","text/plain Hello Alice!")) {
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_on_failure(failure_route)</function>
		</title>
		<para>
		Sets reply routing block, to which control is passed after a 
		transaction completed with a negative result but before sending a 
		final reply. In the referred block, you can either start a new branch 
		(good for services such as forward_on_no_reply) or send a final reply 
		on your own (good for example for message silo, which received a 
		negative reply from upstream and wants to tell upstream <quote>202 I 
		will take care of it</quote>).
		</para>
		<para>
		As not all functions are available from failure route, please check 
		the documentation for each function to see the permissions.
		Any other commands may result in unpredictable behavior and 
		possible server failure.
		</para>
		<para>
		Only one failure_route can be armed for a request. If you use many
		times t_on_failure(), only the last one has effect.
		</para>
		<para>
		Note that whenever failure_route is entered, RURI is set to value 
		of the winning branch.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>failure_route</emphasis> - Reply route block to be 
			called.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, BRANCH_ROUTE, 
		ONREPLY_ROUTE and FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_on_failure</function> usage</title>
		<programlisting format="linespecific">
...
route { 
	t_on_failure("1"); 
	t_relay();
} 

failure_route[1] {
	seturi("sip:user@voicemail");
	t_relay();
}
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_on_reply(reply_route)</function>
		</title>
		<para>
		Sets reply routing block, to which control is passed each time a reply
		(provisional or final) for the transaction is received. 
		The route is not called for local generated replies! In the referred 
		block, you can inspect the reply and perform text operations on it.
		</para>
		<para>
		As not all functions are available from this type of route, please 
		check  the documentation for each function to see the permissions.
		Any other commands may result in unpredictable behavior and 
		possible server failure.
		</para>
		<para>
		If called from branch route, the reply route will be set only for the
		current branch - that's it, it will be called only for relies belonging
		to that particular branch. Of course, from branch route, you can set
		different reply routes for each branch.
		</para>
		<para>
		When called from a non-branc route, the reply route will be globally 
		set for tha current transaction - it will be called for all replies 
		belonging to that transaction. NOTE that only 
		<emphasis>one></emphasis> onreply_route can be armed for a transaction.
		If you use many times t_on_reply(), only the last one has effect.
		</para>
		<para>
		If the processed reply is provisionla reply (1xx code), by calling
		the drop() function (exported by core), the execution of the route
		will end and the reply will not be forwarded further.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>reply_route</emphasis> - Reply route block to be 
			called.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, BRANCH_ROUTE, 
		ONREPLY_ROUTE and FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_on_reply</function> usage</title>
		<programlisting format="linespecific">
...
route {
	seturi("sip:bob@opensips.org");  # first branch
	append_branch("sip:alice@opensips.org"); # second branch

	t_on_reply("global"); # the "global" reply route 
	                      # is set the whole transaction
	t_on_branch("1");

	t_relay();
}

branch_route[1] {
	if ($rU=="alice")
		t_on_reply("alice"); # the "alice" reply route
		                      # is set only for second branch
}

onreply_route[alice] {
	xlog("received reply from alice\n");
}

onreply_route[global] {
	if (t_check_status("1[0-9][0-9]")) {
		setflag(LOG_FLAG);
		log("provisional reply received\n");
		if (t_check_status("183"))
			drop;
	}
}
...
</programlisting>
		</example>
	</section>

	<section id="branch-route">
		<title>
		<function moreinfo="none">t_on_branch(branch_route)</function>
		</title>
		<para>
		Sets a branch route to be execute separately for each branch of the
		transaction before being sent out - changes in that route should 
		reflect only on that branch.
		</para>
		<para>
		As not all functions are available from this type of route, please 
		check  the documentation for each function to see the permissions.
		Any other commands may result in unpredictable behavior and 
		possible server failure.
		</para>
		<para>
		Only one branch_route can be armed for a request. If you use many
		time t_on_branch(), only the last one has effect.
		</para>
		<para>
		By calling the drop() function (exported by core), the execution of 
		the branch route will end and the branch will not be forwarded further.
		</para>
		<para>Meaning of the parameters is as follows:</para>
		<itemizedlist>
		<listitem>
			<para><emphasis>branch_route</emphasis> - Branch route block to be 
			called.
			</para>
		</listitem>
		</itemizedlist>
		<para>
		This function can be used from REQUEST_ROUTE, BRANCH_ROUTE, 
		ONREPLY_ROUTE and FAILURE_ROUTE.
		</para>
		<example>
		<title><function>t_on_branch</function> usage</title>
		<programlisting format="linespecific">
...
route { 
	t_on_branch("1"); 
	t_relay();
} 

branch_route[1] {
	if ($ru=~"bad_uri") {
		xlog("dropping branch $ru \n");
		drop;
	}
	if ($ru=~"GW_uri") {
		append_rpid();
	}
}
...
</programlisting>
		</example>
	</section>

	<section id="t_inject_branches" xreflabel='t_inject_branches'>
		<title>
		<function moreinfo="none">t_inject_branches(source[,flags])</function>
		</title>
		<para>
		The function adds new SIP branches (destinations) to an existing 
		transaction and fires them (sends them out). The transaction may 
		already have ongoing branches (like in ringing state), which will not
		be affected by the injection of the new branches. Also it is possible 
		for the transaction not to have any ongoing branches at the moment of
		the injection (still, the transaction must wait for new branches, even
		if all existing ones are completed - see 
		the <xref linkend="t_wait_for_new_branches"/> function for this).
		</para>
		<para>
		The main usage scenario for this function (and also what makes it
		different from <xref linkend="t_relay"/> is the ability to add new
		branches to an ongoing transaction from script routes not related to 
		the transaction ( like timer route, event route, notification route,
		and other). In such routes, other functions/module used before the
		injection will point to the transaction to be affected by this
		injection - see the <emphasis>event_routing</emphasis> module.
		</para>
		<para>Parameters: </para>
		<itemizedlist>
			<listitem><para>
				<emphasis>source</emphasis> - where to take the description
				for the new branches to be injected. It can be
				<itemizedlist>
					<listitem>
					<emphasis>event</emphasis> - the branch will be taken from
					the event attributes exposed in an event notification route
					(see <emphasis>event_routing</emphasis> module).
					</listitem>
					<listitem>
					<emphasis>msg</emphasis> - the branches will be taken from
					the RURI of the SIP message and from the additional
					branches (created by append_branch() function or similar).
					</listitem>
				</itemizedlist>
			</para></listitem>
			<listitem><para>
				<emphasis>flags</emphasis> - (optional) some additional flags 
				related to the injection process:
				<itemizedlist>
					<listitem>
					<emphasis>cancel</emphasis> - cancel all the ongoing 
					existing branches from the transaction before injecting
					the new branches.
					</listitem>
				</itemizedlist>
			</para></listitem>
		</itemizedlist>
		<example>
		<title><function>t_inject_branches</function> usage</title>
		<programlisting format="linespecific">
...
route[event_notification] {
	t_inject_branches("event");
}
...
</programlisting>
		</example>
	</section>

	<section id="t_wait_for_new_branches" xreflabel='t_wait_for_new_branches'>
		<title>
		<function moreinfo="none">t_wait_for_new_branches()</function>
		</title>
		<para>
		This function instructs the existing SIP transaction to wait for new
		branches to be injected even after the completion of the existing 
		branches. This waiting will be done until the Final Response INVITE 
		timer (fr_inv_timeout) will hit for the transaction; of course, the
		waiting will be terminated if the transaction gets a 2xx final reply
		from one of the branches.
		</para>
		<para>
		Normally if you have a transaction with two branches and 
		they get, let's say, a 404 and 486 replies, the branches will be
		completed and transaction terminated by sending the 404 reply to the 
		caller. Still, if you do <emphasis>t_wait_for_new_branches</emphasis>
		before relaying the transaction, the transaction will not terminate
		upon the completion of the branches and not send the 404 to the caller
		- it will wait for new branches to be injected (see 
		<xref linkend="t_inject_branches"/> function) until the fr_inv timer
		hits.
		</para>
		<example>
		<title><function>t_wait_for_new_branches</function> usage</title>
		<programlisting format="linespecific">
...
t_newtran();
t_wait_for_new_branches();
t_relay();
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_add_hdrs("sip_hdrs")</function>
		</title>
		<para>
		Attach a set of headers to the existing transaction - these headers
		will be appended to all requests related to the transaction (outgoing
		branches, local ACKS, CANCELs).
		</para>
		<example>
		<title><function>t_add_hdrs</function> usage</title>
		<programlisting format="linespecific">
...
t_add_hdrs("X-origin: 1.1.1.1\r\n");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_add_cancel_reason("Reason_hdr")</function>
		</title>
		This function is used to enforce from the script level a custom
		"Reason" header into a CANCEL request. Normally, the Reason header is
		inherited form the received CANCEL (note that CANCEL propagates in a
		hop-by-hop manner - it is re-generated at each hop), but this function
		can overwrite it. It must be called before relaying the CANCEL request
		and its input must be a fully formated Reason header with name, body 
		and CRLF.
		<para>
		</para>
		<example>
		<title><function>t_add_cancel_reason</function> usage</title>
		<programlisting format="linespecific">
...
t_add_cancel_reason('Reason: SIP ;cause=200;text="Call completed elsewhere"\r\n');
t_relay();
...
</programlisting>
		</example>
	</section>


	<section id="treplicate">
		<title>
		<function moreinfo="none">t_replicate(URI,[flags])</function>
		</title>
		<para>
		Replicates a request to another destination. No information due the
		replicated request (like reply code) will be forwarded to the 
		original SIP UAC.
		</para>
		<para>
		The destination is specified by a SIP URI. If multiple destinations are
		to be used, the additional SIP URIs have to be set as branches.
		</para>
		<para>
		The function may take as parameter an optional set of flags for 
		controlling the internal behaviour - for description see the above 
		<quote>t_relay([flags])</quote> function. Note that only 0x4 is 
		applicable here.
		</para>
		<para>
		This functions can be used from REQUEST_ROUTE.
		</para>
		<example>
		<title><function>t_replicate</function> usage</title>
		<programlisting format="linespecific">
...
t_replicate("sip:1.2.3.4:5060");
t_replicate("sip:1.2.3.4:5060;transport=tcp");
t_replicate("sip:1.2.3.4","0x4");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_write_req(info,fifo)</function>
		<function moreinfo="none">t_write_unix(info,sock)</function>
		</title>
		<para>
		Write via FIFO file or UNIX socket a lot of information regarding the
		request. Which information should be written may be control via the
		<quote>tw_append</quote> parameter.
		</para>
		<para>
		This functions can be used from REQUEST_ROUTE, FAILURE_ROUTE and 
		BRANCH_ROUTE.
		</para>
		<example>
		<title><function>t_write_req/unix</function> usage</title>
		<programlisting format="linespecific">
...
modparam("tm","tw_append","append1:Email=$avp(email);UA=$ua")
modparam("tm","tw_append","append2:body=$rb")
...
t_write_req("voicemail/append1","/tmp/appx_fifo");
...
t_write_unix("logger/append2","/var/run/logger.sock");
...
</programlisting>
		</example>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_flush_flags()</function>
		</title>
		<para>
		Flush the flags from current request into the already created 
		transaction. It make sense only in routing block if the transaction was
		created via t_newtran() and the flags have been altered since.
		</para>
		<para>
		This function can be used from REQUEST_ROUTE and BRANCH_ROUTE .
		</para>
		<example>
		<title><function>t_flush_flags</function> usage</title>
		<programlisting format="linespecific">
...
t_flush_flags();
...
</programlisting>
		</example>
	</section>

	</section>


	<section>
		<title>Exported variables</title>
		<para>
		Exported variables are listed in the next sections.
		</para>
		<section>
		<title>$T_branch_idx</title>
			<para>
			<emphasis>$T_branch_idx</emphasis> - the index (starting with 0
			for the first branch) of the currently proccessed branch. This
			index makes sense only in BRANCH and REPLY routes (where there is
			a concept of per branch processing). In all the other types of 
			routes, the value of this index will be NULL.
			</para>
		</section>
		<section>
		<title>$T_reply_code</title>
			<para>
			<emphasis>$T_reply_code</emphasis> - the code of the reply, as 
			follows: in request_route will be the last stateful sent reply;
			in reply_route will be the current processed reply; in 
			failure_route will be the negative winning reply. In case of 
			no-reply or error, '0' value is returned.
			</para>
		</section>
		<section>
		<title>$T_fr_timeout</title>
			<para>
			<emphasis>$T_fr_timeout (R/W)</emphasis> - the timeout
			for the final reply to the current transaction
			</para>
			<para>
			With each different
			request received, <emphasis>$T_fr_timeout</emphasis> will initially
			be equal to the
			<emphasis role='bold'><xref linkend="fr_timeout"/></emphasis> parameter.
			</para>
			<para>
			<emphasis>"$T_fr_timeout = NULL;"</emphasis> will reset it to
			<emphasis role='bold'><xref linkend="fr_timeout"/></emphasis>.
			</para>
		</section>
		<section>
		<title>$T_fr_inv_timeout</title>
			<para>
			<emphasis>$T_fr_inv_timeout (R/W)</emphasis> - the timeout
			for the final reply to an INVITE request, after a 1XX reply
			was received
			</para>
			<para>
			With each different request received,
			<emphasis>$T_fr_inv_timeout</emphasis> will initially be equal to the
			<emphasis role='bold'>
			<xref linkend="fr_inv_timeout"/></emphasis> parameter.
			</para>
			<para>
			<emphasis>"$T_fr_inv_timeout = NULL;"</emphasis> will reset it to
			<emphasis role='bold'><xref linkend="fr_inv_timeout"/></emphasis>.
			</para>
		</section>
		<section>
		<title>$T_ruri</title>
			<para>
			<emphasis>$T_ruri</emphasis> - the ruri of the current branch; this
			information is taken from the transaction structure, so you can
			access this information for any sip message (request/reply) that
			has a transaction.
			</para>
		</section>
		<section>
		<title>$bavp(name)</title>
			<para>
			<emphasis>$bavp(name)</emphasis> - a particular type of avp that
			can have different values for each branch. They can only be used in
			BRANCH, REPLY and FAILURE routes. Otherwise NULL value is returned.
			</para>
		</section>
		<section>
		<title>$T_id</title>
			<para>
			<emphasis>$T_id</emphasis> - returns the ID of the current 
			transaction. The ID is an opaque hexa string, unique for each
			transaction. If there is no current transaction,  NULL value is
			returned.
			</para>
		</section>

	</section>


	<section>
	<title>Exported MI Functions</title>

	<section>
		<title>
		<function moreinfo="none">t_uac_dlg</function>
		</title>
		<para>
		Generates and sends a local SIP request.
		</para>
		<para>Parameters: </para>
		<itemizedlist>
			<listitem><para>
				<emphasis>method</emphasis> - request method
			</para></listitem>
			<listitem><para>
				<emphasis>RURI</emphasis> - request SIP URI
			</para></listitem>
			<listitem><para>
				<emphasis>NEXT HOP</emphasis> - next hop SIP URI (OBP);
				use <quote>.</quote> if no value.
			</para></listitem>
			<listitem><para>
				<emphasis>socket</emphasis> - local socket to be used for
				sending the request; use <quote>.</quote> if no value.
			</para></listitem>
			<listitem><para>
				<emphasis>headers</emphasis> - set of additional headers to
				be added to the request; at least 
				<quote>From</quote> and <quote>To</quote> headers must be
				specify)
			</para></listitem>
			<listitem><para>
				<emphasis>body</emphasis> - (optional, may not be present)
				request body (if present, requires the 
				<quote>Content-Type</quote> and <quote>Content-length</quote>
				headers)
			</para></listitem>
		</itemizedlist>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_uac_cancel</function>
		</title>
		<para>
		Generates and sends a CANCEL for an existing SIP request.
		</para>
		<para>Parameters: </para>
		<itemizedlist>
			<listitem><para>
				<emphasis>callid</emphasis> - callid of the INVITE request
				to be cancelled.
			</para></listitem>
			<listitem><para>
				<emphasis>cseq</emphasis> - cseq of the INVITE request to be
				cancelled.
			</para></listitem>
		</itemizedlist>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_hash</function>
		</title>
		<para>
		Gets information about the load of TM internal hash table.
		</para>
		<para>Parameters: </para>
		<itemizedlist>
			<listitem><para>
				<emphasis>none</emphasis>
			</para></listitem>
		</itemizedlist>
	</section>

	<section>
		<title>
		<function moreinfo="none">t_reply</function>
		</title>
		<para>
		Generates and sends a reply for an existing inbound SIP transaction.
		</para>
		<para>Parameters: </para>
		<itemizedlist>
			<listitem><para>
				<emphasis>code</emphasis> - reply code
			</para></listitem>
			<listitem><para>
				<emphasis>reason</emphasis> - reason phrase.
			</para></listitem>
			<listitem><para>
				<emphasis>trans_id</emphasis> - transaction identifier
				(has the hash_entry:label format)
			</para></listitem>
			<listitem><para>
				<emphasis>to_tag</emphasis> - To tag to be added to TO header
			</para></listitem>
			<listitem><para>
				<emphasis>new_headers</emphasis> - extra headers to be
				appended to the reply; use a dot (<quote>.</quote>) char 
				only if there are no headers;
			</para></listitem>
			<listitem><para>
				<emphasis>body</emphasis> - (optional, may not be present)
				reply body (if present, requires the 
				<quote>Content-Type</quote> and <quote>Content-length</quote>
				headers)
			</para></listitem>
		</itemizedlist>
	</section>

	</section>


	<section>
		<title>Exported statistics</title>
		<para>
		Exported statistics are listed in the next sections. All statistics
		except <quote>inuse_transactions</quote> can be reset.
		</para>
		<section>
		<title>received_replies</title>
			<para>
			Total number of total replies received by TM module.
			</para>
		</section>
		<section>
		<title>relayed_replies</title>
			<para>
			Total number of replies received and relayed by TM module.
			</para>
		</section>
		<section>
		<title>local_replies</title>
			<para>
			Total number of replies local generated by TM module.
			</para>
		</section>
		<section>
		<title>UAS_transactions</title>
			<para>
			Total number of transactions created by received requests.
			</para>
		</section>
		<section>
		<title>UAC_transactions</title>
			<para>
			Total number of transactions created by local generated requests.
			</para>
		</section>
		<section>
		<title>2xx_transactions</title>
			<para>
			Total number of transactions completed with 2xx replies.
			</para>
		</section>
		<section>
		<title>3xx_transactions</title>
			<para>
			Total number of transactions completed with 3xx replies.
			</para>
		</section>
		<section>
		<title>4xx_transactions</title>
			<para>
			Total number of transactions completed with 4xx replies.
			</para>
		</section>
		<section>
		<title>5xx_transactions</title>
			<para>
			Total number of transactions completed with 5xx replies.
			</para>
		</section>
		<section>
		<title>6xx_transactions</title>
			<para>
			Total number of transactions completed with 6xx replies.
			</para>
		</section>
		<section>
		<title>inuse_transactions</title>
			<para>
			Number of transactions existing in memory at current time.
			</para>
		</section>
	</section>

</chapter>

