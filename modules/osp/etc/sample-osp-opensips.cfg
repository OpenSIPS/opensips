
log_level=3     # debug level (cmd line: -dddddddddd)
log_stderror=no # (cmd line: -E)
sip_warning=no

/* Uncomment these line to enter debugging mode */
#debug_mode=yes

check_via=no    # (cmd. line: -v)
dns=no          # (cmd. line: -r)
rev_dns=no      # (cmd. line: -R)
disable_dns_blacklist=yes
socket=udp:127.0.0.1:5060
udp_workers=64

# --------- module loading -------------------------------------------
mpath="/usr/local/lib/opensips/modules"
loadmodule "sl.so"
loadmodule "tm.so"
loadmodule "maxfwd.so"
loadmodule "rr.so"
loadmodule "sipmsgops.so"
loadmodule "usrloc.so"
loadmodule "signaling.so"
loadmodule "registrar.so"
loadmodule "auth.so"
loadmodule "mi_fifo.so"
loadmodule "options.so"
loadmodule "avpops.so"
loadmodule "proto_udp.so"
# Load OSP module
loadmodule "osp.so"
# For SIP From header modification
# loadmodule "uac_auth.so"
# loadmodule "uac.so"
# For CNAM SUBSCRIBE/NOTIFY
# loadmodule "cachedb_local.so"

# --------- setting module-specific parameters -----------------------

#
# PEERING PARAMETERS
# ====================================================================
# This section contains configuration parameters that enables OpenSIPS
# to communicate with one or more OSP servers for routing and CDR
# collection. The parameter sp1_uri must be configured. Additional
# detail on OSP Module parameters and functions is provided in the
# "OSP Module for Secure, Multi-Lateral Peering" document located at
# https://opensips.org/docs/modules/devel/osp.html
#

#
# Configure Work Mode
# ====================================================================
# This parameter is used to tell the OSP module the work mode it
# should work in.  The default value is 0.
#
# 0 - Direct
# 1 - Indirect
#
modparam("osp", "work_mode", 1)

#
# Configure Service Type
# ====================================================================
# This parameter is used to tell the OSP module the service type it
# should provide.  The default value is 0.
#
# 0 - Normal voice service
# 1 - Ported number query service
# 2 - CNAM query service
# 3 - STIR query service
#
# modparam("osp", "service_type", 0)

#
# Configure OSP Servers
# ====================================================================
# OpenSIPS can be configured to query up to 16 OSP servers for routing
# information, number portability correction and peering authorization
# tokens using the sp1_uri to sp16_uri parameters.  Each spX_uri is
# the configuration for an OSP server.  A configuration for sp1_uri
# is required. Configuring other OSP servers, using sp2_uri, ...,
# sp16_uri parameters, is optional. The OSP server address should be
# configured as a standard URL beginning with either http:// or
# https:// followed by the domain name of the OSP server or the IP
# address enclosed in brackets. The domain name or IP address should
# be followed by the peering server TCP port number and uniform
# resource identifier. Below are example configurations.
#
modparam("osp", "sp1_uri", "http://osptestserver.transnexus.com:5045/osp")
# modparam("osp", "sp2_uri", "https://[1.2.3.4]:1443/osp")

#
# OpenSIPS IP Address
# ====================================================================
# device_ip is a recommended parameter that explicitly defines the IP
# address of OpenSIPS in an OSP AuthorizationRequest message (as
# SourceAlternate type=transport).  The IP address must be in brackets
# as shown in the example below.
#
# modparam("osp", "device_ip", "[127.0.0.1]:5060")

#
# Use OSP Security Features
# ====================================================================
# This parameter is used to tell the OSP module if the OSP security
# features should be used.  The default value is 0.
#
# 0 - OSP module will not use the OSP security features.
# 1 - OSP module will use the OSP security features.
#
# modparam("osp", "use_security_features", 0)

#
# Peering Token Validation
# ====================================================================
# When OpenSIPS receives a SIP INVITE with an OSP peering token, the
# OSP Module will validate the token to determine whether or not the
# call has been authorized by a trusted OSP server.  OSP peering
# tokens may, or may not, be digitally signed.  This parameter defines
# if OpenSIPS will validate signed or unsigned tokens or both. The
# values for "token format" are defined below.  The default value
# is 2. If the use_security_features parameter is set to 0, signed
# tokens cannot be validated.
#
# 0 - Validate only signed tokens.  Calls with valid signed tokens are
#     allowed.
# 1 - Validate only unsigned tokens.  Calls with valid unsigned tokens
#     are allowed.
# 2 - Validate both signed and unsigned tokens are allowed.  Calls
#     with valid tokens are allowed.
#
# modparam("osp", "token_format", 2)

#
# Crypto files from Peering Server Enrollment
# ====================================================================
# These parameters identify crypto files used for validating peering
# authorization tokens and establishing a secure channel between
# OpenSIPS and an OSP server using SSL.  The files may be generated
# using the 'Enroll' utility from the OSP Toolkit.  By default, the
# proxy will look for pkey.pem, localcert.pem, and cacart_0.pem in the
# default configuration directory.
#
# The default config directory is set at compile time using CFG_DIR
# and defaults to /usr/local/etc/opensips/.  The files may be copied
# to the expected file location or the parameters below may be
# changed. If the use_security_features parameter is set to 0, these
# parameters will be ignored.
#
# If the default CFG_DIR value was used at compile time, the files
# will be loaded from:
# modparam("osp", "private_key", "/usr/local/etc/opensips/pkey.pem")
# modparam("osp", "local_certificate", "/usr/local/etc/opensips/localcert.pem")
# modparam("osp", "ca_certificates", "/usr/local/etc/opensips/cacert_0.pem")

#
# Support non-SIP signaling protocols
# ====================================================================
# This parameter is used to tell the OSP module if non-SIP signaling
# protocols are supported.  The default value is 0.
#
# modparam("osp", "support_nonsip_protocol", 0)

#
# Max number of destiantions
# ====================================================================
# This parameter is used to tell OSP servers max how many destinations
# should be returned.  It is up to 12.  The default value is 12.
#
# modparam("osp", "max_destinations", 12)

#
# Report Network ID in CDRs
# ====================================================================
# This parameter is used to tell the OSP module if to report
# network IDs in completed call CDRs.  The default value is 3.
#
# 0 - Do not report any network ID.
# 1 - Report source network ID.
# 2 - Report destination network ID.
# 3 - Report both source and destination network ID.
#
# modparam("osp", "report_networkid", 3)

#
# Use Number Portability parameters
# ====================================================================
# This parameter is used to tell the OSP module if the number
# portability parameters should be obtained from RURI.  The default
# value is 1.
#
# 0 - OSP module will not use the number portability parameters.
# 1 - OSP module will use the number portability parameters in RURI in
#     Authorization Request to OSP server if these parameters exist in
#     the INVITE received from the UA.
#
# modparam("osp", "use_number_portability", 1)

#
# Export Number Portability parameter order
# ====================================================================
# This parameter is used to tell the OSP module how to export number
# portability parameters.  The default value is 0.
#
# 0 - OSP module will export the number portability parameters in
#     default order.
# 1 - OSP module will export the number portability parameters in the
#     order that rn is the last parameter.
#
# modparam("osp", "export_npparameter_order", 0)

#
# Append "user=phone" Parameter
# ====================================================================
# This parameter is used to tell the OSP module if the "user=phone"
# parameter, which indicates that the user portion of the URI should
# be treated as a tel URI, should be appended.  The default value is
# 0.
#
# modparam("osp", "append_userphone", 0)

#
# Destination Network ID Location
# ====================================================================
# This parameter is used to tell the OSP module where the destination
# network ID should be appended.  The default value is 2.
#
# 0 - network ID is not appended.
# 1 - network ID is appended as userinfo parameter.
# 2 - network ID is appended as URI parameter.
#
# modparam("osp", "networkid_location", 2)

#
# Destination Network ID Parameter Name
# ====================================================================
# This parameter is used to tell the OSP module the parameter name
# that is used to carry destination network ID.  The default value is
# "networkid".
#
# modparam("osp", "networkid_parameter", "networkid")

#
# Destination Switch ID Location
# ====================================================================
# This parameter is used to tell the OSP module where the destination
# switch ID should be appended.  The default value is 2.
#
# 0 - switch ID is not appended.
# 1 - switch ID is appended as userinfo parameter.
# 2 - switch ID is appended as URI parameter.
#
# modparam("osp", "switchid_location", 2)

#
# Destination Switch ID Parameter Name
# ====================================================================
# This parameter is used to tell the OSP module the parameter name
# that is used to carry destination switch ID.  The default value is
# "switchid".
#
# modparam("osp", "switchid_parameter", "switchid")

#
# Parameter String Location
# ====================================================================
# This parameter is used to tell the OSP module where the parameter
# string should be appended in the outbound URI.  The default value is
# 0.
#
# 0 - parameter string is not appended.
# 1 - parameter string is appended as userinfo parameter.
# 2 - parameter string is appended as URI parameter.
#
# modparam("osp", "parameterstring_location", 0)

#
# Parameter String Value
# ====================================================================
# This parameter is used to tell the OSP module the parameter string
# that is appended in outbound URI.  The default value is empty.
#
# modparam("osp", "parameterstring_value", "")

#
# Source Device IP AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store source device IP in the indirect work mode.  The default
# value is "$avp(_osp_source_device_)".
#
# modparam("osp", "source_device_avp", "$avp(_osp_source_device_)")
modparam("osp", "source_device_avp", "$avp(srcdev)")

#
# Source Network ID AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store source network ID.  The default value is
# "$avp(_osp_source_networkid_)".
#
# modparam("osp", "source_networkid_avp", "$avp(_osp_source_networkid_)")
modparam("osp", "source_networkid_avp", "$avp(snid)")

#
# Source Switch ID AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store source switch ID.  The default value is
# "$avp(_osp_source_switchid_)".
#
# modparam("osp", "source_switchid_avp", "$avp(_osp_source_switchid_)")
modparam("osp", "source_switchid_avp", "$avp(swid)")

#
# Custom Information AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store custom information.  The default value is
# "$avp(_osp_custom_info_)".
#
# modparam("osp", "custom_info_avp", "$avp(_osp_custom_info_)")
modparam("osp", "custom_info_avp", "$avp(cinfo)")

#
# CNAM AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store CNAM.  The default value is "$avp(_osp_cnam_)".
#
# modparam("osp", "cnam_avp", "$avp(_osp_cnam_)")
modparam("osp", "cnam_avp", "$avp(cnam)")

#
# NOTIFY extra headers
# ====================================================================
# This parameter is used to tell the OSP module the extra SIP headers
# that are appended in NOTIFY.  The default value is empty.
#
# modparam("osp", "extraheaders_value", "Source: N")

#
# Media Address AVPs
# ====================================================================
# These parameters are used to tell the OSP module which AVPs are used
# to store media addresses.  The default values are
# "$avp(_osp_source_media_address_)" and
# "$avp(_osp_destination_media_address_)".
#
# modparam("osp", "source_media_avp", "$avp(_osp_source_media_address_)")
# modparam("osp", "destination_media_avp", "$avp(_osp_destination_media_address_)")
modparam("osp", "source_media_avp", "$avp(srcmedia)")
modparam("osp", "destination_media_avp", "$avp(destmedia)")

#
# Request Date header AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store request Date header.  The default value is
# "$avp(_osp_request_date_)".
#
# modparam("osp", "request_date_avp", "$avp(_osp_request_date_)")
modparam("osp", "request_date_avp", "$avp(reqdate)")

#
# SDP finger print attributes AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store SDP finger print attributes.  The default value is
# "$avp(_osp_sdp_fingerprint_)".
#
# modparam("osp", "sdp_fingerprint_avp", "$avp(_osp_sdp_fingerprint_)")
modparam("osp", "sdp_fingerprint_avp", "$avp(sdpfp)")

#
# Identity header AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store Identity header.  The default value is "$avp(_osp_identity_)"
#
# modparam("osp", "identity_avp", "$avp(_osp_identity_)")
modparam("osp", "identity_avp", "$avp(identity)")

#
# Service provider AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store source service provider information.  The default value is
# "$avp(_osp_service_provider_)".
#
# modparam("osp", "service_provider_avp", "$avp(_osp_service_provider_)")
modparam("osp", "service_provider_avp", "$avp(sp)")

#
# User group AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store calling party user group information.  The default value is
# "$avp(_osp_user_group_)".
#
# modparam("osp", "user_group_avp", "$avp(_osp_user_group_)")
modparam("osp", "user_group_avp", "$avp(groupid)")

#
# User ID AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store calling party user ID information.  The default value is
# "$avp(_osp_user_id_)".
#
# modparam("osp", "user_id_avp", "$avp(_osp_user_id_)")
modparam("osp", "user_id_avp", "$avp(userid)")

#
# Recommended Destination AVP
# ====================================================================
# This parameter is used to tell the OSP module which AVP is used to
# store recommended destination information.  The default value is
# "$avp(_osp_destination_)".
#
# modparam("osp", "destination_avp", "$avp(_osp_destination_)")
modparam("osp", "destination_avp", "$avp(dest)")

#
# SIP Reason header AVPs
# ====================================================================
# These parameters are used to tell the OSP module which AVPs are used
# to store SIP Reason header parameters.  The default values are
# "$avp(_osp_reason_type_)", "$avp(_osp_reason_cause_)" and
# "$avp(_osp_reason_text_)".
#
# modparam("osp", "reason_type_avp", "$avp(_osp_reason_type_)")
# modparam("osp", "reason_cause_avp", "$avp(_osp_reason_cause_)")
# modparam("osp", "reason_text_avp", "$avp(_osp_reason_text_)")
modparam("osp", "reason_type_avp", "$avp(reasontype)")
modparam("osp", "reason_cause_avp", "$avp(reasoncause)")
modparam("osp", "reason_text_avp", "$avp(reasontext)")

#
# -- mi_fifo params --
#
# The name of the FIFO file to be created for listening and reading
# external commands.
#
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")

# -- usrloc params --
#
# Disable the usrloc module to utilize database for persistent
# contact storage.
#
modparam("usrloc", "db_mode", 0)

# -- rr params --
#
# Enable append_fromtag, request's from-tag is appended to
# Record-Route. This is useful for understanding whether subsequent
# requests (such as BYE) come from caller (route's from-tag == BYE's
# from-tag) or callee (route's from-tag == BYE's to-tag).
#
modparam("rr", "append_fromtag", 1)

# -- tm params --
#
# Timer which hits if there is no response (including provisional
# messages such as 100, 180, 183, ..., etc.) for a request such as
# INVITE, RE-INVITE or BYE after fr_timeout seconds.
#
# For the INVITE use case, if the proxy does not receive a response
# to an INVITE before this timer expires, the proxy will retry the
# call and send an INVITE to the next VoIP destination in the routing
# list.
#
# For the RE-INVITE and BYE use cases, if the proxy does not receive
# a response before this timer expires, the proxy will send a SIP 408
# Timeout message to the source of the request.
#
modparam("tm", "fr_timeout", 2)

#
# Timer which hits if no final reply for an INVITE arrives after a
# provisional message was received (in seconds).  For example, user is
# not picking up the phone.
#
modparam("tm", "fr_inv_timeout", 5)
modparam("tm", "onreply_avp_mode", 1)
modparam("tm", "restart_fr_on_each_reply", 1)

# -- cachedb_local params --
#
# The size of the hash table. This parameter will be used as the power
# of 2 when computing table size.  The default value is 9 (512)
#
# modparam("cachedb_local", "cache_table_size", 21)

# --------- request routing logic ------------------------------------

# main routing logic
route{
    xlog("L_INFO", "----ROUTE: Route IN - M=$rm RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

    # initial sanity checks
    if (!mf_process_maxfwd_header("10")) {
        xlog("L_WARN", "----ROUTE: Too many hops, $rm from '$fu' to '$tu'\n");
        sl_send_reply("483", "Too Many Hops");
        return;
    };

    # we record-route all messages -- to make sure that
    # subsequent messages will go through our proxy; this
    # is useful if upstream and downstream entities
    # use different transport protocol
    record_route();

    # loose-route processing
    if (loose_route()) {
        if ($rm == "INVITE") {
            log(2, "----ROUTE: Relay re-INVITE\n");
            # send it out now; use stateful forwarding as it works
            # reliably even for UDP2TCP
            if (!t_relay("0x02")) {
                sl_reply_error();
            }
            return;
        } else if ($rm == "ACK") {
            log(2, "----ROUTE: Relay ACK\n");
            # send it out now; use stateful forwarding as it works
            # reliably even for UDP2TCP
            if (!t_relay("0x02")) {
                sl_reply_error();
            }
            return;
        }
    } else {
        if ($rm == "BYE") {
            xlog("L_WARN", "----ROUTE: Processing BYE without route header - F=$fu T=$tu IP=$si ID=$ci\n");
            if (t_check_trans()) {
                log(2, "----ROUTE: Duplicated BYE\n");
            } else {
                # NOTE - don't t_relay before reporting usage
                log(2, "----ROUTE: BYE from UNKNOWN\n");
                if (!reportospusage("2")) {
                    xlog("L_WARN", "----ROUTE: failed to report usage, from '$fu' to '$tu'\n");
                }
                sl_send_reply("400", "Bad Request - no route header in BYE message");
            }
            return;
        }
    }

    if ($rm == "INVITE") {
        log(2, "----ROUTE: Processing INVITE\n");

        # Stop retransmission
        append_to_reply("X-Progress-Date: $time(%Y-%m-%dT%H:%M:%S).$Tsm\r\n");
        sl_send_reply("100", "Trying");

        if (t_check_trans()) {
            log(2, "----ROUTE: Duplicated INVITE\n");
            return;
        }

        # Authentication
        log(3, "OSP authorization validation logic\n");

        # This function looks for OSP peering token in the message.
        # It will fail if the token is not present
        if (checkospheader()) {
            log(3, "With OSP token, validate it\n");

            # The function validates OSP tokens.  It will fail if the
            # token is not valid or has expired
            validateospheader();
            switch ($retcode) {
                case 1:
                    # Authorization is valid.  The proxy can now use
                    # its own database of registered users for
                    # routing information.
                    # The proxy could also issue another OSP peering
                    # authorization and routing request by calling
                    # route(1) function.
                    log(3, "OSP authorization valid\n");

                    # Remove the OSP peering token from the received
                    # message otherwise it will be forwarded on to
                    # the next hop
                    remove_hf("P-OSP-Auth-Token");
                    break;
                case -2:
                    log(2, "----ROUTE: Internal server error\n");
                    sl_send_reply("500", "Internal Server Error");
                    return;
                default:
                    log(2, "----ROUTE: OSP authorization invalid\n");
                    sl_send_reply("401", "Unauthorized");
                    return;
            };
        } else {
            log(3, "Without OSP token, apply different authentication strategy\n");
            log(3, "Go ahead, everyone is welcomed\n");

            # Implement authentication strategy here or simply add the
            # statements below to block all invites without OSP
            # peering tokens
            # sl_send_reply("401", "Unauthorized");
            # return;
        }

        log(2, "----ROUTE: Authentication passed\n");

        # Routing

#        if (lookup("location")) {
#            log(2, "----ROUTE: Registered user, forward the message\n");
#            append_hf("P-hint: usrloc\r\n");
#            t_relay();
#        } else {
#            log(2, "----ROUTE: Unregistered user, use OSP to get routing\n");
#            route(2);
#        }

        log(2, "----ROUTE: Use OSP to get routing\n");
        route(2);
    } else if ($rm == "ACK") {
        log(2, "----ROUTE: Processing ACK\n");

        if (t_check_trans()) {
            log(2, "----ROUTE: Relay E2E ACK\n");
            t_relay();
        } else {
            log(2, "----ROUTE: Not to relay ACK");
        }
    } else if ($rm == "BYE") {
        log(2, "----ROUTE: Processing BYE\n");

        xlog("L_INFO", "----ROUTE: R=$hdr(Route)\n");

        if (t_check_trans()) {
            log(2, "----ROUTE: Duplicated BYE\n");
            return;
        }

        # NOTE - don't t_relay before reporting usage
        if (is_direction("downstream")) {
            log(2, "----ROUTE: BYE from SOURCE\n");
            if (!reportospusage("0")) {
                xlog("L_WARN", "----ROUTE: failed to report usage, from '$fu' to '$tu'\n");
            }
        } else {
            log(2, "----ROUTE: BYE from DESTINATION\n");
            if (!reportospusage("1")) {
                xlog("L_WARN", "----ROUTE: failed to report usage, from '$fu' to '$tu'\n");
            }
        }
        t_relay();
    } else if ($rm == "CANCEL") {
        log(2, "----ROUTE: Processing CANCEL\n");
        if (t_check_trans()) {
            t_relay();
        } else {
            xlog("L_WARN", "----ROUTE: CANCEL without matching transaction, from '$fu' to '$tu'\n");
        }
    } else if (($rm == "OPTIONS") && is_myself("$rd")) {
        log(2, "----ROUTE: Processing OPTIONS\n");
        $var(username) = "metaswitch";
        if (($rU == $var(username)) && ($tU == $var(username)) && ($fU == $var(username))) {
            xlog("L_INFO", "----ROUTE: OPTIONS with username '$var(username)'\n");
            sl_send_reply("200", "OPTIONS OK");
        } else {
            options_reply();
        }
    } else if ($rm == "PRACK") {
        log(2, "----ROUTE: Processing PRACK\n");
        t_relay();
    } else if ($rm == "INFO") {
        log(2, "----ROUTE: Processing INFO\n");
        t_relay();
    } else if ($rm == "UPDATE") {
        log(2, "----ROUTE: Processing UPDATE\n");
        t_relay();
#    } else if ($rm == "REGISTER") {
#        log(2, "----ROUTE: Processing REGISTER\n");
#
#        # Stop retransmission
#        sl_send_reply("100", "Trying");
#
#        if (is_myself("$rd")) {
#            log(2, "----ROUTE: Registered\n");
#            save("location");
#        } else {
#            log(2, "----ROUTE: Register from outside domain rejected\n");
#            sl_send_reply("488", "Unknown Domain");
#        }
#    } else if ($rm == "SUBSCRIBE") {
#        log(2, "----ROUTE: Processing SUBSCRIBE\n");
#
#        # Retrive Event header
#        $var(SEVENTREG) = "/^([^;]*).*/\1/s";
#        $var(sevent) = $(hdr(Event){re.subst,$var(SEVENTREG)});
#        if (($var(sevent) == "calling-name") && is_myself("$rd")) {
#            # Retrive calling number
#            $var(CLGPARTYREG) = "/.*Calling-party: *([^\r\n]*).*/\1/s";
#            $var(clgparty) = $(rb{re.subst,$var(CLGPARTYREG)});
#            $var(sclg) = $(var(clgparty){uri.user});
#
#            # Search local cache
#            $var(cnamrecord) = NULL;
#            cache_fetch("local", "CNAM_$var(sclg)", $var(cnamrecord));
#            if ($retcode && ($var(cnamrecord) != NULL)) {
#                xlog("L_INFO", "----ROUTE: Find cached CNAM record for '$var(sclg)' '$var(cnamrecord)'\n");
#
#                # Process SUBSCRIBE
#                processsubscribe("$(var(cnamrecord){s.b64decode})");
#            } else {
#                xlog("L_INFO", "----ROUTE: Failed to find cached CNAM record for '$var(sclg)'\n");
#
#                # Relay SUBSCRIBE to XXX and YYY
#                if (!t_relay("XXX", "0x02")) {
#                    log(2, "----ROUTE: t_relay SUBSCRIBE to XXX failed.\n");
#                    if (!t_relay("YYY", "0x02")) {
#                        log(2, "----ROUTE: t_relay SUBSCRIBE to YYY failed.\n");
#                        sl_reply_error();
#                    }
#                }
#            }
#        } else {
#            log(2, "----ROUTE: t_relay SUBSCRIBE.\n");
#            t_relay();
#        }
#    } else if ($rm == "NOTIFY") {
#        log(2, "----ROUTE: Processing NOTIFY\n");
#
#        # Retrive Event header
#        $var(NEVENTREG) = "/^([^;]*).*/\1/s";
#        $var(nevent) = $(hdr(Event){re.subst,$var(NEVENTREG)});
#        if ($var(nevent) == "calling-name") {
#            # Retrieve calling number
#            $var(CLGNAMEREG) = "/.*Calling-Name: *([^\r\n]*).*/\1/s";
#            $var(clgname) = $(rb{re.subst,$var(CLGNAMEREG)});
#            $var(nclg) = $(var(clgname){nameaddr.uri}{uri.user});
#
#            # Cache CNAM resultes
#            $var(cnamentry) = $(rb{s.b64encode});
#            xlog("L_INFO", "----ROUTE: Cache CNAM for '$var(nclg)' '$var(cnamentry)'\n");
#            cache_store("local", "CNAM_$var(nclg)", "$var(cnamentry)", 86400);
#        }
#
#        t_relay();
    } else {
        xlog("L_WARN", "----ROUTE: Unsupported message, $rm from '$fu' to '$tu'\n");
        sl_send_reply("500", "Unsupported Message");
    }

    log(3, "----ROUTE: Route OUT\n");
}


# OSP Authorization and Routing
route[2] {
    log(3, "OSP authorization and routing logic\n");

    # Is request to a phone number?
    # A phone number consists of digits (0 through 9)
    # and can begin with +
#    if ($ru =~ "sip:[+,0-9][0-9]*@") {
        # Requesting OSP peering routing and authorization
        # The request may fail if:
        #  o OSP peering servers are not available
        #  o Authentication failed
        #  o There is no route to destination or the route is blocked
        log(3, "Requesting OSP authorization and routing\n");

        # Get actual source device IP
        if (is_present_hf("P-Source-Device")) {
            $avp(srcdev) = $hdr(P-Source-Device);
        }

        # Get source network ID
        # OpenSIPS can include a specific header parameter as the
        # source NetworkId in an OSP AuthorizationRequest to an OSP
        # server. Below are two example configurations for this
        # feature.
        #
        # Uncomment the lines below to use the URI user tgrp parameter
        # value in the Contact ($ct) as the source NetworkId
        # ($avp(snid)).
        # if (is_present_hf("Contact")) {
        #     if ($(ct.fields(uri){uri.user}{param.exist, tgrp})) {
        #         $avp(snid) = $(ct.fields(uri){uri.user}{param.value, tgrp});
        #     }
        # }
        #
        # Uncomment the lines below to use the otg parameter value in
        # the From URI ($fu) as the source NetworkId ($avp(snid)).
        # if ($(fu{uri.params}{param.exist, otg})) {
        #     $avp(snid) = $(fu{uri.param, otg});
        # }
        #
        # Uncomment the lines below to use the TGID parameter value in
        # the From header as the source NetworkId ($avp(snid)).
        # $var(PARAMREG) = "/^[^>]*>;//";
        # $var(fparam) = $(hdr(From){re.subst,$var(PARAMREG)});
        # if ($(var(fparam){param.exist, TGID})) {
        #     $avp(snid) = $(var(fparam){param.value, TGID});
        # }
        # if ($(var(fparam){param.exist, SWID})) {
        #     $avp(swid) = $(var(fparam){param.value, SWID});
        # }
        #
        # Uncomment the lines below to use P-Call-Owner SIP header
        # value as the source NetworkId ($avp(snid)).
        # if (is_present_hf("P-Call-Owner")) {
        #     $avp(snid) = $hdr(P-Call-Owner);
        # }
        #
        # Uncomment the lines below to use P-Network-ID SIP header
        # value as the source NetworkId ($avp(snid)).
        if (is_present_hf("P-Network-ID")) {
            $avp(snid) = $hdr(P-Network-ID);
        }

        # Get custom info
        # Uncomment the lines below to use P-Custom-Info SIP header
        # value as the custom info ($avp(cinfo)).
        if (is_present_hf("P-Custom-Info")) {
            $avp(cinfo) = $hdr(P-Custom-Info);
        }

        # Get request Date header
        if (is_present_hf("Date")) {
            $avp(reqdate) = $hdr(Date);
        } else {
            setrequestdate();
            if (is_avp_set("$avp(reqdate)")) {
                append_hf("Date: $avp(reqdate)\r\n");
            }
        }

        # Get source service provider
        # Uncomment the lines below to use P-Service-Provider SIP
        # header value as the source service provider ($avp(sp)).
        # if (is_present_hf("P-Service-Provider")) {
        #     $avp(sp) = $hdr(P-Service-Provider);
        # }

        # Get source user group
        # Uncomment the lines below to use P-User-Group SIP header
        # value as the source user group ($avp(groupid)).
        # if (is_present_hf("P-User-Group")) {
        #     $avp(groupid) = $hdr(P-User-Group);
        # }

        # Get source user ID
        # Uncomment the lines below to use X-BroadWorks-Dnc SIP header
        # user-id parameter value as the source user ID
        # ($avp(userid)).
        if (is_present_hf("X-Broadworks-Dnc") && $(hdr(X-Broadworks-Dnc){param.exist,user-id})) {
            $avp(userid) = $(hdr(X-Broadworks-Dnc){param.value, user-id});
        }

        # Get recommended destination
        # Uncomment the line below to set recommended destination ($avp(dest)) for
        # non-voice service.
        # $avp(dest) = "127.0.0.1:5060";

        # SDP related AVPs
        if(has_body("application/sdp")) {
            # Get source media address
            if ($(rb{sdp.line,c}) != NULL) {
                $avp(srcmedia) = $(rb{sdp.line,c}{s.substr,9,0}{s.select,0,/});
            }
    
            # Get SDP finger print attributes
            $var(FPHEADER) = "a=fingerprint:";
            $var(FPREG) = "/^a=fingerprint: *//";
            $var(SPACEREG) = "/  / /g";
            $var(i) = 0;
            $var(aline) = $(rb{sdp.line,a,$var(i)});
            while ($(var(aline){s.len}) != 0) {
                $var(aheader) = $(var(aline){s.substr,0,$(var(FPHEADER){s.len})});
                if ($var(aheader) == $var(FPHEADER)) {
                    $avp(sdpfp) = $(var(aline){re.subst,$var(FPREG)}{re.subst,$var(SPACEREG)});
                }
                $var(i) = $var(i) + 1;
                $var(aline) = $(rb{sdp.line,a,$var(i)});
            }
        }

        $var(returncode) = requestosprouting();
        append_to_reply("X-Final-Date: $time(%Y-%m-%dT%H:%M:%S).$Tsm\r\n");
        switch ($var(returncode)) {
            # To change the OpenSIPS response for specific use cases,
            # edit the 'sl_send-reply...' lines in the cases above.
            # For example, to change the SIP response for a blocked
            # route from 403 to 404 change the line
            #   sl_send_reply("403", "Forbidden - Call is blocked");
            # to
            #   sl_send_reply("404", "Forbidden - Call is blocked");
            case 1:
                log(3, "Response received\n");

                if (checkosproute()) {
                    # Now we have 3 options.
                    #  o route(3) - sends a redirect for all available
                    #    routes, or a CNAM response
                    #  o route(4) - fork off to all available routes
                    #  o route(5) in conjunction with failure_route and
                    #    branch_route - sequentially tries all routes

                    # route(3);
                    # route(4);
                    route(5);
                } else {
                    xlog("L_WARN", "----ROUTE: No supported destination for call ID '$ci'.\n");
                    sl_send_reply("404", "Route Not Found - No supported route");
                }
                break;
            case -4000: # HTTP 400, missing OSP elements or bad message
            case -4001: # AuthRsp 400, not used
            case -4002: # STIR client end error
                xlog("L_WARN", "----ROUTE: Call to '$tU' from source device '$si' is a bad request.\n");
                sl_send_reply("400", "Bad Request");
                break;
            case -4010: # HTTP 401, invalid wire device
            case -4011: # AuthRsp 401, invalid transport or source device
                xlog("L_WARN", "----ROUTE: Call to '$tU' from source device '$si' is unauthorized on OSP Server.\n");
                sl_send_reply("401", "Unauthorized");
                break;
            case -4030: # Route blocked
                xlog("L_WARN", "----ROUTE: Call to '$tU' from source device '$si' is blocked on OSP Server.\n");
                sl_send_reply("403", "Forbidden - Call is blocked");
                break;
            case -4040: # Route not found
                xlog("L_WARN", "----ROUTE: No route on OSP server for call to '$tU' from source device '$si'.\n");
                sl_send_reply("404", "Route Not Found");
                break;
            case -4050: # Source may not originate
                xlog("L_WARN", "----ROUTE: Method not allowed on OSP server for call to '$tU' from source device '$si'.\n");
                sl_send_reply("405", "Method Not Allowed");
                break;
            case -4280: # Invalid calling number
                xlog("L_WARN", "----ROUTE: Calling number invalid for call to '$tU' from source device '$si'.\n");
                sl_send_reply("400", "Bad Request - Calling number invalid");
                break;
            case -4800: # OSPrey server not start
            case -4801: # OSPrey server timeout
            case -4802: # OSPrey server not ready
                xlog("L_WARN", "----ROUTE: Server not ready for call to '$tU' from source device '$si'.\n");
                sl_send_reply("480", "Temporarily Unavailable - Server not ready");
                break;
            case -4820: # Loop dectected
                xlog("L_WARN", "----ROUTE: Loop detected for call to '$tU' from source device '$si'.\n");
                sl_send_reply("482", "Loop Detected");
                break;
            case -4840: # Invalid called number
                xlog("L_WARN", "----ROUTE: Address incomplete for call to '$tU' from source device '$si'.\n");
                sl_send_reply("484", "Address Incomplete");
                break;
            case -5030: # Routing feature off, license exceeded or inbound device throttle
                xlog("L_WARN", "----ROUTE: Service not available for call to '$tU' from source device '$si'.\n");
                sl_send_reply("503", "Service Not Available");
                break;
            case -6030: # Fraud or STIR server end error
                xlog("L_WARN", "----ROUTE: Call to '$tU' from source device '$si' is declined on OSP Server.\n");
                # Set SIP Reason header
                route(8);
                sl_send_reply("603", "Decline");
                break;
            case -2:    # Internal error
                log(2, "----ROUTE: Internal server error\n");
                sl_send_reply("500", "Internal Server Error");
                break;
            default:    # Unspecified server error
                log(2, "----ROUTE: OSP Authorization failed\n");
                sl_send_reply("503", "Service Not Available - Unspecified");
        }
#    } else {
#        log(3, "Wrong phone number\n");
#        sl_send_reply("401", "Not Phone Number");
#    }
}


# The SIP 300 message indicates multiple destinations are returned
# for the call.  The user agent can try one or more the destinations
# to complete the call.
# The SIP 301 message indicates that the called party has moved
# permanently and cannot be found at the Request-URI address.  A 301
# response would not be a expected response for an OSP query.
# The SIP 302 message indicates the user agent SHOULD retry the request
# at the new address(es) given in the redirect Contact header field.
#
# To change the SIP response for the route[3] use case, edit the
# sl_send_reply... configuration.  For example, to change the 300
# response to 302, change from
#   sl_send_reply("300", "Redirect");
# to
#   sl_send_reply("302", "Redirect");
route[3] {
    log(3, "Prepare response\n");

    prepareospresponse();
    switch ($retcode) {
    case 300:
        if (is_avp_set("$avp(identity)")) {
            append_to_reply("Identity: $avp(identity)\r\n");
        }
        sl_send_reply("300", "Redirect");
        break;
    case 380:
        if (is_avp_set("$avp(cnam)")) {
            append_to_reply("P-Asserted-Identity: $avp(cnam) <$fu>\r\n");
        } else {
            append_to_reply("P-Asserted-Identity: $fu\r\n");
        }
        sl_send_reply("380", "CNAM Lookup");
        break;
    default:
        log(3, "Failed to prepare response\n");
        sl_send_reply("500", "Internal Server Error");
    }
}


route[4] {
    log(3, "Prepare all routes and fork-off\n");

    if (is_avp_set("$avp(identity)")) {
        append_hf("Identity: $avp(identity)\r\n");
    }

    if (prepareallosproutes()) {
        t_relay();
    } else {
        log(3, "Failed to prepare all routes\n");
        sl_send_reply("500", "Internal Server Error");
    }
}


route[5] {
    log(3, "Try the 1st route\n");

    if (is_avp_set("$avp(identity)")) {
        append_hf("Identity: $avp(identity)\r\n");
    }

    t_on_branch("1");

    t_on_reply("1");

    t_on_failure("1");

    # Reset fr_inv_timeout
    $T_fr_inv_timeout = null;

    # For SIP From header modification
    # route(7);

    if (!t_relay("0x02")) {
        xlog("L_WARN", "----ROUTE: t_relay failed.\n");
        route(6);
    }
}


route[6] {
    log(3, "Try the next route\n");

    if (checkosproute()) {
        t_on_branch("1");

        t_on_reply("1");

        t_on_failure("1");

        # Reset fr_inv_timeout
        $T_fr_inv_timeout = null;

        $var(returncode) = t_relay("0x02");
        if (!$var(returncode)) {
            if ($var(returncode) == -3) {
                xlog("L_WARN", "----ROUTE: cancelled.\n");
                t_reply("487", "Request Cancelled");
            } else {
                xlog("L_WARN", "----ROUTE: t_relay failed.\n");
                route(6);
            }
        }
    } else {
        xlog("L_WARN", "----ROUTE: All destinations attempted for call ID '$ci'. Call cannot be completed.\n");
        t_reply("503", "Service Not Available - Call cannot be completed");
    }
}


# For SIP From header modification
#route[7] {
#    log(3, "Remove otg parameter\n");
#
#    if ($(fu{param.exist, otg})) {
#        $avp(from) = $fu;
#        avp_subst("$avp(from)", "/(.*);otg=([^;]*)(.*)/\1\3/");
#        xlog("L_INFO", "----ROUTE: New From URI = $avp(from)\n");
#        uac_replace_from("$avp(from)");
#    } else {
#        log(3, "Without otg parameter\n");
#    }
#}


# For STIR
route[8] {
    log(3, "Insert SIP Reason header\n");

    if (is_avp_set("$avp(reasontype)")) {
        $var(type) = $avp(reasontype);
        if (is_avp_set("$avp(reasoncause)")) {
            $var(cause) = ";cause=" + $avp(reasoncause);
        }
        if (is_avp_set("$avp(reasontext)")) {
            $var(text) = ";text=\"" + $avp(reasontext) + "\"";
        }
        append_to_reply("Reason: $var(type)$var(cause)$var(text)\r\n");
    }
}


onreply_route[1] {
    # Get local egress address
    getlocaladdress();

    if (t_check_status("180") || t_check_status("183")) {
        log(3, "180/183 received\n");

        # Reset fr_inv_timeout
        $T_fr_inv_timeout = 60;
    } else if (t_check_status("200")) {
        # Get destination media address
        if(has_body("application/sdp")) {
            if ($(rb{sdp.line,c}) != NULL) {
                $avp(destmedia) = $(rb{sdp.line,c}{s.substr,9,0}{s.select,0,/});
            }
        }
    }
}


failure_route[1] {
    if (t_check_status("487")) {
        log(3, "Call canceled (status 487)\n");
        return;
    }

    if (t_check_status("486")) {
        log(3, "User busy (status 486)\n");
        return;
    }

    if (t_check_status("408")) {
        if (!t_local_replied("last")) {
            log(3, "User unavailable (status 408)\n");
            return;
        }
    }

    if (t_check_status("6[0-9][0-9]")) {
        log(3, "Declined (status 6xx)\n");
        return;
    }

    if (t_was_cancelled()) {
        log(3, "Call cancelled\n");
        return;
    }

    route(6);
}


branch_route[1] {
    log(3, "Prepare route specific OSP information\n");

    if (prepareosproute()) {
        # Only add/change Remote-Party-ID if calling number is translated
        if (checkcallingtranslation()) {
            log(3, "Calling number translated, add a new RPID header\n");

            # Remove the Remote_Party-ID from the received message
            # Otherwise it will be forwarded on to the next hop
            remove_hf("Remote-Party-ID");

            # Append a new Remote_Party
            append_rpid_hf();
        }
    } else {
        drop();
    }
}

