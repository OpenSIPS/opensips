usrloc Module
     __________________________________________________________

   Table of Contents

   1. Admin Guide

        1.1. Overview
        1.2. Distributed SIP User Location

              1.2.1. "Federation" Topology
              1.2.2. "Full Sharing" Topology
              1.2.3. "N Contact Pings" Problem

        1.3. Contact matching
        1.4. Dependencies

              1.4.1. OpenSIPS Modules
              1.4.2. External Libraries or Applications

        1.5. Exported Parameters

              1.5.1. nat_bflag (string)
              1.5.2. contact_id_column (string)
              1.5.3. user_column (string)
              1.5.4. domain_column (string)
              1.5.5. contact_column (string)
              1.5.6. expires_column (string)
              1.5.7. q_column (string)
              1.5.8. callid_column (string)
              1.5.9. cseq_column (string)
              1.5.10. methods_column (string)
              1.5.11. flags_column (string)
              1.5.12. cflags_column (string)
              1.5.13. user_agent_column (string)
              1.5.14. received_column (string)
              1.5.15. socket_column (string)
              1.5.16. path_column (string)
              1.5.17. sip_instance_column (string)
              1.5.18. kv_store_column (string)
              1.5.19. attr_column (string)
              1.5.20. use_domain (integer)
              1.5.21. desc_time_order (integer)
              1.5.22. timer_interval (integer)
              1.5.23. db_url (string)
              1.5.24. cachedb_url (string)
              1.5.25. db_mode (integer, deprecated)
              1.5.26. working_mode_preset (string)
              1.5.27. cluster_mode (string)
              1.5.28. restart_persistency (string)
              1.5.29. sql_write_mode (string)
              1.5.30. matching_mode (integer)
              1.5.31. cseq_delay (integer)
              1.5.32. location_cluster (integer)
              1.5.33. skip_replicated_db_ops (int)
              1.5.34. max_contact_delete (int)
              1.5.35. hash_size (integer)
              1.5.36. regen_broken_contactid (integer)
              1.5.37. latency_event_min_us (integer)
              1.5.38. latency_event_min_us_delta (integer)
              1.5.39. pinging_mode (string)
              1.5.40. mi_dump_kv_store (integer)

        1.6. Exported Functions
        1.7. Exported MI Functions

              1.7.1. ul_rm
              1.7.2. ul_rm_contact
              1.7.3. ul_dump
              1.7.4. ul_flush
              1.7.5. ul_add
              1.7.6. ul_show_contact
              1.7.7. ul_sync
              1.7.8. ul_cluster_sync

        1.8. Exported Statistics

              1.8.1. users
              1.8.2. contacts
              1.8.3. expires
              1.8.4. registered_users

        1.9. Exported Events

              1.9.1. E_UL_AOR_INSERT
              1.9.2. E_UL_AOR_DELETE
              1.9.3. E_UL_CONTACT_INSERT
              1.9.4. E_UL_CONTACT_DELETE
              1.9.5. E_UL_CONTACT_UPDATE
              1.9.6. E_UL_LATENCY_UPDATE

   2. Developer Guide

        2.1. Available Functions

              2.1.1. ul_register_domain(name)
              2.1.2. ul_insert_urecord(domain, aor, rec,
                      is_replicated)

              2.1.3. ul_delete_urecord(domain, aor, is_replicated)

              2.1.4. ul_get_urecord(domain, aor)
              2.1.5. ul_lock_udomain(domain)
              2.1.6. ul_unlock_udomain(domain)
              2.1.7. ul_release_urecord(record, is_replicated)
              2.1.8. ul_insert_ucontact(record, contact,
                      contact_info, contact, is_replicated)

              2.1.9. ul_delete_ucontact (record, contact,
                      is_replicated)

              2.1.10. ul_delete_ucontact_from_id (domain,
                      contact_id)

              2.1.11. ul_get_ucontact(record, contact)
              2.1.12. ul_get_domain_ucontacts (domain, buf, len,
                      flags)

              2.1.13. ul_get_all_ucontacts (buf, len, flags)
              2.1.14. ul_update_ucontact(record, contact,
                      contact_info, is_replicated)

              2.1.15. ul_bind_ursloc( api )
              2.1.16. ul_register_ulcb(type ,callback, param)
              2.1.17. ul_get_num_users()

   3. Contributors

        3.1. By Commit Statistics
        3.2. By Commit Activity

   4. Documentation

        4.1. Contributors

   List of Tables

   1.1. Possible values for the "pinging_mode", depending on the
          current "cluster_mode"

   3.1. Top contributors by DevScore^(1), authored commits^(2) and
          lines added/removed^(3)

   3.2. Most recently active contributors^(1) to this module

   List of Examples

   1.1. Set nat_bflag parameter
   1.2. Set contact_id_column parameter
   1.3. Set user_column parameter
   1.4. Set user_column parameter
   1.5. Set contact_column parameter
   1.6. Set expires_column parameter
   1.7. Set q_column parameter
   1.8. Set callid_column parameter
   1.9. Set cseq_column parameter
   1.10. Set methods_column parameter
   1.11. Set flags_column parameter
   1.12. Set cflags_column parameter
   1.13. Set user_agent_column parameter
   1.14. Set received_column parameter
   1.15. Set socket_column parameter
   1.16. Set path_column parameter
   1.17. Set sip_instance_column parameter
   1.18. Set kv_store_column parameter
   1.19. Set attr_column parameter
   1.20. Set use_domain parameter
   1.21. Set desc_time_order parameter
   1.22. Set timer_interval parameter
   1.23. Set db_url parameter
   1.24. Set cachedb_url parameter
   1.25. Set db_mode parameter
   1.26. Set working_mode_preset parameter
   1.27. Set cluster_mode parameter
   1.28. Set restart_persistency parameter
   1.29. Set sql_write_mode parameter
   1.30. Set matching_mode parameter
   1.31. Set cseq_delay parameter
   1.32. Setting the location_cluster parameter
   1.33. Setting the skip_replicated_db_ops parameter
   1.34. Setting the max_contact_delete parameter
   1.35. Set hash_size parameter
   1.36. Set regen_broken_contactid parameter
   1.37. Set latency_event_min_us parameter
   1.38. Set latency_event_min_us_delta parameter
   1.39. Set pinging_mode parameter
   1.40. Set mi_dump_kv_store parameter

Chapter 1. Admin Guide

1.1. Overview

   A SIP user location implementation. Its main purpose is to
   store, manage and provide access to SIP registration bindings
   (contacts) for other modules (e.g. registrar, mid-registrar,
   nathelper, etc.). The module exports no functions that could be
   directly used from the OpenSIPS script.

   At runtime, the contacts may reside in memory, in an SQL
   database or in a NoSQL database. Combinations of two of the
   above are also possible. For example, contacts may only be
   directly manipulated in memory in order to guarantee fast
   interactions while being asynchronously synchronized to an SQL
   database. The latter helps achieve restart persistency. Consult
   the working_mode_preset parameter for more details on all
   possible runtime behaviors of the module.

   The OpenSIPS user location implementation is cluster-enabled.
   On top of supporting traditional "single instance" setups, it
   also allows multiple OpenSIPS user location nodes to form a
   single, global user location cluster. This allows high-level
   features such as startup synchronization (data tunneling) from
   a random, healthy "donor" node and evenly distributed NAT
   pinging workloads.

1.2. Distributed SIP User Location

   Starting with OpenSIPS 2.4, the user location module offers
   several optional data distribution models, each tailoring to
   specific real-life production use cases. Built on top of the
   OpenSIPS clustering module, these models take into account
   service concerns such as high availability, geographical
   distribution, horizontal scalability and NAT traversal.

   Depending on data locality, the distribution models are split
   in two main categories:

1.2.1. "Federation" Topology

   A federated user location keeps contact data local to the
   original OpenSIPS node the contact initially registered to. In
   order to share the reachability of these contacts with the
   global OpenSIPS user location cluster, registrar nodes will
   only publish some light "metadata" entries for any new
   Addresses-of-Record which are reachable from them. These
   entries will cause other nodes to also fork additional SIP
   branches pointing to the above-mentioned registrar upon
   receiving a call for the above-mentioned Addresses-of-Record.

   The federation topology is an optimized solution for the
   following core problems:
     * IP restrictions - In some cases, calls routed towards
       registered contacts must necessarily egress through the
       original registration nodes of these contacts. A classic
       example of this situation is when an OpenSIPS registrar
       sitting at the edge of the platform is directly facing a
       NAT device on the way to the contact. Unless calls are sent
       out from this exact registrar, they will not be able to
       traverse the NAT device and reach the contact.
     * horizontal scalability - Avoiding global
       replication/contact broadcasting within the cluster not
       only dramatically improves contact storage performance, but
       also leads to better service scalability. Different
       geographical locations can be sized according to their
       local subscriber populations (traffic may be balanced to
       them using DNS SRV weights, for example), without losing
       platform-wide reachability.

   Currently, the metadata information may be published to NoSQL
   databases which support key/multi-value column-like
   associations. Example known backends to support these
   abstractions at the time of writing are MongoDB and Cassandra.

   The federated user location tutorial contains precise details
   on how to achieve this setup (including High Availability
   support).

1.2.2. "Full Sharing" Topology

   A fully sharing user location broadcasts contact information to
   all data nodes (OpenSIPS or NoSQL). The main assumption behind
   this mode is that any routing restrictions have been alleviated
   beforehand. Consequently, either SIP traffic egressing from a
   "full sharing" OpenSIPS user location topology is being
   intermediated by an additional SIP edge endpoint of our
   platform, or there are no egress IP restrictions at all (for
   example, if all SIP UAs have public IPs). In this setup, all
   OpenSIPS user location nodes are equivalent to one another, as
   they each have access to the same dataset and have no routing
   restrictions.

   The full sharing topology is an appropriate solution for
   multi-layer VoIP platforms, where the OpenSIPS registrar nodes
   do not directly interact with external SIP endpoints. Moreover,
   it can be configured to fully store contact data within a NoSQL
   cluster (zero in-memory storage), thus taking full advantage of
   the data sharing, sharding, migration and other capabilities of
   a specialized distributed data handling engine.

   Additionally, a "full sharing" topology can be used to achieve
   a basic "hot backup" high-availability setup with an
   active-passive registrar nodes configuration, both of which
   make use of a shared virtual IP.

   Registrations may optionally be fully managed inside NoSQL
   databases which support key/multi-value column-like
   associations. Example known backends to currently support these
   abstractions are MongoDB and Apache Cassandra.

   The "full sharing" user location tutorial contains precise
   details on how to achieve this setup (including full NoSQL
   storage support).

1.2.3. "N Contact Pings" Problem

   A long-standing problem caused by contact information being
   replicated to multiple SIP registrar instances directly through
   replication or indirectly through a globally reachable
   database. As long as traditionally clusterized nodes are not
   aware of each other, they will each scan the entire contact
   dataset, thus periodically sending "N pings" instead of "1
   ping" for each contact. This difference directly affects
   service scalability, as well as the amount of consumed
   resources such as CPU and network bandwidth, both on the
   service and client side.

   This problem is solved with the help of the OpenSIPS cluster
   layer, which makes all nodes aware of each others' presence.
   Thus, the distributed user location node topologies are able to
   collectively partition the pinging workload and spread it
   evenly across the current number of cluster nodes, at any given
   point in time. The pinging_mode module parameter describes the
   built-in pinging heuristics in more detail.

1.3. Contact matching

   Contact matching (for the same Address-of-Record, AoR) is an
   important aspect of a SIP user location service, especially in
   the context of NAT traversal. The latter raises more problems,
   since contacts from different phones of same users may overlap
   (if behind NATs with identical configurations) or the
   re-register Contact of the same SIP User Agent may be seen as a
   new one (due to the request arriving via a new NAT binding).

   The SIP RFC 3261 publishes a matching algorithm based only on
   the contact string with Call-ID and CSeq number extra checking
   (if the Call-ID matches, it must have a higher CSeq number,
   otherwise the registration is invalid). But as argumented
   above, this is not enough in a NAT traversal context, so the
   OpenSIPS implementation of contact matching offers more
   algorithms:
     * Contact based only - strict RFC 3261 compliancy - the
       contact is matched as string and extra checked via Call-ID
       and CSeq (if Call-ID is the same, it must have a higher
       CSeq number, otherwise the registration is invalid).
     * Contact and Call-ID based - an extension of the first case
       - the Contact and Call-ID header field values must match as
       strings; the CSeq must be higher than the previous one - so
       be careful how you deal with REGISTER retransmissions in
       this case.

   For more details on how to control/select the contact matching
   algorithm, please go to matching_mode.

1.4. Dependencies

1.4.1. OpenSIPS Modules

   The following modules must be loaded before this module:
     * Optionally an SQL database module.
     * Optionally a NoSQL database module.
     * clusterer, if cluster_mode is different than "none".

1.4.2. External Libraries or Applications

   The following libraries or applications must be installed
   before running OpenSIPS with this module loaded:
     * None.

1.5. Exported Parameters

1.5.1. nat_bflag (string)

   The name of the branch flag to be used as NAT marker (if the
   contact is or not natted). This is a branch flag and it will be
   imported and used by all other modules depending on the usrloc
   module.

   Default value is NULL (not set).

   Example 1.1. Set nat_bflag parameter
...
modparam("usrloc", "nat_bflag", "NAT_BFLAG")
...

1.5.2. contact_id_column (string)

   Name of the column holding the unique contact IDs.

   Default value is “contact_id”.

   Example 1.2. Set contact_id_column parameter
...
modparam("usrloc", "contact_id_column", "ctid")
...

1.5.3. user_column (string)

   Name of column containing usernames.

   Default value is “username”.

   Example 1.3. Set user_column parameter
...
modparam("usrloc", "user_column", "username")
...

1.5.4. domain_column (string)

   Name of column containing domains.

   Default value is “domain”.

   Example 1.4. Set user_column parameter
...
modparam("usrloc", "domain_column", "domain")
...

1.5.5. contact_column (string)

   Name of column containing contacts.

   Default value is “contact”.

   Example 1.5. Set contact_column parameter
...
modparam("usrloc", "contact_column", "contact")
...

1.5.6. expires_column (string)

   Name of column containing expires value.

   Default value is “expires”.

   Example 1.6. Set expires_column parameter
...
modparam("usrloc", "expires_column", "expires")
...

1.5.7. q_column (string)

   Name of column containing q values.

   Default value is “q”.

   Example 1.7. Set q_column parameter
...
modparam("usrloc", "q_column", "q")
...

1.5.8. callid_column (string)

   Name of column containing callid values.

   Default value is “callid”.

   Example 1.8. Set callid_column parameter
...
modparam("usrloc", "callid_column", "callid")
...

1.5.9. cseq_column (string)

   Name of column containing cseq numbers.

   Default value is “cseq”.

   Example 1.9. Set cseq_column parameter
...
modparam("usrloc", "cseq_column", "cseq")
...

1.5.10. methods_column (string)

   Name of column containing supported methods.

   Default value is “methods”.

   Example 1.10. Set methods_column parameter
...
modparam("usrloc", "methods_column", "methods")
...

1.5.11. flags_column (string)

   Name of column to save the internal flags of the record.

   Default value is “flags”.

   Example 1.11. Set flags_column parameter
...
modparam("usrloc", "flags_column", "flags")
...

1.5.12. cflags_column (string)

   Name of column to save the branch/contact flags of the record.

   Default value is “cflags”.

   Example 1.12. Set cflags_column parameter
...
modparam("usrloc", "cflags_column", "cflags")
...

1.5.13. user_agent_column (string)

   Name of column containing user-agent values.

   Default value is “user_agent”.

   Example 1.13. Set user_agent_column parameter
...
modparam("usrloc", "user_agent_column", "user_agent")
...

1.5.14. received_column (string)

   Name of column containing the source IP, port, and protocol
   from the REGISTER message.

   Default value is “received”.

   Example 1.14. Set received_column parameter
...
modparam("usrloc", "received_column", "received")
...

1.5.15. socket_column (string)

   Name of column containing the received socket information
   (IP:port) for the REGISTER message.

   Default value is “socket”.

   Example 1.15. Set socket_column parameter
...
modparam("usrloc", "socket_column", "socket")
...

1.5.16. path_column (string)

   Name of column containing the Path header.

   Default value is “path”.

   Example 1.16. Set path_column parameter
...
modparam("usrloc", "path_column", "path")
...

1.5.17. sip_instance_column (string)

   Name of column containing the SIP instance.

   Default value is “NULL”.

   Example 1.17. Set sip_instance_column parameter
...
modparam("usrloc", "sip_instance_column", "sip_instance")
...

1.5.18. kv_store_column (string)

   Name of column containing generic key-value data.

   Default value is “kv_store”.

   Example 1.18. Set kv_store_column parameter
...
modparam("usrloc", "kv_store_column", "json_data")
...

1.5.19. attr_column (string)

   Name of column containing additional registration-related
   information.

   Default value is “attr”.

   Example 1.19. Set attr_column parameter
...
modparam("usrloc", "attr_column", "attributes")
...

1.5.20. use_domain (integer)

   If the domain part of the user should be also saved and used
   for identifing the user (along with the username part). Useful
   in multi domain scenarios. Non 0 value means true.

   Default value is “0 (false)”.

   Example 1.20. Set use_domain parameter
...
modparam("usrloc", "use_domain", 1)
...

1.5.21. desc_time_order (integer)

   If the user's contacts should be kept timestamp ordered;
   otherwise the contact will be ordered based on q value. Non 0
   value means true.

   Default value is “0 (false)”.

   Example 1.21. Set desc_time_order parameter
...
modparam("usrloc", "desc_time_order", 1)
...

1.5.22. timer_interval (integer)

   Number of seconds between two timer runs. During each run, the
   module will update/delete dirty/expired contacts from memory
   and/or mirror these operations to the database, if configured
   to do so.

Warning

   In case of an OpenSIPS shutdown or even a crash, contacts which
   are in memory only and have not been flushed yet to disk will
   NOT get lost! OpenSIPS will try its best to do a last-minute
   sync to DB right before shutting down.

   Default value is 60.

   Example 1.22. Set timer_interval parameter
...
modparam("usrloc", "timer_interval", 120)
...

1.5.23. db_url (string)

   URL of the database that should be used.

   Default value is
   “mysql://opensips:opensipsrw@localhost/opensips”.

   Example 1.23. Set db_url parameter
...
modparam("usrloc", "db_url", "dbdriver://username:password@dbhost/dbname
")
...

1.5.24. cachedb_url (string)

   URL of a NoSQL database to be used. Only required in a
   cachedb-enabled cluster_mode.

   Default value is “none”.

   Example 1.24. Set cachedb_url parameter
...
modparam("usrloc", "cachedb_url", "mongodb://10.0.0.4:27017/opensipsDB.u
serlocation")
...

1.5.25. db_mode (integer, deprecated)

   This parameter has been kept for backwards compatibility. It
   acts as a working_mode_preset (which it also conflicts with),
   overriding any cluster_mode, restart_persistency and
   sql_write_mode settings. Possible values are:

     * 0, corresponding to "single-instance-no-db" (see below)
     * 1, corresponding to "single-instance-sql-write-through"
     * 2, corresponding to "single-instance-sql-write-back"
     * 3, corresponding to "sql-only"

   Default value is "not set".

   Example 1.25. Set db_mode parameter
...
modparam("usrloc", "db_mode", 2)
...

1.5.26. working_mode_preset (string)

   A pre-defined working mode for the usrloc module. Setting this
   parameter will override any cluster_mode, restart_persistency
   and sql_write_mode settings.

     * "single-instance-no-db" - This disables database
       completely. Only memory will be used. Contacts will not
       survive restart. Use this value if you need a really fast
       usrloc and contact persistence is not necessary or is
       provided by other means.
     * "single-instance-sql-write-through" - Write-Through scheme.
       All changes to usrloc are immediately reflected in database
       too. This is very slow, but very reliable. Use this scheme
       if speed is not your priority but need to make sure that no
       registered contacts will be lost during crash or reboot.
     * "single-instance-sql-write-back" - Write-Back scheme. This
       is a combination of previous two schemes. All changes are
       made to memory and database synchronization is done in the
       timer. The timer deletes all expired contacts and flushes
       all modified or new contacts to database. Use this scheme
       if you encounter high-load peaks and want them to process
       as fast as possible. The mode will not help at all if the
       load is high all the time. The added latency on the SIP
       signaling when using this asynchronous preset is much lower
       than the one added by the safe but blocking,
       "single-instance-sql-write-through" preset.
     * "sql-only" - DB-Only scheme. No memory cache is kept, all
       operations being directly performed with the database. The
       timer deletes all expired contacts from database - cleans
       after clients that didn't un-register or re-register. The
       mode is useful if you configure more servers sharing the
       same DB without any replication at SIP level. The mode may
       be slower due the high number of DB operation. For example
       NAT pinging is a killer since during each ping cycle all
       nated contact are loaded from the DB; The lack of memory
       caching also disable the statistics exports.
     * "federation-cachedb-cluster" - OpenSIPS will run with a
       "federation-cachedb" cluster_mode and "sync-from-cluster"
       restart_persistency. This will require the configuration of
       multiple "seed" nodes in the cluster. Refer to the
       federated user location tutorial for more details.
     * "full-sharing-cluster" - OpenSIPS will run with a
       "full-sharing" cluster_mode and "sync-from-cluster"
       restart_persistency. This will require the configuration of
       one of the nodes in the cluster as a "seed" node in order
       to bootstrap the syncing process.
     * "full-sharing-cachedb-cluster" - OpenSIPS will run with a
       "full-sharing-cachedb" cluster_mode, where all location
       data strictly resides in a NoSQL database, thus it will
       have natural restart persistency.

   Refer to section Distributed SIP User Location for details
   regarding the clustering topologies and their behavior.

   Default value is "single-instance-no-db".

   Example 1.26. Set working_mode_preset parameter
...
modparam("usrloc", "working_mode_preset", "full-sharing-cachedb-cluster"
)
...

1.5.27. cluster_mode (string)

   This parameter will get overridden if either
   working_mode_preset or db_mode is set.

   The behavior of the global OpenSIPS user location cluster.
   Refer to section Distributed SIP User Location for details.

   This parameter may take the following values:
     * "none" - single instance mode.
     * "federation-cachedb" - federation-based data sharing. Local
       AoR metadata is published inside a NoSQL database, so other
       cluster nodes can fork SIP traffic over to the current
       node. Consequently, the location_cluster and cachedb_url
       parameters are mandatory.
     * "full-sharing" - Broadcast contact updates (full-mesh
       mirroring) to all other OpenSIPS cluster participants. Each
       node will hold the entire user location dataset.
       Consequently, the location_cluster parameter is mandatory.
     * "full-sharing-cachedb" - Full contact data management
       through the use of a NoSQL database (somewhat resembling
       the "sql-only" preset). The cluster layer is still required
       in order to be able to partition and spread the pinging
       workload evenly among participating OpenSIPS nodes.
       Consequently, the location_cluster and cachedb_url
       parameters are mandatory.
     * "sql-only" - Multiple OpenSIPS boxes using a common db_url
       without necessarily being aware of each other.

   Default value is "none" (single instance mode).

   Example 1.27. Set cluster_mode parameter
...
modparam("usrloc", "cluster_mode", "federation-cachedb")
...

1.5.28. restart_persistency (string)

   This parameter will get overridden if either
   working_mode_preset or db_mode are set.

   Controls the behavior of the OpenSIPS user location following a
   restart. This parameter has no effect in some database-only
   working mode presets, where restart persistency is naturally
   ensured.

   This parameter may take the following values:
     * "none" - no explicit data synchronization following a
       restart. The node starts empty.
     * "load-from-sql" - enable SQL-based restart persistency.
       This causes all runtime in-memory writes (i.e. new
       registrations, re-registrations or de-registrations) to
       also propagate to an SQL database, from which all data will
       be imported following a restart. Choosing this value will
       make the db_url parameter mandatory, as well as cause
       sql_write_mode to default to "write-back" instead of
       "none".
     * "sync-from-cluster" - enable cluster-based restart
       persistency. Following a restart, an OpenSIPS cluster node
       will search for a healthy "donor" node from which to mirror
       the entire user location dataset via direct cluster sync
       (TCP-based, binary-encoded data transfer). Depending on the
       clustering mode and cluster topology, this will require the
       configuration of one or multiple "seed" nodes in the
       cluster. Choosing this value will make the location_cluster
       parameter mandatory.

   Default value is "none" (no restart persistency).

   Example 1.28. Set restart_persistency parameter
...
modparam("usrloc", "restart_persistency", "sync-from-cluster")
...

1.5.29. sql_write_mode (string)

   This parameter will get overridden if either
   working_mode_preset or db_mode are set.

   Only valid if restart_persistency is enabled. Controls the
   runtime behavior of OpenSIPS writes to the SQL database.

   This parameter may take the following values:
     * "none" - do not perform any additional SQL writes at
       runtime to an SQL database in order to specifically ensure
       restart persistency.
     * "write-through" - all in-memory writes (i.e. new
       registrations, re-registrations or de-registrations) also
       propagate into the SQL database, inline. While this will
       definitely slow down registration performance (lookups are
       served from memory!), it has the advantage of making the
       instance crash-safe.
     * "write-back" - all in-memory writes (i.e. new
       registrations, re-registrations or de-registrations)
       eventually also propagate into the SQL database, thanks to
       a separate timer routine. This dramatically speeds up
       registrations, but also introduces the possibility of
       crashing before the latest contact changes are propagated
       to the database. See the timer_interval for additional
       configuration.

   Default value is "none" (no added SQL writes).

   Example 1.29. Set sql_write_mode parameter
...
modparam("usrloc", "sql_write_mode", "write-back")
...

1.5.30. matching_mode (integer)

   What contact matching algorithm to be used. Refer to section
   Contact Matching for the description of the algorithms.

   The parameter may take the following values:
     * 0 - CONTACT ONLY based matching algorithm.
     * 1 - CONTACT and CALLID based matching algorithm.

   Default value is 0 (CONTACT_ONLY).

   Example 1.30. Set matching_mode parameter
...
modparam("usrloc", "matching_mode", 1)
...

1.5.31. cseq_delay (integer)

   Delay (in seconds) for accepting as retransmissions register
   requests with same Call-ID and Cseq. The delay is calculated
   starting from the receiving time of the first register with
   that Call-ID and Cseq.

   Retransmissions within this delay interval will be accepted and
   replied as the original request, but no update will be done in
   location. If the delay is exceeded, error is reported.

   A value of 0 disable the retransmission detection.

   Default value is “20 seconds”.

   Example 1.31. Set cseq_delay parameter
...
modparam("usrloc", "cseq_delay", 5)
...

1.5.32. location_cluster (integer)

   Specifies the cluster ID which this instance will send to and
   receive from all user-location related information
   (addresses-of-record, contacts), organized into specific events
   (inserts, deletes or updates).

   Default value is 0 (replication disabled).

   More details on the user location distribution mechanisms are
   available under Distributed SIP User Location.

   Example 1.32. Setting the location_cluster parameter
...
modparam("usrloc", "location_cluster", 1)
...

1.5.33. skip_replicated_db_ops (int)

   Prevent OpenSIPS from performing any DB-related contact
   operations when events are received over the Binary Interface.
   This is commonly used to prevent unneeded duplicate operations.

   Default value is "0" (upon receival of usrloc-related Binary
   Interface events, DB queries may be freely performed)

   More details on the user location replication mechanism are
   available in Distributed SIP User Location

   Example 1.33. Setting the skip_replicated_db_ops parameter
...
modparam("usrloc", "skip_replicated_db_ops", 1)
...

1.5.34. max_contact_delete (int)

   Relevant only in WRITE_THROUGH or WRITE_BACK schemes. The
   maximum number of contacts to be deleted from the database at
   once. Will delete all of them, if fewer after passing through
   all the contacts.

   Default value is "10"

   Example 1.34. Setting the max_contact_delete parameter
...
modparam("usrloc", "max_contact_delete", 10)
...

1.5.35. hash_size (integer)

   The number of entries of the hash table used by usrloc to store
   the location records is 2^hash_size. For hash_size=4, the
   number of entries of the hash table is 16. Since version 2.2,
   the maximu size of this parameter is 16, meaning that the hash
   supports maximum 65536 entries.

   Default value is “9”.

   Example 1.35. Set hash_size parameter
...
modparam("usrloc", "hash_size", 10)
...

1.5.36. regen_broken_contactid (integer)

   Since version 2.2, contact_id concept was introduced. Since
   this parameter validates a contact each time OpenSIPS is
   started, there are times when the value of this parameter
   should be regenerated. That is when location table is being
   migrated from a version older than 2.2 or when hash_size module
   parameter is changed. Enabling this parameter will regenerate
   broken contact id's based on current configurations.

   Default value is “0(not enabled)”

   Example 1.36. Set regen_broken_contactid parameter
...
modparam("usrloc", "regen_broken_contactid", 1)
...

1.5.37. latency_event_min_us (integer)

   Defines a minimal pinging latency threshold, in microseconds,
   past which contact pinging latency update events will get
   raised. By default, an event is raised for each ping reply
   (i.e. latency update).

   If both latency_event_min_us and latency_event_min_us_delta are
   set, the event will get raised if either of them is true.

   Default value is “0 (no bottom limit set)”.

   Example 1.37. Set latency_event_min_us parameter
...
# raise an event for any 425+ ms pinging latency
modparam("usrloc", "latency_event_min_us", 425000)
...

1.5.38. latency_event_min_us_delta (integer)

   Defines a minimal, absolute pinging latency difference, in
   microseconds, past which contact pinging latency update events
   will get raised. The difference is computed using the latencies
   of the last two contact pinging replies. By default, an event
   is raised for each ping reply (i.e. latency update).

   If both latency_event_min_us and latency_event_min_us_delta are
   set, the event will get raised if either of them is true.

   Default value is “0 (no minimal latency delta set)”.

   Example 1.38. Set latency_event_min_us_delta parameter
...
# raise an event only if a contact has pinging latency swings of 300+ ms
modparam("usrloc", "latency_event_min_us_delta", 300000)
...

1.5.39. pinging_mode (string)

   Depending on the cluster_mode, the module can perform contact
   pinging using one of at most two possible heuristics:
     * "ownership" - this instance will only attempt to ping a
       contact if it decides it is the logical owner of the
       contact. If a shared tag is attached to a contact, a node
       will keep sending pings to that contact as long as it owns
       the respective tag. If no shared tag has been specified for
       a given contact, the default is to assume permanent
       ownership of the contact and always ping it.
     * "cooperation" - the assumption behind this pinging
       heuristic is that all user location cluster nodes are
       symmetrical (possibly front-ended by a SIP traffic
       balancing entity), such that either of them can ping any
       contact. Under this assumption, all currently online user
       location cluster nodes will cooperate and evenly split the
       pinging workload between them by hashing AoRs modulo
       current_number_of_online_nodes, and only picking the ones
       that they are responsible for.

   Table 1.1. Possible values for the "pinging_mode", depending on
   the current "cluster_mode"
   cluster_mode none federation-cachedb full-sharing
   full-sharing-cachedb sql-only
   pinging_mode ownership ownership cooperation / ownership
   cooperation unmaintained

   Notice that only the "full-sharing" clustering mode allows some
   flexibility -- all other modes are logically tied to a single
   pinging logic. Any unaccepted value, according to the above
   table, set for those modes will be silently discarded.

   Example 1.39. Set pinging_mode parameter
...
# prepare an active/backup "full-sharing" setup, with no front-end
modparam("usrloc", "pinging_mode", "ownership")
...

1.5.40. mi_dump_kv_store (integer)

   Enable in order to include the "KV-Store" field in all usrloc
   MI commands which output AoR or Contact representations. This
   verbose field contains custom data attached to each of these
   two entities. mid_registrar makes use of both of these holders,
   for example.

   Default value is “0 (disabled)”.

   Example 1.40. Set mi_dump_kv_store parameter
...
# include the "KV-Store" key in all usrloc MI output
modparam("usrloc", "mi_dump_kv_store", 1)
...

1.6. Exported Functions

   There are no exported functions that could be used in scripts.

1.7. Exported MI Functions

1.7.1.  ul_rm

   Deletes an entire AOR record (including its contacts).

   Parameters:
     * table_name - table where the AOR is removed from (Ex:
       location).
     * aor - user AOR in username[@domain] format (domain must be
       supplied only if use_domain option is on).

1.7.2.  ul_rm_contact

   Deletes a contact from an AOR record.

   Parameters:
     * table name - table where the AOR is removed from (Ex:
       location).
     * AOR - user AOR in username[@domain] format (domain must be
       supplied only if use_domain option is on).
     * contact - exact contact to be removed

1.7.3.  ul_dump

   Dumps the entire content of the USRLOC in memory cache

   Parameters:
     * brief - (optional, may not be present); if equals to string
       “brief”, a brief dump will be done (only AOR and contacts,
       with no other details)

1.7.4.  ul_flush

   Force a flush of all pending usrloc cache changes to the
   database. Normally, this routine runs every timer_interval
   seconds.

1.7.5.  ul_add

   Adds a new contact for an user AOR.

   Parameters:
     * table name - table where the contact will be added (Ex:
       location).
     * aor - user AOR in username[@domain] format (domain must be
       supplied only if use_domain option is on).
     * contact - contact string to be added
     * expires - expires value of the contact
     * q - Q value of the contact
     * unused - unused attribute (kept for backword compatibility)
     * flags - internal USRLOC flags of the contact
     * cflags - per branch flags of the contact
     * methods - mask with supported requests of the contact

1.7.6.  ul_show_contact

   Dumps the contacts of an user AOR.

   Parameters:
     * table_name - table where the AOR resides (Ex: location).
     * aor - user AOR in username[@domain] format (domain must be
       supplied only if use_domain option is on).

1.7.7.  ul_sync

   Empty the location table, then synchronize it with all contacts
   from memory. Note that this can not be used when no database is
   specified or with the DB-Only scheme.

   Important: make sure that all your contacts are in memory
   (ul_dump MI function) before executing this command.

   Parameters:
     * table name - table where the AOR resides (Ex: location).
     * AOR (optional) - only delete/sync this user AOR, not the
       whole table. Format: "username[@domain]" (domain is
       required only if use_domain option is on).

1.7.8.  ul_cluster_sync

   This command will only take effect if the module is running
   under a cluster-enabled working_mode_preset.

   The current node will locate a healthy donor node within the
   location_cluster and issue a sync request to it. The donor node
   will then proceed to push all of its user location data over to
   the current node, via the binary interface. The received data
   will be merged with existing data. Conflicting contacts
   (matched according to matching_mode) are overwritten only if
   the sync data is newer than the current data.

1.8. Exported Statistics

   Exported statistics are listed in the next sections.

1.8.1. users

   Number of AOR existing in the USRLOC memory cache for that
   domain - can not be resetted; this statistic will be register
   for each used domain (Ex: location).

1.8.2. contacts

   Number of contacts existing in the USRLOC memory cache for that
   domain - can not be resetted; this statistic will be register
   for each used domain (Ex: location).

1.8.3. expires

   Total number of expired contacts for that domain - can be
   resetted; this statistic will be register for each used domain
   (Ex: location).

1.8.4. registered_users

   Total number of AOR existing in the USRLOC memory cache for all
   domains - can not be resetted.

1.9. Exported Events

1.9.1.  E_UL_AOR_INSERT

   This event is raised when a new AOR is inserted in the USRLOC
   memory cache.

   Parameters:
     * aor - The AOR of the inserted record.

1.9.2.  E_UL_AOR_DELETE

   This event is raised when a new AOR is deleted from the USRLOC
   memory cache.

   Parameters:
     * aor - The AOR of the deleted record.

1.9.3.  E_UL_CONTACT_INSERT

   This event is raised when a new contact is inserted in any of
   the existing AOR's contact list. For each new contact, if its
   AOR does not exist in the memory, then both the E_UL_AOR_CREATE
   and E_UL_CONTACT_INSERT events will be raised.

   Parameters:
     * aor - The AOR of the inserted contact.
     * uri - The contact URI of the inserted contact.
     * received - IP, port and protocol the registration message
       was received from. If these have the same value as the
       contact's address (see the address parameter) then the
       received parameter will be an empty string.
     * path - The PATH header value of the registration
       message.(empty string if not present)
     * qval - The Q value (priority) of the contact (as integer
       value from 0 to 10).
     * user_agent - The User-Agent header value.
       NOTICE: Can contain spaces.
     * socket - The SIP socket/listener (as string) used by
       OpenSIPS to receive the contact registations.
     * bflags - The branch flags (bflags) of the contact (in
       integer value of the bitmask)
     * expires - The expires value of the contact (as UNIX
       timestamp integer).
     * callid - The Call-ID header of the registration message.
     * cseq - The cseq number as an int value.
     * attr - The attributes string attached to the contact (the
       custom attributes attached from the script level). As this
       string is options, if missing in the contact, the event
       will push the empty string for this event field.
     * latency - The latency of the last successful ping for this
       contact. Until the first ping reply for a given contact
       arrives, its pinging latency will be 0.
     * shtag - The shared tag of the contact, which helps
       determine if the current node owns the contact (e.g.
       possibly using the $cluster.sh_tag pseudo-variable in order
       to perform the check).
       NOTICE: If a contact has no shared tag attached to it, this
       key will map to a "" (empty string) value!

1.9.4.  E_UL_CONTACT_DELETE

   This event is raised when a contact is deleted from an existing
   AOR's contact list. If the contact is the only one in the list
   then both the E_UL_AOR_DELETE and E_UL_CONTACT_DELETE events
   will be raised.

   Parameters: same as the E_UL_CONTACT_INSERT event

1.9.5.  E_UL_CONTACT_UPDATE

   This event is raised when a contact's info is updated by
   receiving another registration message.

   Parameters: same as the E_UL_CONTACT_INSERT event

1.9.6.  E_UL_LATENCY_UPDATE

   This event is raised when a contact pinging latency matches
   either of the latency_event_min_us or
   latency_event_min_us_delta filters. If none of these filters is
   set, this event will get raised for each successful contact
   ping operation.

   Parameters: same as the E_UL_CONTACT_INSERT event

Chapter 2. Developer Guide

2.1. Available Functions

2.1.1.  ul_register_domain(name)

   The function registers a new domain. Domain is just another
   name for table used in registrar. The function is called from
   fixups in registrar. It gets name of the domain as a parameter
   and returns pointer to a new domain structure. The fixup than
   'fixes' the parameter in registrar so that it will pass the
   pointer instead of the name every time save() or lookup() is
   called. Some usrloc functions get the pointer as parameter when
   called. For more details see implementation of save function in
   registrar.

   Meaning of the parameters is as follows:
     * const char* name - Name of the domain (also called table)
       to be registered.

2.1.2.  ul_insert_urecord(domain, aor, rec, is_replicated)

   The function creates a new record structure and inserts it in
   the specified domain. The record is structure that contains all
   the contacts for belonging to the specified username.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Pointer to domain returned by
       ul_register_udomain.
     * str* aor - Address of Record (aka username) of the new
       record (at this time the record will contain no contacts
       yet).
     * urecord_t** rec - The newly created record structure.
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.3.  ul_delete_urecord(domain, aor, is_replicated)

   The function deletes all the contacts bound with the given
   Address Of Record.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Pointer to domain returned by
       ul_register_udomain.
     * str* aor - Address of record (aka username) of the record,
       that should be deleted.
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.4.  ul_get_urecord(domain, aor)

   The function returns pointer to record with given Address of
   Record.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Pointer to domain returned by
       ul_register_udomain.

     * str* aor - Address of Record of request record.

2.1.5.  ul_lock_udomain(domain)

   The function lock the specified domain, it means, that no other
   processes will be able to access during the time. This prevents
   race conditions. Scope of the lock is the specified domain,
   that means, that multiple domain can be accessed
   simultaneously, they don't block each other.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Domain to be locked.

2.1.6.  ul_unlock_udomain(domain)

   Unlock the specified domain previously locked by
   ul_lock_udomain.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Domain to be unlocked.

2.1.7.  ul_release_urecord(record, is_replicated)

   Do some sanity checks - if all contacts have been removed,
   delete the entire record structure.

   Meaning of the parameters is as follows:
     * urecord_t* record - Record to be released.
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.8.  ul_insert_ucontact(record, contact, contact_info, contact,
is_replicated)

   The function inserts a new contact in the given record with
   specified parameters.

   Meaning of the parameters is as follows:
     * urecord_t* record - Record in which the contact should be
       inserted.
     * str* contact - Contact URI.
     * ucontact_info_t* contact_info - Single structure containing
       the new contact information
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.9.  ul_delete_ucontact (record, contact, is_replicated)

   The function deletes given contact from record.

   Meaning of the parameters is as follows:
     * urecord_t* record - Record from which the contact should be
       removed.

     * ucontact_t* contact - Contact to be deleted.
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.10.  ul_delete_ucontact_from_id (domain, contact_id)

   The function deletes a contact with the given contact_id from
   the given domain.

   Meaning of the parameters is as follows:
     * udomain_t* domain - Domain where the contact can be found.

     * uint64_t contact_id - Contact_id identifying the contact to
       be deleted.

2.1.11.  ul_get_ucontact(record, contact)

   The function tries to find contact with given Contact URI and
   returns pointer to structure representing the contact.

   Meaning of the parameters is as follows:
     * urecord_t* record - Record to be searched for the contact.

     * str_t* contact - URI of the request contact.

2.1.12.  ul_get_domain_ucontacts (domain, buf, len, flags)

   The function retrieves all contacts of all registered users
   from the given doamin and returns them in the caller-supplied
   buffer. If the buffer is too small, the function returns
   positive value indicating how much additional space would be
   necessary to accommodate all of them. Please note that the
   positive return value should be used only as a “hint”, as there
   is no guarantee that during the time between two subsequent
   calls number of registered contacts will remain the same.

   If flag parameter is set to non-zero value then only contacts
   that have the specified flags set will be returned. It is, for
   example, possible to list only contacts that are behind NAT.

   Meaning of the parameters is as follows:
     * udomaint_t* domain - Domain from which to get the contacts

     * void* buf - Buffer for returning contacts.

     * int len - Length of the buffer.

     * unsigned int flags - Flags that must be set.

2.1.13.  ul_get_all_ucontacts (buf, len, flags)

   The function retrieves all contacts of all registered users and
   returns them in the caller-supplied buffer. If the buffer is
   too small, the function returns positive value indicating how
   much additional space would be necessary to accommodate all of
   them. Please note that the positive return value should be used
   only as a “hint”, as there is no guarantee that during the time
   between two subsequent calls number of registered contacts will
   remain the same.

   If flag parameter is set to non-zero value then only contacts
   that have the specified flags set will be returned. It is, for
   example, possible to list only contacts that are behind NAT.

   Meaning of the parameters is as follows:
     * void* buf - Buffer for returning contacts.

     * int len - Length of the buffer.

     * unsigned int flags - Flags that must be set.

2.1.14.  ul_update_ucontact(record, contact, contact_info,
is_replicated)

   The function updates contact with new values.

   Meaning of the parameters is as follows:
     * urecord_t* record - Record in which the contact should be
       inserted.
     * ucontact_t* contact - Contact URI.
     * ucontact_info_t* contact_info - Single structure containing
       the new contact information
     * char is_replicated - Specifies whether this function will
       be called from the context of a Binary Interface callback.
       If uncertain, simply use 0.

2.1.15.  ul_bind_ursloc( api )

   The function imports all functions that are exported by the
   USRLOC module. Overs for other modules which want to user the
   internal USRLOC API an easy way to load and access the
   functions.

   Meaning of the parameters is as follows:
     * usrloc_api_t* api - USRLOC API

2.1.16.  ul_register_ulcb(type ,callback, param)

   The function register with USRLOC a callback function to be
   called when some event occures inside USRLOC.

   Meaning of the parameters is as follows:
     * int types - type of event for which the callback should be
       called (see usrloc/ul_callback.h).
     * ul_cb f - callback function; see usrloc/ul_callback.h for
       prototype.
     * void *param - some parameter to be passed to the callback
       each time when it is called.

2.1.17.  ul_get_num_users()

   The function loops through all domains summing up the number of
   users.

Chapter 3. Contributors

3.1. By Commit Statistics

   Table 3.1. Top contributors by DevScore^(1), authored
   commits^(2) and lines added/removed^(3)
     Name DevScore Commits Lines ++ Lines --
   1. Jan Janak (@janakj) 421 117 15689 10095
   2. Bogdan-Andrei Iancu (@bogdan-iancu) 243 145 4198 3609
   3. Liviu Chircu (@liviuchircu) 241 153 6268 2082
   4. Ionut Ionita (@ionutrazvanionita) 41 24 1099 413
   5. Daniel-Constantin Mierla (@miconda) 40 29 544 308
   6. Vlad Patrascu (@rvlad-patrascu) 40 21 770 633
   7. Jiri Kuthan (@jiriatipteldotorg) 36 25 975 120
   8. Razvan Crainea (@razvancrainea) 28 22 380 121
   9. Henning Westerholt (@henningw) 22 11 462 356
   10. Andrei Pelinescu-Onciul 17 13 151 91

   All remaining contributors: Vlad Paiu (@vladpaiu), Nils
   Ohlmeier, Eseanu Marius Cristian (@eseanucristian), Ovidiu Sas
   (@ovidiusas), Ionel Cerghit (@ionel-cerghit), Maksym Sobolyev
   (@sobomax), Andrei Dragus, Alessio Garzi (@Ozzyboshi), Dusan
   Klinec, Andrei Datcu (@andrei-datcu), Juha Heinanen (@juha-h),
   Anca Vamanu, Marcus Hunger, Jamey Hicks, Andreas Granig, Shlomi
   Gutman, @jalung, Jeffrey Magder, Phil D'Amore, Norman
   Brandinger (@NormB), David Sanders, Konstantin Bokarius, Walter
   Doekes (@wdoekes), Klaus Darilion, Iouri Kharon, Aron Podrigal
   (@ar45), Dan Pascu (@danpascu), Matthew M. Boedicker, Peter
   Lemenkov (@lemenkov), UnixDev, Edson Gellert Schubert, Alexey
   Vasilyev (@vasilevalex), Elena-Ramona Modroiu, Stephane Alnet.

   (1) DevScore = author_commits + author_lines_added /
   (project_lines_added / project_commits) + author_lines_deleted
   / (project_lines_deleted / project_commits)

   (2) including any documentation-related commits, excluding
   merge commits. Regarding imported patches/code, we do our best
   to count the work on behalf of the proper owner, as per the
   "fix_authors" and "mod_renames" arrays in
   opensips/doc/build-contrib.sh. If you identify any
   patches/commits which do not get properly attributed to you,
   please submit a pull request which extends "fix_authors" and/or
   "mod_renames".

   (3) ignoring whitespace edits, renamed files and auto-generated
   files

3.2. By Commit Activity

   Table 3.2. Most recently active contributors^(1) to this module
                      Name                   Commit Activity
   1.  Liviu Chircu (@liviuchircu)         Jan 2013 - Jan 2020
   2.  Alexey Vasilyev (@vasilevalex)      Dec 2019 - Dec 2019
   3.  Bogdan-Andrei Iancu (@bogdan-iancu) Mar 2002 - Nov 2019
   4.  Razvan Crainea (@razvancrainea)     Jul 2011 - Sep 2019
   5.  Aron Podrigal (@ar45)               Aug 2019 - Aug 2019
   6.  Alessio Garzi (@Ozzyboshi)          Aug 2019 - Aug 2019
   7.  Vlad Patrascu (@rvlad-patrascu)     Jul 2016 - Jul 2019
   8.  Dan Pascu (@danpascu)               May 2019 - May 2019
   9.  Walter Doekes (@wdoekes)            Apr 2019 - Apr 2019
   10. Peter Lemenkov (@lemenkov)          Jun 2018 - Jun 2018

   All remaining contributors: Shlomi Gutman, @jalung, Vlad Paiu
   (@vladpaiu), Ionut Ionita (@ionutrazvanionita), Ionel Cerghit
   (@ionel-cerghit), Ovidiu Sas (@ovidiusas), Dusan Klinec, Eseanu
   Marius Cristian (@eseanucristian), David Sanders, Andrei Datcu
   (@andrei-datcu), Stephane Alnet, Andrei Dragus, Phil D'Amore,
   UnixDev, Daniel-Constantin Mierla (@miconda), Henning
   Westerholt (@henningw), Iouri Kharon, Konstantin Bokarius,
   Edson Gellert Schubert, Anca Vamanu, Matthew M. Boedicker,
   Marcus Hunger, Elena-Ramona Modroiu, Jeffrey Magder, Norman
   Brandinger (@NormB), Andreas Granig, Juha Heinanen (@juha-h),
   Klaus Darilion, Jan Janak (@janakj), Andrei Pelinescu-Onciul,
   Jiri Kuthan (@jiriatipteldotorg), Maksym Sobolyev (@sobomax),
   Jamey Hicks, Nils Ohlmeier.

   (1) including any documentation-related commits, excluding
   merge commits

Chapter 4. Documentation

4.1. Contributors

   Last edited by: Liviu Chircu (@liviuchircu), Alexey Vasilyev
   (@vasilevalex), Vlad Patrascu (@rvlad-patrascu), Peter Lemenkov
   (@lemenkov), Bogdan-Andrei Iancu (@bogdan-iancu), Razvan
   Crainea (@razvancrainea), Ionut Ionita (@ionutrazvanionita),
   Eseanu Marius Cristian (@eseanucristian), Ovidiu Sas
   (@ovidiusas), Andrei Datcu (@andrei-datcu), Daniel-Constantin
   Mierla (@miconda), Konstantin Bokarius, Edson Gellert Schubert,
   Henning Westerholt (@henningw), Marcus Hunger, Elena-Ramona
   Modroiu, Juha Heinanen (@juha-h), Jan Janak (@janakj), Maksym
   Sobolyev (@sobomax), Nils Ohlmeier.

   Documentation Copyrights:

   Copyright © 2018 www.opensips-solutions.com

   Copyright © 2005-2008 Voice Sistem SRL

   Copyright © 2003 FhG FOKUS
